# Story 2.13: Git Workflow Process Implementation

## 📋 문서 정보
- **문서 버전**: 1.0
- **작성일**: 2025-08-28
- **작성자**: Frontend Team
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **상태**: Active
- **관련 아키텍처 문서**: [23-git-workflow-process.md](../ui-architecture/23-git-workflow-process.md)

---

## 🎯 스토리 목표

바로캘린더 프로젝트의 **체계적인 Git 워크플로우 프로세스**를 구현하여 팀 협업 효율성을 극대화하고 코드 품질을 보장하는 개발 환경을 구축한다.

### 주요 구현 사항
- **GitFlow 기반 브랜치 전략** 및 명명 규칙 적용
- **Conventional Commits** 표준을 따른 커밋 메시지 시스템
- **Pull Request 템플릿** 및 코드 리뷰 프로세스 자동화
- **GitHub Actions** 기반 CI/CD 파이프라인 구축

---

## 👤 사용자 스토리

### US 2.13.1: 체계적인 브랜치 관리
**As a** 개발팀원  
**I want** 명확한 브랜치 전략과 명명 규칙을 통해 체계적으로 코드를 관리하기를  
**So that** 팀원들과 효율적으로 협업하고 코드 충돌을 최소화할 수 있다.

**인수 조건:**
- [ ] GitFlow 기반 브랜치 전략 (main, develop, feature, release, hotfix) 구현
- [ ] 일관된 브랜치 명명 규칙 적용
- [ ] 브랜치 보호 규칙 설정으로 직접 푸시 방지
- [ ] 자동 브랜치 정리 스크립트 구현

### US 2.13.2: 표준화된 커밋 및 PR 프로세스
**As a** 개발팀원  
**I want** Conventional Commits 표준을 따른 커밋 메시지와 체계적인 PR 프로세스를 사용하기를  
**So that** 코드 변경 사항을 명확하게 추적하고 자동화된 릴리스 노트를 생성할 수 있다.

**인수 조건:**
- [ ] Conventional Commits 형식 자동 검증
- [ ] PR 템플릿으로 일관된 문서화
- [ ] 코드 리뷰 가이드라인 및 승인 프로세스
- [ ] 자동화된 커밋 메시지 검증 도구

### US 2.13.3: CI/CD 파이프라인 자동화
**As a** 개발팀  
**I want** GitHub Actions를 통한 자동화된 CI/CD 파이프라인을 구축하기를  
**So that** 코드 품질을 보장하고 배포 과정을 자동화할 수 있다.

**인수 조건:**
- [ ] 자동화된 린트, 타입 체크, 테스트 실행
- [ ] PR 생성 시 자동 품질 검사
- [ ] main 브랜치 머지 시 자동 배포
- [ ] 빌드 실패 시 알림 시스템

---

## 🔧 기술적 구현 요구사항

### 1. Git Hooks 설정 시스템

**주요 파일**: `scripts/setup-git-hooks.sh`

```bash
#!/bin/bash
# scripts/setup-git-hooks.sh

echo "🔧 Setting up Git hooks for Baro Calendar..."

# Git hooks 디렉토리 생성
mkdir -p .git/hooks

# Pre-commit hook 설정
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/sh
# Pre-commit hook for Baro Calendar

echo "🔍 Running pre-commit checks..."

# 1. ESLint 검사
echo "📝 Running ESLint..."
npm run lint
if [ $? -ne 0 ]; then
  echo "❌ ESLint 검사 실패. 커밋이 중단됩니다."
  echo "💡 'npm run lint:fix'를 실행하여 자동 수정을 시도해보세요."
  exit 1
fi

# 2. TypeScript 타입 검사  
echo "🔍 Running TypeScript type checking..."
npm run type-check
if [ $? -ne 0 ]; then
  echo "❌ TypeScript 타입 검사 실패. 커밋이 중단됩니다."
  exit 1
fi

# 3. 클라이언트 검사 (client 폴더 존재 시)
if [ -d "client" ]; then
  echo "🔍 Running client-side checks..."
  cd client
  
  npm run lint
  if [ $? -ne 0 ]; then
    echo "❌ Client ESLint 검사 실패."
    cd ..
    exit 1
  fi
  
  npm run type-check
  if [ $? -ne 0 ]; then
    echo "❌ Client TypeScript 검사 실패."
    cd ..
    exit 1
  fi
  
  cd ..
fi

# 4. 단위 테스트 실행 (빠른 테스트만)
echo "🧪 Running quick tests..."
npm run test:unit
if [ $? -ne 0 ]; then
  echo "❌ 단위 테스트 실패. 커밋이 중단됩니다."
  echo "💡 'npm run test:unit -- --watch'로 테스트를 확인해보세요."
  exit 1
fi

# 5. 코드 포맷팅 검사
echo "💄 Checking code formatting..."
npm run format:check
if [ $? -ne 0 ]; then
  echo "❌ 코드 포맷팅이 일치하지 않습니다."
  echo "💡 'npm run format'을 실행하여 자동 포맷팅을 적용하세요."
  exit 1
fi

echo "✅ Pre-commit 검사 완료"
EOF

# Commit message hook 설정
cat > .git/hooks/commit-msg << 'EOF'
#!/bin/sh
# Commit message validation for Conventional Commits

commit_file="$1"
commit_msg=$(cat "$commit_file")

# Conventional Commits 정규표현식
commit_regex='^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?: .{1,72}'

# 머지 커밋 예외처리
if echo "$commit_msg" | grep -q "^Merge "; then
  echo "✅ Merge commit detected, skipping validation"
  exit 0
fi

# 리버트 커밋 예외처리  
if echo "$commit_msg" | grep -q "^Revert "; then
  echo "✅ Revert commit detected, skipping validation"
  exit 0
fi

# WIP 커밋 허용 (개발 중)
if echo "$commit_msg" | grep -q "^WIP: "; then
  echo "✅ WIP commit detected, allowing for development"
  exit 0
fi

# Conventional Commits 형식 검증
if ! echo "$commit_msg" | grep -qE "$commit_regex"; then
  echo "❌ 커밋 메시지가 Conventional Commits 형식을 따르지 않습니다."
  echo ""
  echo "올바른 형식:"
  echo "  <type>[optional scope]: <description>"
  echo ""
  echo "사용 가능한 타입:"
  echo "  feat:     새로운 기능"
  echo "  fix:      버그 수정"  
  echo "  docs:     문서 변경"
  echo "  style:    코드 스타일 변경 (포맷팅, 세미콜론 등)"
  echo "  refactor: 기능 변경 없는 코드 리팩토링"
  echo "  perf:     성능 개선"
  echo "  test:     테스트 추가/수정"
  echo "  chore:    빌드, 의존성 관리 등"
  echo "  ci:       CI/CD 설정 변경"
  echo "  build:    빌드 시스템 변경"
  echo ""
  echo "예시:"
  echo "  feat(calendar): add month view navigation"
  echo "  fix(auth): resolve token expiration issue"
  echo "  docs(readme): update installation guide"
  echo ""
  echo "현재 커밋 메시지: '$commit_msg'"
  exit 1
fi

echo "✅ 커밋 메시지 검증 완료"
EOF

# Pre-push hook 설정
cat > .git/hooks/pre-push << 'EOF'
#!/bin/sh
# Pre-push hook for additional checks

echo "🚀 Running pre-push checks..."

# 1. 전체 테스트 실행 (develop/main 브랜치에 푸시할 때)
current_branch=$(git rev-parse --abbrev-ref HEAD)

if [ "$current_branch" = "develop" ] || [ "$current_branch" = "main" ]; then
  echo "🧪 Running full test suite for $current_branch branch..."
  npm run test
  if [ $? -ne 0 ]; then
    echo "❌ 전체 테스트 실패. 푸시가 중단됩니다."
    exit 1
  fi
  
  echo "🏗️ Running build check..."
  npm run build
  if [ $? -ne 0 ]; then
    echo "❌ 빌드 실패. 푸시가 중단됩니다."
    exit 1
  fi
fi

echo "✅ Pre-push 검사 완료"
EOF

# 실행 권한 부여
chmod +x .git/hooks/pre-commit
chmod +x .git/hooks/commit-msg  
chmod +x .git/hooks/pre-push

echo "✅ Git hooks 설정 완료!"
echo "💡 이제 커밋할 때 자동으로 코드 검사가 실행됩니다."
```

### 2. GitHub Actions CI/CD 워크플로우

**주요 파일**: `.github/workflows/ci-cd.yml`

```yaml
# .github/workflows/ci-cd.yml
name: Baro Calendar CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  release:
    types: [ published ]

env:
  NODE_VERSION: '20.x'
  CACHE_NAME: baro-calendar

jobs:
  # 코드 품질 및 테스트 검사
  quality-check:
    name: Quality Check
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.npm
          client/node_modules
          node_modules
        key: ${{ env.CACHE_NAME }}-${{ runner.os }}-${{ matrix.node-version }}-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ env.CACHE_NAME }}-${{ runner.os }}-${{ matrix.node-version }}-
    
    - name: Install root dependencies
      run: npm ci
    
    - name: Install client dependencies
      run: |
        if [ -d "client" ]; then
          cd client
          npm ci
          cd ..
        fi
    
    - name: Run ESLint
      run: |
        npm run lint
        if [ -d "client" ]; then
          cd client && npm run lint && cd ..
        fi
    
    - name: Run TypeScript type checking
      run: |
        npm run type-check
        if [ -d "client" ]; then
          cd client && npm run type-check && cd ..
        fi
    
    - name: Run unit tests with coverage
      run: |
        npm run test:coverage
        if [ -d "client" ]; then
          cd client && npm run test:coverage && cd ..
        fi
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        name: baro-calendar-coverage
        fail_ci_if_error: false

  # 보안 검사
  security-check:
    name: Security Check
    runs-on: ubuntu-latest
    needs: quality-check
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run security audit
      run: |
        npm audit --audit-level high
        if [ -d "client" ]; then
          cd client && npm audit --audit-level high && cd ..
        fi
    
    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: javascript
    
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

  # E2E 테스트
  e2e-test:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: quality-check
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        npm ci
        if [ -d "client" ]; then
          cd client && npm ci && cd ..
        fi
    
    - name: Build application
      run: |
        npm run build
        if [ -d "client" ]; then
          cd client && npm run build && cd ..
        fi
    
    - name: Install Playwright browsers
      run: |
        if [ -d "client" ]; then
          cd client && npx playwright install && cd ..
        fi
    
    - name: Run E2E tests
      run: |
        if [ -d "client" ] && [ -f "client/playwright.config.ts" ]; then
          cd client && npm run test:e2e && cd ..
        fi
    
    - name: Upload Playwright report
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: playwright-report
        path: client/playwright-report/
        retention-days: 7

  # 빌드 검증
  build-check:
    name: Build Check
    runs-on: ubuntu-latest
    needs: [quality-check, security-check]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        npm ci
        if [ -d "client" ]; then
          cd client && npm ci && cd ..
        fi
    
    - name: Build production
      run: |
        npm run build
        if [ -d "client" ]; then
          cd client && npm run build && cd ..
        fi
    
    - name: Check build size
      run: |
        if [ -d "client/dist" ]; then
          cd client
          echo "📊 Build size analysis:"
          du -sh dist/*
          
          # 빌드 크기 임계치 체크 (예: 2MB)
          build_size=$(du -s dist | cut -f1)
          max_size=2048  # KB
          
          if [ $build_size -gt $max_size ]; then
            echo "⚠️  Build size ($build_size KB) exceeds threshold ($max_size KB)"
            echo "Please optimize bundle size"
            exit 1
          fi
          cd ..
        fi
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: build-artifacts
        path: |
          client/dist/
        retention-days: 7

  # 스테이징 배포 (develop 브랜치)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-check, e2e-test]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install and build
      run: |
        npm ci
        if [ -d "client" ]; then
          cd client && npm ci && npm run build && cd ..
        fi
    
    - name: Deploy to staging
      run: |
        echo "🚀 Deploying to staging environment..."
        # 실제 배포 스크립트 실행
        # npm run deploy:staging
    
    - name: Run smoke tests
      run: |
        echo "🔍 Running smoke tests..."
        # 기본적인 헬스 체크
        # npm run test:smoke

  # 프로덕션 배포 (main 브랜치)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-check, e2e-test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Install and build
      run: |
        npm ci
        if [ -d "client" ]; then
          cd client && npm ci && npm run build:production && cd ..
        fi
    
    - name: Deploy to production
      run: |
        echo "🚀 Deploying to production environment..."
        # 실제 프로덕션 배포 스크립트 실행
        # npm run deploy:production
    
    - name: Run production health checks
      run: |
        echo "🏥 Running production health checks..."
        # 프로덕션 헬스 체크
        # npm run test:health

  # 알림
  notify:
    name: Notify Results
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: Notify Slack
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#dev-notifications'
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

### 3. PR 템플릿 및 브랜치 보호 설정

**주요 파일**: `.github/pull_request_template.md`

```markdown
<!-- .github/pull_request_template.md -->
## 📋 작업 내용

### 🎯 변경 사항
- [ ] **새로운 기능 추가**: 
- [ ] **기존 기능 수정**: 
- [ ] **버그 수정**: 
- [ ] **성능 개선**: 
- [ ] **리팩토링**: 
- [ ] **문서 업데이트**: 
- [ ] **테스트 추가**: 
- [ ] **설정 변경**: 

### 📝 상세 설명
<!-- 구현한 기능이나 수정 사항에 대한 상세한 설명을 작성해주세요 -->


## 🖼️ 스크린샷 (UI 변경 시)
<!-- UI 변경이 있는 경우 Before/After 스크린샷을 첨부해주세요 -->
| Before | After |
|--------|-------|
| 스크린샷 | 스크린샷 |

## 🧪 테스트

### 테스트 범위
- [ ] 단위 테스트 추가/수정
- [ ] 통합 테스트 추가/수정  
- [ ] E2E 테스트 추가/수정
- [ ] 수동 테스트 완료

### 테스트 시나리오
<!-- 주요 테스트 시나리오를 작성해주세요 -->
1. 
2. 
3. 

## ✅ 체크리스트

### 코드 품질
- [ ] ESLint 규칙을 모두 통과합니다
- [ ] TypeScript 컴파일 에러가 없습니다
- [ ] 모든 테스트가 통과합니다
- [ ] 코드 리뷰가 완료되었습니다

### 성능 및 보안
- [ ] 성능에 부정적인 영향이 없습니다
- [ ] 보안 취약점이 없습니다
- [ ] 메모리 누수가 없습니다
- [ ] 번들 크기 증가가 합리적입니다

### 사용자 경험
- [ ] 브라우저 호환성을 확인했습니다 (Chrome, Firefox, Safari, Edge)
- [ ] 모바일 반응형 디자인이 적용되었습니다
- [ ] 접근성 기준을 준수합니다 (WCAG 2.1 AA)
- [ ] 로딩 상태 및 에러 처리가 적절합니다

### 문서화
- [ ] README가 업데이트되었습니다 (필요시)
- [ ] API 문서가 업데이트되었습니다 (필요시)
- [ ] 주석이 적절히 추가되었습니다
- [ ] 변경 사항이 CHANGELOG에 반영되었습니다

## 🔗 관련 이슈 및 PR

### 관련 이슈
- Closes #이슈번호
- Fixes #이슈번호  
- Related to #이슈번호

### 의존성 PR
- Depends on #PR번호
- Blocks #PR번호

## 🚨 주의사항

### Breaking Changes
- [ ] 이 변경사항은 Breaking Change입니다
- [ ] 마이그레이션 가이드가 필요합니다

### 특별한 배포 요구사항
- [ ] 데이터베이스 마이그레이션 필요
- [ ] 환경 변수 업데이트 필요
- [ ] 제3자 서비스 설정 변경 필요
- [ ] 캐시 초기화 필요

### 배포 후 확인사항
- [ ] 헬스 체크 모니터링
- [ ] 로그 모니터링
- [ ] 성능 메트릭 확인
- [ ] 사용자 피드백 모니터링

## 📝 추가 정보

### 리뷰어에게
<!-- 리뷰어가 특히 집중해서 봐야 할 부분이나 알아야 할 컨텍스트를 작성해주세요 -->


### 참고 자료
<!-- 관련 문서, 디자인, 스펙 등의 링크를 첨부해주세요 -->
- 

---

**리뷰어 체크리스트 (리뷰어용)**
- [ ] 코드 로직이 명확하고 이해하기 쉽습니다
- [ ] 네이밍이 일관되고 의미가 명확합니다
- [ ] 에러 처리가 적절합니다
- [ ] 성능상 문제가 없습니다
- [ ] 보안상 문제가 없습니다
- [ ] 테스트 커버리지가 충분합니다
- [ ] 문서화가 적절합니다
```

### 4. 브랜치 관리 스크립트

**주요 파일**: `scripts/branch-management.sh`

```bash
#!/bin/bash
# scripts/branch-management.sh

# 바로캘린더 Git 브랜치 관리 스크립트

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 로그 함수
log_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
    echo -e "${RED}❌ $1${NC}"
}

# 브랜치 생성 함수
create_feature_branch() {
    local branch_name=$1
    
    if [ -z "$branch_name" ]; then
        log_error "브랜치 이름을 입력해주세요."
        echo "사용법: $0 feature <branch-name>"
        exit 1
    fi
    
    log_info "Feature 브랜치 생성 중: feature/$branch_name"
    
    # develop 브랜치로 전환하고 최신 상태로 업데이트
    git checkout develop
    git pull origin develop
    
    # 새 feature 브랜치 생성
    git checkout -b "feature/$branch_name"
    
    log_success "Feature 브랜치 'feature/$branch_name' 생성 완료"
    log_info "이제 작업을 시작하세요!"
}

create_release_branch() {
    local version=$1
    
    if [ -z "$version" ]; then
        log_error "릴리스 버전을 입력해주세요."
        echo "사용법: $0 release <version> (예: 1.2.0)"
        exit 1
    fi
    
    log_info "Release 브랜치 생성 중: release/v$version"
    
    # develop 브랜치에서 시작
    git checkout develop
    git pull origin develop
    
    # 새 release 브랜치 생성
    git checkout -b "release/v$version"
    
    # package.json 버전 업데이트
    if [ -f "package.json" ]; then
        npm version "$version" --no-git-tag-version
        git add package.json
        git commit -m "chore(release): bump version to $version"
    fi
    
    if [ -d "client" ] && [ -f "client/package.json" ]; then
        cd client
        npm version "$version" --no-git-tag-version
        git add package.json
        cd ..
        git commit -m "chore(client): bump version to $version"
    fi
    
    log_success "Release 브랜치 'release/v$version' 생성 완료"
    log_info "릴리스 준비 작업을 진행하세요."
}

create_hotfix_branch() {
    local branch_name=$1
    
    if [ -z "$branch_name" ]; then
        log_error "핫픽스 브랜치 이름을 입력해주세요."
        echo "사용법: $0 hotfix <branch-name>"
        exit 1
    fi
    
    log_info "Hotfix 브랜치 생성 중: hotfix/$branch_name"
    
    # main 브랜치에서 시작
    git checkout main
    git pull origin main
    
    # 새 hotfix 브랜치 생성
    git checkout -b "hotfix/$branch_name"
    
    log_success "Hotfix 브랜치 'hotfix/$branch_name' 생성 완료"
    log_warning "핫픽스는 신중하게 작업해주세요!"
}

# 브랜치 정리 함수
cleanup_merged_branches() {
    log_info "머지된 브랜치 정리 중..."
    
    # 현재 브랜치 확인
    current_branch=$(git branch --show-current)
    
    # develop으로 전환
    if [ "$current_branch" != "develop" ]; then
        git checkout develop
        git pull origin develop
    fi
    
    # 머지된 feature 브랜치 찾기
    merged_branches=$(git branch --merged develop | grep "feature/" | grep -v "*" | sed 's/^[ ]*//')
    
    if [ -z "$merged_branches" ]; then
        log_info "정리할 머지된 feature 브랜치가 없습니다."
    else
        log_info "다음 브랜치들이 정리됩니다:"
        echo "$merged_branches"
        
        read -p "정말로 이 브랜치들을 삭제하시겠습니까? (y/N): " -n 1 -r
        echo
        
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "$merged_branches" | while read -r branch; do
                git branch -d "$branch"
                log_success "로컬 브랜치 '$branch' 삭제됨"
            done
        else
            log_info "브랜치 정리가 취소되었습니다."
        fi
    fi
    
    # 원격 브랜치 정리
    log_info "원격 브랜치 정리 중..."
    git remote prune origin
    
    log_success "브랜치 정리 완료!"
}

# 오래된 브랜치 확인
check_old_branches() {
    log_info "30일 이상 된 브랜치 확인 중..."
    
    cutoff_date=$(date -d '30 days ago' --iso-8601)
    
    old_branches=$(git for-each-ref --format='%(refname:short) %(committerdate:iso8601)' refs/heads | \
        awk -v cutoff="$cutoff_date" '$2 <= cutoff' | cut -d' ' -f1 | grep -v -E '^(main|develop)$')
    
    if [ -z "$old_branches" ]; then
        log_success "30일 이상 된 브랜치가 없습니다."
    else
        log_warning "다음 브랜치들이 30일 이상 되었습니다:"
        echo "$old_branches"
        log_info "필요없는 브랜치는 수동으로 정리를 고려해보세요."
    fi
}

# 브랜치 상태 확인
check_branch_status() {
    log_info "브랜치 상태 확인 중..."
    
    echo "📊 브랜치 통계:"
    echo "- Feature 브랜치: $(git branch | grep -c "feature/" || echo "0")"
    echo "- Release 브랜치: $(git branch | grep -c "release/" || echo "0")"
    echo "- Hotfix 브랜치: $(git branch | grep -c "hotfix/" || echo "0")"
    echo "- 전체 브랜치: $(git branch | wc -l)"
    
    echo ""
    echo "🔄 최근 활동:"
    git for-each-ref --sort=-committerdate refs/heads --format='%(refname:short) - %(committerdate:relative) - %(authorname)' | head -10
}

# 도움말
show_help() {
    echo "바로캘린더 Git 브랜치 관리 도구"
    echo ""
    echo "사용법:"
    echo "  $0 <command> [arguments]"
    echo ""
    echo "Commands:"
    echo "  feature <name>    새로운 feature 브랜치 생성"
    echo "  release <version> 새로운 release 브랜치 생성"
    echo "  hotfix <name>     새로운 hotfix 브랜치 생성"
    echo "  cleanup           머지된 브랜치 정리"
    echo "  check-old         오래된 브랜치 확인"
    echo "  status            브랜치 상태 확인"
    echo "  help              이 도움말 표시"
    echo ""
    echo "예시:"
    echo "  $0 feature calendar-month-view"
    echo "  $0 release 1.2.0"
    echo "  $0 hotfix security-patch"
    echo "  $0 cleanup"
}

# 메인 로직
case "$1" in
    "feature")
        create_feature_branch "$2"
        ;;
    "release")
        create_release_branch "$2"
        ;;
    "hotfix")
        create_hotfix_branch "$2"
        ;;
    "cleanup")
        cleanup_merged_branches
        ;;
    "check-old")
        check_old_branches
        ;;
    "status")
        check_branch_status
        ;;
    "help"|"-h"|"--help")
        show_help
        ;;
    *)
        log_error "알 수 없는 명령어입니다: $1"
        show_help
        exit 1
        ;;
esac
```

---

## 🎨 UX 디자인 고려사항

### 개발자 경험 최적화
- **명확한 에러 메시지**: Git hook 실패 시 해결 방법 제시
- **자동화된 브랜치 설정**: 스크립트를 통한 일관된 브랜치 생성
- **실시간 피드백**: CI/CD 파이프라인 상태를 Slack으로 실시간 알림

### 코드 리뷰 프로세스 개선
- **구조화된 PR 템플릿**: 일관된 코드 리뷰 경험
- **자동 체크리스트**: 놓치기 쉬운 검토 항목 자동 확인
- **컨텍스트 제공**: 리뷰어가 이해하기 쉬운 상세 정보 제공

---

## ⚡ 성능 최적화

### CI/CD 파이프라인 최적화
- **병렬 작업 실행**: 독립적인 검사를 동시에 실행
- **캐시 활용**: 의존성 및 빌드 아티팩트 캐싱으로 실행 시간 단축
- **조건부 실행**: 변경된 파일에 따른 선택적 테스트 실행

### Git 성능 최적화
- **Shallow clone**: CI/CD에서 전체 히스토리 대신 최신 커밋만 fetch
- **부분 체크아웃**: 필요한 경로만 체크아웃하여 클론 시간 단축
- **브랜치 정리**: 정기적인 불필요한 브랜치 정리로 저장소 크기 관리

---

## 🧪 Definition of Done

### 프로세스 구현 요구사항
- [ ] GitFlow 기반 브랜치 전략 완전 구현
- [ ] Conventional Commits 표준 100% 적용
- [ ] PR 템플릿 및 코드 리뷰 가이드라인 수립
- [ ] GitHub Actions CI/CD 파이프라인 구축

### 자동화 요구사항
- [ ] Git hooks (pre-commit, commit-msg, pre-push) 설정
- [ ] 자동 코드 품질 검사 (ESLint, TypeScript, 테스트)
- [ ] 자동 보안 검사 (npm audit, CodeQL)
- [ ] 자동 배포 파이프라인 (스테이징, 프로덕션)

### 품질 보증 요구사항
- [ ] 모든 PR에서 필수 검사 통과
- [ ] 브랜치 보호 규칙 적용 (main, develop)
- [ ] 최소 리뷰어 승인 요구
- [ ] 빌드 및 테스트 실패 시 머지 차단

### 모니터링 및 알림 요구사항
- [ ] CI/CD 결과 Slack 알림 연동
- [ ] 빌드 실패 시 담당자 자동 알림
- [ ] 성능 메트릭 (빌드 시간, 테스트 시간) 수집
- [ ] 월간 프로세스 효율성 리포트 생성

### 문서화 요구사항
- [ ] Git 워크플로우 가이드 문서 작성
- [ ] 브랜치 명명 규칙 가이드 문서
- [ ] 커밋 메시지 컨벤션 가이드 문서
- [ ] 신규 개발자 온보딩 가이드

---

## 📚 관련 문서

- [23-git-workflow-process.md](../ui-architecture/23-git-workflow-process.md) - Git 워크플로우 아키텍처
- [Story 2.9: CI/CD Pipeline Setup](./2.9.cicd-pipeline-setup.md) - CI/CD 파이프라인
- [Story 2.7: Testing Strategy](./2.7.testing-strategy.md) - 테스팅 전략
- [Story 2.12: Observability & Monitoring](./2.12.observability-monitoring.md) - 모니터링 시스템

---

## 📈 성공 지표

### 개발 효율성 지표
- **PR 리뷰 시간**: 평균 24시간 이하 달성
- **빌드 성공률**: 95% 이상 유지
- **배포 빈도**: 주 2회 이상 정기 배포
- **핫픽스 빈도**: 월 2회 이하로 제한

### 코드 품질 지표
- **코드 커버리지**: 80% 이상 유지
- **ESLint 경고**: 0개 달성
- **TypeScript 에러**: 0개 달성
- **보안 취약점**: Critical 0개, High 5개 이하

### 협업 효율성 지표
- **커밋 메시지 규칙 준수율**: 95% 이상
- **PR 템플릿 활용률**: 100%
- **코드 리뷰 참여율**: 팀원 90% 이상
- **브랜치 명명 규칙 준수율**: 100%