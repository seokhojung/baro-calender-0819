# Story 2.3: 실시간 동기화 시스템

## 📋 문서 정보
- **스토리 버전**: 2.0
- **작성일**: 2025-08-28
- **작성자**: Bob (Scrum Master Agent)
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **Epic**: 프론트엔드 실시간 협업 기능
- **상태**: Ready for Development

---

## 🎯 **스토리 목표**

**완전한 실시간 동기화 시스템 구현**
- WebSocket 기반 양방향 통신
- 자동 재연결 및 오프라인 지원
- 낙관적 업데이트 및 충돌 해결
- 실시간 협업 커서 및 상태 표시
- 메시지 큐잉 및 재시도 메커니즘

---

## 👤 **사용자 스토리**

**사용자로서, 나는:**
1. 다른 사용자의 일정 변경사항을 실시간으로 확인하고 싶다
2. 네트워크가 불안정해도 작업이 손실되지 않기를 원한다
3. 동시 편집 시 충돌이 자동으로 해결되기를 원한다
4. 다른 사용자가 무엇을 보고 있는지 알고 싶다
5. 오프라인에서도 작업하고 온라인 시 자동 동기화되기를 원한다

---

## 🏗️ **기술적 구현 요구사항**

### **1. WebSocket 연결 관리**

**Enhanced WebSocket Manager**
```typescript
// src/lib/realtime/websocket-manager.ts
import { EventEmitter } from 'events'

export enum ConnectionState {
  CONNECTING = 'connecting',
  CONNECTED = 'connected',
  DISCONNECTED = 'disconnected',
  RECONNECTING = 'reconnecting',
  ERROR = 'error'
}

export interface WebSocketMessage<T = any> {
  type: string
  payload: T
  timestamp: number
  id: string
  userId?: string
  version?: number
}

export interface WebSocketConfig {
  url: string
  protocols?: string[]
  reconnect?: {
    maxAttempts?: number
    delay?: number
    maxDelay?: number
    factor?: number
  }
  heartbeat?: {
    interval?: number
    timeout?: number
    message?: string
  }
  auth?: {
    token?: string
    refreshToken?: () => Promise<string>
  }
}

export class WebSocketManager extends EventEmitter {
  private ws: WebSocket | null = null
  private config: Required<WebSocketConfig>
  private state: ConnectionState = ConnectionState.DISCONNECTED
  private reconnectAttempts = 0
  private reconnectTimer: NodeJS.Timeout | null = null
  private heartbeatTimer: NodeJS.Timeout | null = null
  private heartbeatTimeoutTimer: NodeJS.Timeout | null = null
  private messageQueue: WebSocketMessage[] = []
  private pendingMessages = new Map<string, WebSocketMessage>()
  
  constructor(config: WebSocketConfig) {
    super()
    this.config = this.normalizeConfig(config)
  }
  
  private normalizeConfig(config: WebSocketConfig): Required<WebSocketConfig> {
    return {
      url: config.url,
      protocols: config.protocols || [],
      reconnect: {
        maxAttempts: config.reconnect?.maxAttempts ?? 10,
        delay: config.reconnect?.delay ?? 1000,
        maxDelay: config.reconnect?.maxDelay ?? 30000,
        factor: config.reconnect?.factor ?? 1.5,
      },
      heartbeat: {
        interval: config.heartbeat?.interval ?? 30000,
        timeout: config.heartbeat?.timeout ?? 5000,
        message: config.heartbeat?.message ?? 'ping',
      },
      auth: {
        token: config.auth?.token ?? '',
        refreshToken: config.auth?.refreshToken ?? (async () => ''),
      }
    }
  }
  
  async connect(): Promise<void> {
    if (this.state === ConnectionState.CONNECTED) {
      return
    }
    
    this.setState(ConnectionState.CONNECTING)
    
    try {
      // Refresh token if needed
      if (this.config.auth.refreshToken) {
        const token = await this.config.auth.refreshToken()
        this.config.auth.token = token
      }
      
      const url = new URL(this.config.url)
      if (this.config.auth.token) {
        url.searchParams.set('token', this.config.auth.token)
      }
      
      this.ws = new WebSocket(url.toString(), this.config.protocols)
      this.setupEventHandlers()
    } catch (error) {
      this.handleError(error)
      this.scheduleReconnect()
    }
  }
  
  private setupEventHandlers() {
    if (!this.ws) return
    
    this.ws.onopen = () => {
      this.setState(ConnectionState.CONNECTED)
      this.reconnectAttempts = 0
      this.startHeartbeat()
      this.flushMessageQueue()
      this.emit('connected')
    }
    
    this.ws.onmessage = (event) => {
      this.handleMessage(event.data)
    }
    
    this.ws.onclose = (event) => {
      this.setState(ConnectionState.DISCONNECTED)
      this.stopHeartbeat()
      this.emit('disconnected', event.code, event.reason)
      
      if (!event.wasClean) {
        this.scheduleReconnect()
      }
    }
    
    this.ws.onerror = (error) => {
      this.handleError(error)
    }
  }
  
  private handleMessage(data: string) {
    try {
      const message: WebSocketMessage = JSON.parse(data)
      
      // Handle heartbeat response
      if (message.type === 'pong') {
        this.handleHeartbeatResponse()
        return
      }
      
      // Handle acknowledgments
      if (message.type === 'ack') {
        const pending = this.pendingMessages.get(message.id)
        if (pending) {
          this.pendingMessages.delete(message.id)
          this.emit('message-acknowledged', message)
        }
        return
      }
      
      // Emit message for handling
      this.emit('message', message)
      
      // Send acknowledgment
      this.sendAck(message.id)
    } catch (error) {
      console.error('Failed to parse WebSocket message:', error)
    }
  }
  
  send<T = any>(type: string, payload: T, options?: {
    requireAck?: boolean
    timeout?: number
  }): Promise<void> {
    return new Promise((resolve, reject) => {
      const message: WebSocketMessage<T> = {
        type,
        payload,
        timestamp: Date.now(),
        id: crypto.randomUUID(),
        userId: this.getCurrentUserId(),
      }
      
      if (this.state === ConnectionState.CONNECTED && this.ws) {
        this.ws.send(JSON.stringify(message))
        
        if (options?.requireAck) {
          this.pendingMessages.set(message.id, message)
          
          const timeout = setTimeout(() => {
            this.pendingMessages.delete(message.id)
            reject(new Error('Message acknowledgment timeout'))
          }, options.timeout || 5000)
          
          this.once(`ack:${message.id}`, () => {
            clearTimeout(timeout)
            resolve()
          })
        } else {
          resolve()
        }
      } else {
        // Queue message for later
        this.messageQueue.push(message)
        resolve()
      }
    })
  }
  
  private sendAck(messageId: string) {
    if (this.ws && this.state === ConnectionState.CONNECTED) {
      this.ws.send(JSON.stringify({
        type: 'ack',
        id: messageId,
        timestamp: Date.now()
      }))
    }
  }
  
  private startHeartbeat() {
    this.stopHeartbeat()
    
    this.heartbeatTimer = setInterval(() => {
      if (this.ws && this.state === ConnectionState.CONNECTED) {
        this.ws.send(JSON.stringify({
          type: 'ping',
          timestamp: Date.now()
        }))
        
        // Set timeout for pong response
        this.heartbeatTimeoutTimer = setTimeout(() => {
          console.warn('Heartbeat timeout - reconnecting')
          this.reconnect()
        }, this.config.heartbeat.timeout)
      }
    }, this.config.heartbeat.interval)
  }
  
  private handleHeartbeatResponse() {
    if (this.heartbeatTimeoutTimer) {
      clearTimeout(this.heartbeatTimeoutTimer)
      this.heartbeatTimeoutTimer = null
    }
  }
  
  private stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
    
    if (this.heartbeatTimeoutTimer) {
      clearTimeout(this.heartbeatTimeoutTimer)
      this.heartbeatTimeoutTimer = null
    }
  }
  
  private scheduleReconnect() {
    if (this.reconnectAttempts >= this.config.reconnect.maxAttempts) {
      this.setState(ConnectionState.ERROR)
      this.emit('max-reconnect-attempts')
      return
    }
    
    const delay = Math.min(
      this.config.reconnect.delay * Math.pow(this.config.reconnect.factor, this.reconnectAttempts),
      this.config.reconnect.maxDelay
    )
    
    this.setState(ConnectionState.RECONNECTING)
    this.reconnectAttempts++
    
    this.reconnectTimer = setTimeout(() => {
      this.connect()
    }, delay)
    
    this.emit('reconnecting', this.reconnectAttempts, delay)
  }
  
  private flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift()
      if (message && this.ws) {
        this.ws.send(JSON.stringify(message))
      }
    }
  }
  
  disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }
    
    this.stopHeartbeat()
    
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect')
      this.ws = null
    }
    
    this.setState(ConnectionState.DISCONNECTED)
  }
  
  reconnect() {
    this.disconnect()
    this.connect()
  }
  
  private setState(state: ConnectionState) {
    const oldState = this.state
    this.state = state
    this.emit('state-change', state, oldState)
  }
  
  private handleError(error: any) {
    console.error('WebSocket error:', error)
    this.emit('error', error)
  }
  
  private getCurrentUserId(): string {
    // Get from auth store or context
    return 'current-user-id'
  }
  
  getState(): ConnectionState {
    return this.state
  }
  
  isConnected(): boolean {
    return this.state === ConnectionState.CONNECTED
  }
}
```

### **2. 실시간 캘린더 동기화 훅**

**Calendar Sync Hook**
```typescript
// src/hooks/useRealtimeCalendar.ts
import { useEffect, useCallback, useRef } from 'react'
import { useCalendarStore } from '@/stores/calendarStore'
import { WebSocketManager, ConnectionState } from '@/lib/realtime/websocket-manager'
import { CalendarEvent } from '@/types/calendar'

interface RealtimeCalendarOptions {
  projectId?: string
  autoConnect?: boolean
  onUserJoin?: (userId: string) => void
  onUserLeave?: (userId: string) => void
}

export const useRealtimeCalendar = (options: RealtimeCalendarOptions = {}) => {
  const wsRef = useRef<WebSocketManager | null>(null)
  const { 
    events, 
    addEvent, 
    updateEvent, 
    deleteEvent,
    setOptimisticUpdate,
    revertOptimisticUpdate 
  } = useCalendarStore()
  
  const [connectionState, setConnectionState] = useState<ConnectionState>(
    ConnectionState.DISCONNECTED
  )
  const [activeUsers, setActiveUsers] = useState<Map<string, UserPresence>>(
    new Map()
  )
  
  // Initialize WebSocket connection
  useEffect(() => {
    if (!options.autoConnect) return
    
    const ws = new WebSocketManager({
      url: process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3001',
      auth: {
        refreshToken: async () => {
          // Get fresh token from auth store
          const token = await refreshAuthToken()
          return token
        }
      }
    })
    
    wsRef.current = ws
    
    // Handle connection state changes
    ws.on('state-change', (state: ConnectionState) => {
      setConnectionState(state)
    })
    
    // Handle incoming messages
    ws.on('message', handleIncomingMessage)
    
    // Connect
    ws.connect()
    
    // Subscribe to project updates
    if (options.projectId) {
      ws.send('subscribe', { projectId: options.projectId })
    }
    
    return () => {
      ws.disconnect()
    }
  }, [options.projectId, options.autoConnect])
  
  const handleIncomingMessage = useCallback((message: WebSocketMessage) => {
    switch (message.type) {
      case 'event:created':
        handleEventCreated(message.payload)
        break
      case 'event:updated':
        handleEventUpdated(message.payload)
        break
      case 'event:deleted':
        handleEventDeleted(message.payload)
        break
      case 'user:joined':
        handleUserJoined(message.payload)
        break
      case 'user:left':
        handleUserLeft(message.payload)
        break
      case 'user:cursor':
        handleUserCursor(message.payload)
        break
      case 'conflict:detected':
        handleConflict(message.payload)
        break
    }
  }, [])
  
  const handleEventCreated = (event: CalendarEvent) => {
    // Check if this is our own event (optimistic update)
    if (!useCalendarStore.getState().hasOptimisticUpdate(event.id)) {
      addEvent(event)
    }
  }
  
  const handleEventUpdated = (event: CalendarEvent) => {
    const currentEvent = events.find(e => e.id === event.id)
    
    // Handle version conflict
    if (currentEvent && currentEvent.version && event.version) {
      if (currentEvent.version >= event.version) {
        // Our version is newer or same - ignore update
        return
      }
    }
    
    updateEvent(event.id, event)
  }
  
  const handleEventDeleted = (eventId: string) => {
    deleteEvent(eventId)
  }
  
  const handleUserJoined = (user: UserPresence) => {
    setActiveUsers(prev => new Map(prev).set(user.id, user))
    options.onUserJoin?.(user.id)
  }
  
  const handleUserLeft = (userId: string) => {
    setActiveUsers(prev => {
      const next = new Map(prev)
      next.delete(userId)
      return next
    })
    options.onUserLeave?.(userId)
  }
  
  const handleUserCursor = (cursor: UserCursor) => {
    setActiveUsers(prev => {
      const user = prev.get(cursor.userId)
      if (user) {
        return new Map(prev).set(cursor.userId, {
          ...user,
          cursor
        })
      }
      return prev
    })
  }
  
  const handleConflict = (conflict: ConflictInfo) => {
    // Show conflict resolution UI
    console.warn('Conflict detected:', conflict)
    // Implement conflict resolution strategy
  }
  
  // Optimistic create with sync
  const createEventWithSync = useCallback(async (
    eventData: Omit<CalendarEvent, 'id'>
  ) => {
    const tempId = `temp-${Date.now()}`
    const optimisticEvent = {
      ...eventData,
      id: tempId,
      version: 0
    }
    
    // Optimistic update
    setOptimisticUpdate(tempId, optimisticEvent)
    addEvent(optimisticEvent)
    
    try {
      // Send to server
      await wsRef.current?.send('event:create', eventData, {
        requireAck: true,
        timeout: 5000
      })
    } catch (error) {
      // Revert on failure
      revertOptimisticUpdate(tempId)
      deleteEvent(tempId)
      throw error
    }
  }, [addEvent, setOptimisticUpdate, revertOptimisticUpdate, deleteEvent])
  
  // Broadcast cursor position
  const broadcastCursor = useCallback((position: CursorPosition) => {
    wsRef.current?.send('user:cursor', position)
  }, [])
  
  return {
    connectionState,
    activeUsers,
    createEventWithSync,
    broadcastCursor,
    isConnected: connectionState === ConnectionState.CONNECTED,
    reconnect: () => wsRef.current?.reconnect()
  }
}

interface UserPresence {
  id: string
  name: string
  avatar?: string
  color: string
  cursor?: UserCursor
  lastSeen: Date
}

interface UserCursor {
  userId: string
  x: number
  y: number
  elementId?: string
  timestamp: number
}

interface CursorPosition {
  x: number
  y: number
  elementId?: string
}

interface ConflictInfo {
  localVersion: CalendarEvent
  remoteVersion: CalendarEvent
  strategy: 'local' | 'remote' | 'merge'
}
```

### **3. 오프라인 지원 및 동기화**

**Offline Support Manager**
```typescript
// src/lib/realtime/offline-manager.ts
import { openDB, IDBPDatabase } from 'idb'

interface OfflineAction {
  id: string
  type: 'create' | 'update' | 'delete'
  resource: string
  data: any
  timestamp: number
  retryCount: number
}

export class OfflineManager {
  private db: IDBPDatabase | null = null
  private syncInProgress = false
  private syncQueue: OfflineAction[] = []
  
  async initialize() {
    this.db = await openDB('baro-calendar-offline', 1, {
      upgrade(db) {
        // Actions store
        if (!db.objectStoreNames.contains('actions')) {
          const actionStore = db.createObjectStore('actions', { 
            keyPath: 'id' 
          })
          actionStore.createIndex('timestamp', 'timestamp')
        }
        
        // Cache store
        if (!db.objectStoreNames.contains('cache')) {
          const cacheStore = db.createObjectStore('cache', {
            keyPath: 'key'
          })
          cacheStore.createIndex('expiry', 'expiry')
        }
      }
    })
    
    // Listen for online/offline events
    window.addEventListener('online', () => this.handleOnline())
    window.addEventListener('offline', () => this.handleOffline())
    
    // Start sync if online
    if (navigator.onLine) {
      this.startSync()
    }
  }
  
  async queueAction(action: Omit<OfflineAction, 'id' | 'timestamp' | 'retryCount'>) {
    if (!this.db) return
    
    const fullAction: OfflineAction = {
      ...action,
      id: crypto.randomUUID(),
      timestamp: Date.now(),
      retryCount: 0
    }
    
    // Store in IndexedDB
    await this.db.put('actions', fullAction)
    
    // Add to memory queue
    this.syncQueue.push(fullAction)
    
    // Try to sync if online
    if (navigator.onLine) {
      this.processQueue()
    }
  }
  
  private async processQueue() {
    if (this.syncInProgress || this.syncQueue.length === 0) {
      return
    }
    
    this.syncInProgress = true
    
    while (this.syncQueue.length > 0) {
      const action = this.syncQueue.shift()
      if (!action) continue
      
      try {
        await this.executeAction(action)
        
        // Remove from IndexedDB on success
        if (this.db) {
          await this.db.delete('actions', action.id)
        }
      } catch (error) {
        console.error('Failed to sync action:', error)
        
        // Increment retry count
        action.retryCount++
        
        // Re-queue if under retry limit
        if (action.retryCount < 3) {
          this.syncQueue.push(action)
          if (this.db) {
            await this.db.put('actions', action)
          }
        } else {
          // Max retries reached - handle failure
          this.handleSyncFailure(action)
        }
      }
    }
    
    this.syncInProgress = false
  }
  
  private async executeAction(action: OfflineAction) {
    switch (action.type) {
      case 'create':
        return this.syncCreate(action)
      case 'update':
        return this.syncUpdate(action)
      case 'delete':
        return this.syncDelete(action)
    }
  }
  
  private async syncCreate(action: OfflineAction) {
    const response = await fetch(`/api/${action.resource}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(action.data)
    })
    
    if (!response.ok) {
      throw new Error(`Create failed: ${response.statusText}`)
    }
    
    return response.json()
  }
  
  private async syncUpdate(action: OfflineAction) {
    const response = await fetch(`/api/${action.resource}/${action.data.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(action.data)
    })
    
    if (!response.ok) {
      throw new Error(`Update failed: ${response.statusText}`)
    }
    
    return response.json()
  }
  
  private async syncDelete(action: OfflineAction) {
    const response = await fetch(`/api/${action.resource}/${action.data.id}`, {
      method: 'DELETE'
    })
    
    if (!response.ok) {
      throw new Error(`Delete failed: ${response.statusText}`)
    }
  }
  
  private handleSyncFailure(action: OfflineAction) {
    // Notify user of sync failure
    console.error('Sync failed after max retries:', action)
    
    // Emit event for UI handling
    window.dispatchEvent(new CustomEvent('sync-failure', {
      detail: action
    }))
  }
  
  private async loadQueueFromDB() {
    if (!this.db) return
    
    const actions = await this.db.getAll('actions')
    this.syncQueue = actions.sort((a, b) => a.timestamp - b.timestamp)
  }
  
  private async handleOnline() {
    console.log('Connection restored - starting sync')
    await this.loadQueueFromDB()
    this.startSync()
  }
  
  private handleOffline() {
    console.log('Connection lost - entering offline mode')
  }
  
  private async startSync() {
    await this.loadQueueFromDB()
    this.processQueue()
  }
  
  // Cache management
  async getCached<T>(key: string): Promise<T | null> {
    if (!this.db) return null
    
    try {
      const cached = await this.db.get('cache', key)
      
      if (cached && cached.expiry > Date.now()) {
        return cached.data as T
      }
      
      // Remove expired cache
      if (cached) {
        await this.db.delete('cache', key)
      }
      
      return null
    } catch (error) {
      console.error('Cache get error:', error)
      return null
    }
  }
  
  async setCached<T>(key: string, data: T, ttl = 3600000) {
    if (!this.db) return
    
    try {
      await this.db.put('cache', {
        key,
        data,
        expiry: Date.now() + ttl
      })
    } catch (error) {
      console.error('Cache set error:', error)
    }
  }
  
  async clearCache() {
    if (!this.db) return
    
    const tx = this.db.transaction('cache', 'readwrite')
    await tx.objectStore('cache').clear()
  }
}

// Singleton instance
export const offlineManager = new OfflineManager()
```

### **4. 협업 커서 및 상태 표시**

**Collaboration Cursors Component**
```typescript
// src/components/collaboration/CollaborationCursors.tsx
import React, { useEffect, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { useRealtimeCalendar } from '@/hooks/useRealtimeCalendar'

interface CollaborationCursorsProps {
  containerRef?: React.RefObject<HTMLElement>
}

export const CollaborationCursors: React.FC<CollaborationCursorsProps> = ({
  containerRef
}) => {
  const { activeUsers, broadcastCursor } = useRealtimeCalendar()
  const lastBroadcast = useRef(0)
  
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      const now = Date.now()
      
      // Throttle broadcasts to every 50ms
      if (now - lastBroadcast.current < 50) return
      
      lastBroadcast.current = now
      
      const container = containerRef?.current
      if (container) {
        const rect = container.getBoundingClientRect()
        broadcastCursor({
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
          elementId: (e.target as HTMLElement)?.id
        })
      } else {
        broadcastCursor({
          x: e.clientX,
          y: e.clientY,
          elementId: (e.target as HTMLElement)?.id
        })
      }
    }
    
    window.addEventListener('mousemove', handleMouseMove)
    return () => window.removeEventListener('mousemove', handleMouseMove)
  }, [broadcastCursor, containerRef])
  
  return (
    <div className="pointer-events-none fixed inset-0 z-50">
      <AnimatePresence>
        {Array.from(activeUsers.values()).map((user) => {
          if (!user.cursor) return null
          
          return (
            <motion.div
              key={user.id}
              initial={{ opacity: 0, scale: 0 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0 }}
              transition={{ duration: 0.2 }}
              className="absolute"
              style={{
                left: user.cursor.x,
                top: user.cursor.y,
                transform: 'translate(-50%, -50%)'
              }}
            >
              {/* Cursor */}
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                style={{ color: user.color }}
              >
                <path
                  d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"
                  fill="currentColor"
                  stroke="white"
                  strokeWidth="2"
                />
              </svg>
              
              {/* User label */}
              <div
                className="absolute top-6 left-4 px-2 py-1 rounded text-xs text-white whitespace-nowrap"
                style={{ backgroundColor: user.color }}
              >
                {user.name}
              </div>
            </motion.div>
          )
        })}
      </AnimatePresence>
    </div>
  )
}

// Active Users List Component
export const ActiveUsersList: React.FC = () => {
  const { activeUsers, connectionState } = useRealtimeCalendar()
  
  return (
    <div className="flex items-center gap-2">
      {/* Connection Status */}
      <div className="flex items-center gap-1">
        <div className={cn(
          "w-2 h-2 rounded-full",
          connectionState === ConnectionState.CONNECTED && "bg-green-500",
          connectionState === ConnectionState.CONNECTING && "bg-yellow-500 animate-pulse",
          connectionState === ConnectionState.DISCONNECTED && "bg-red-500"
        )} />
        <span className="text-xs text-muted-foreground">
          {connectionState}
        </span>
      </div>
      
      {/* Active Users */}
      <div className="flex -space-x-2">
        {Array.from(activeUsers.values()).slice(0, 5).map((user) => (
          <div
            key={user.id}
            className="relative w-8 h-8 rounded-full border-2 border-background"
            style={{ backgroundColor: user.color }}
            title={user.name}
          >
            {user.avatar ? (
              <img
                src={user.avatar}
                alt={user.name}
                className="w-full h-full rounded-full"
              />
            ) : (
              <div className="flex items-center justify-center w-full h-full text-white text-xs font-medium">
                {user.name.charAt(0).toUpperCase()}
              </div>
            )}
            
            {/* Online indicator */}
            <div className="absolute bottom-0 right-0 w-2.5 h-2.5 bg-green-500 rounded-full border-2 border-background" />
          </div>
        ))}
        
        {activeUsers.size > 5 && (
          <div className="flex items-center justify-center w-8 h-8 rounded-full bg-muted text-xs font-medium">
            +{activeUsers.size - 5}
          </div>
        )}
      </div>
    </div>
  )
}
```

### **5. 충돌 해결 전략**

**Conflict Resolution System**
```typescript
// src/lib/realtime/conflict-resolver.ts
import { CalendarEvent } from '@/types/calendar'
import { diff, patch } from 'jsondiffpatch'

export enum ConflictStrategy {
  LAST_WRITE_WINS = 'last_write_wins',
  FIRST_WRITE_WINS = 'first_write_wins',
  MANUAL = 'manual',
  MERGE = 'merge'
}

export class ConflictResolver {
  private strategy: ConflictStrategy
  
  constructor(strategy: ConflictStrategy = ConflictStrategy.LAST_WRITE_WINS) {
    this.strategy = strategy
  }
  
  async resolve(
    local: CalendarEvent,
    remote: CalendarEvent,
    base?: CalendarEvent
  ): Promise<CalendarEvent> {
    switch (this.strategy) {
      case ConflictStrategy.LAST_WRITE_WINS:
        return this.lastWriteWins(local, remote)
        
      case ConflictStrategy.FIRST_WRITE_WINS:
        return this.firstWriteWins(local, remote)
        
      case ConflictStrategy.MERGE:
        return this.mergeChanges(local, remote, base)
        
      case ConflictStrategy.MANUAL:
        return this.manualResolve(local, remote)
        
      default:
        return remote
    }
  }
  
  private lastWriteWins(local: CalendarEvent, remote: CalendarEvent): CalendarEvent {
    return local.updatedAt > remote.updatedAt ? local : remote
  }
  
  private firstWriteWins(local: CalendarEvent, remote: CalendarEvent): CalendarEvent {
    return local.updatedAt < remote.updatedAt ? local : remote
  }
  
  private mergeChanges(
    local: CalendarEvent,
    remote: CalendarEvent,
    base?: CalendarEvent
  ): CalendarEvent {
    if (!base) {
      // No base - use simple merge
      return {
        ...remote,
        ...local,
        // Preserve remote version for conflict tracking
        version: Math.max(local.version || 0, remote.version || 0) + 1,
        updatedAt: new Date()
      }
    }
    
    // Three-way merge
    const localDiff = diff(base, local)
    const remoteDiff = diff(base, remote)
    
    // Apply both diffs if no conflicts
    let merged = { ...base }
    
    if (localDiff) {
      merged = patch(merged, localDiff)
    }
    
    if (remoteDiff) {
      merged = patch(merged, remoteDiff)
    }
    
    return {
      ...merged,
      version: Math.max(local.version || 0, remote.version || 0) + 1,
      updatedAt: new Date()
    }
  }
  
  private async manualResolve(
    local: CalendarEvent,
    remote: CalendarEvent
  ): Promise<CalendarEvent> {
    // Show conflict resolution UI
    return new Promise((resolve) => {
      window.dispatchEvent(new CustomEvent('show-conflict-dialog', {
        detail: {
          local,
          remote,
          onResolve: resolve
        }
      }))
    })
  }
  
  detectConflicts(local: CalendarEvent, remote: CalendarEvent): string[] {
    const conflicts: string[] = []
    
    // Check each field for conflicts
    const fields: (keyof CalendarEvent)[] = [
      'title', 'description', 'startDate', 'endDate',
      'location', 'attendees', 'projectId'
    ]
    
    for (const field of fields) {
      if (local[field] !== remote[field]) {
        conflicts.push(field)
      }
    }
    
    return conflicts
  }
}
```

---

## 🎨 **사용자 경험 (UX) 설계**

### **1. 연결 상태 표시기**

```typescript
// src/components/status/ConnectionStatus.tsx
export const ConnectionStatus: React.FC = () => {
  const { connectionState } = useRealtimeCalendar()
  const [showDetails, setShowDetails] = useState(false)
  
  const getStatusConfig = () => {
    switch (connectionState) {
      case ConnectionState.CONNECTED:
        return {
          icon: <WifiIcon className="w-4 h-4" />,
          text: 'Connected',
          color: 'text-green-600',
          bgColor: 'bg-green-100'
        }
      case ConnectionState.CONNECTING:
        return {
          icon: <RefreshIcon className="w-4 h-4 animate-spin" />,
          text: 'Connecting...',
          color: 'text-yellow-600',
          bgColor: 'bg-yellow-100'
        }
      case ConnectionState.RECONNECTING:
        return {
          icon: <RefreshIcon className="w-4 h-4 animate-spin" />,
          text: 'Reconnecting...',
          color: 'text-orange-600',
          bgColor: 'bg-orange-100'
        }
      case ConnectionState.DISCONNECTED:
        return {
          icon: <WifiOffIcon className="w-4 h-4" />,
          text: 'Offline',
          color: 'text-red-600',
          bgColor: 'bg-red-100'
        }
      default:
        return {
          icon: <AlertCircleIcon className="w-4 h-4" />,
          text: 'Error',
          color: 'text-gray-600',
          bgColor: 'bg-gray-100'
        }
    }
  }
  
  const config = getStatusConfig()
  
  return (
    <div className="relative">
      <button
        onClick={() => setShowDetails(!showDetails)}
        className={cn(
          "flex items-center gap-2 px-3 py-1.5 rounded-full transition-colors",
          config.bgColor,
          config.color
        )}
      >
        {config.icon}
        <span className="text-sm font-medium">{config.text}</span>
      </button>
      
      {showDetails && (
        <div className="absolute top-full mt-2 right-0 w-64 p-4 bg-white rounded-lg shadow-lg border">
          <ConnectionDetails />
        </div>
      )}
    </div>
  )
}
```

### **2. 동기화 진행 표시**

```typescript
// src/components/status/SyncProgress.tsx
export const SyncProgress: React.FC = () => {
  const { pendingActions, syncProgress } = useSyncStatus()
  
  if (pendingActions.length === 0) return null
  
  return (
    <div className="fixed bottom-4 right-4 w-80 p-4 bg-white rounded-lg shadow-lg border">
      <div className="flex items-center justify-between mb-2">
        <span className="text-sm font-medium">Syncing changes...</span>
        <span className="text-xs text-muted-foreground">
          {syncProgress.completed}/{syncProgress.total}
        </span>
      </div>
      
      <Progress value={syncProgress.percentage} className="mb-2" />
      
      <div className="space-y-1">
        {pendingActions.slice(0, 3).map((action) => (
          <div key={action.id} className="flex items-center gap-2 text-xs">
            <Loader2 className="w-3 h-3 animate-spin" />
            <span className="truncate">{action.description}</span>
          </div>
        ))}
      </div>
    </div>
  )
}
```

---

## 📊 **성능 최적화**

### **메시지 배칭 및 스로틀링**

```typescript
// src/lib/realtime/message-batcher.ts
export class MessageBatcher {
  private batch: WebSocketMessage[] = []
  private batchTimer: NodeJS.Timeout | null = null
  private batchSize = 10
  private batchDelay = 100
  
  constructor(
    private sendFunction: (messages: WebSocketMessage[]) => void,
    options?: {
      batchSize?: number
      batchDelay?: number
    }
  ) {
    this.batchSize = options?.batchSize || this.batchSize
    this.batchDelay = options?.batchDelay || this.batchDelay
  }
  
  add(message: WebSocketMessage) {
    this.batch.push(message)
    
    if (this.batch.length >= this.batchSize) {
      this.flush()
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => this.flush(), this.batchDelay)
    }
  }
  
  flush() {
    if (this.batch.length === 0) return
    
    const messages = [...this.batch]
    this.batch = []
    
    if (this.batchTimer) {
      clearTimeout(this.batchTimer)
      this.batchTimer = null
    }
    
    this.sendFunction(messages)
  }
}
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] WebSocket 연결 관리 및 자동 재연결
- [ ] 실시간 이벤트 동기화
- [ ] 오프라인 지원 및 큐잉
- [ ] 협업 커서 및 사용자 상태 표시
- [ ] 충돌 감지 및 해결

### **기술 요구사항**
- [ ] WebSocket Manager 구현
- [ ] IndexedDB 기반 오프라인 저장소
- [ ] 낙관적 업데이트 메커니즘
- [ ] 메시지 배칭 및 압축

### **신뢰성 요구사항**
- [ ] 자동 재연결 (exponential backoff)
- [ ] 하트비트 메커니즘
- [ ] 메시지 중복 제거
- [ ] 순서 보장

### **성능 요구사항**
- [ ] 100ms 이내 실시간 동기화
- [ ] 1000+ 동시 접속 처리
- [ ] 메시지 배칭으로 네트워크 최적화
- [ ] 효율적인 메모리 관리

### **테스트 요구사항**
- [ ] WebSocket 연결 테스트
- [ ] 오프라인 시나리오 테스트
- [ ] 충돌 해결 테스트
- [ ] 부하 테스트

---

## 📚 **관련 문서 참조**

- [15. Realtime WebSocket Sync](../ui-architecture/15-realtime-websocket-sync.md)
- [04. State Management](../ui-architecture/04-state-management.md)
- [20. Error Handling](../ui-architecture/20-error-handling.md)

---

**이 스토리는 바로캘린더의 실시간 동기화 시스템 구현을 위한 종합적인 기술 가이드입니다. WebSocket 기반의 안정적인 실시간 협업을 통해 팀원들과 원활하게 일정을 공유하고 관리할 수 있습니다.**