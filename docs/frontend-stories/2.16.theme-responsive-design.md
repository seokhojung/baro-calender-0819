# Story 2.16: Theme & Responsive Design Implementation

## 📋 문서 정보
- **문서 버전**: 1.0
- **작성일**: 2025-08-28
- **작성자**: Frontend Team
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **상태**: Active
- **관련 아키텍처 문서**: [07-theme-responsive-design.md](../ui-architecture/07-theme-responsive-design.md)

---

## 🎯 스토리 목표

바로캘린더 애플리케이션의 **포용적인 테마 시스템과 반응형 디자인**을 구현하여 모든 사용자가 다양한 디바이스와 접근성 요구사항에 맞춰 최적화된 사용자 경험을 제공받을 수 있도록 한다.

### 주요 구현 사항
- **다크/라이트 테마** 및 시스템 선호도 기반 자동 전환
- **8가지 프로젝트 테마** 선택 및 커스터마이징
- **모바일 퍼스트 반응형 디자인** 시스템
- **접근성 고려** 색상 대비 및 모션 감소 지원

---

## 👤 사용자 스토리

### US 2.16.1: 다이나믹 테마 전환 시스템
**As a** 사용자  
**I want** 라이트/다크 모드를 자유롭게 전환하거나 시스템 설정에 따라 자동으로 적용되기를  
**So that** 내 환경과 선호도에 맞는 최적의 시각적 경험을 얻을 수 있다.

**인수 조건:**
- [ ] 라이트, 다크, 시스템 자동 모드 지원
- [ ] 실시간 테마 전환 (새로고침 없음)
- [ ] 사용자 선택 로컬 스토리지 저장
- [ ] 시스템 테마 변경 자동 감지

### US 2.16.2: 프로젝트별 커스텀 테마
**As a** 사용자  
**I want** 프로젝트마다 고유한 테마 색상을 선택하여 시각적으로 구분하기를  
**So that** 여러 프로젝트를 동시에 관리할 때 직관적으로 식별할 수 있다.

**인수 조건:**
- [ ] 8가지 프로젝트 테마 (Blue, Green, Purple, Orange, Red, Teal, Pink, Indigo)
- [ ] 프로젝트별 그라디언트 및 색상 조합
- [ ] 테마 미리보기 및 실시간 적용
- [ ] 개별 프로젝트 테마 저장 및 복원

### US 2.16.3: 반응형 디자인 시스템
**As a** 사용자  
**I want** 모바일, 태블릿, 데스크톱에서 모두 최적화된 인터페이스를 사용하기를  
**So that** 어떤 디바이스에서든 일관되고 사용하기 편한 경험을 얻을 수 있다.

**인수 조건:**
- [ ] 6단계 브레이크포인트 시스템 (xs, sm, md, lg, xl, 2xl)
- [ ] 모바일 퍼스트 CSS 아키텍처
- [ ] 터치 친화적 UI 요소 (최소 44px 타겟)
- [ ] 동적 뷰포트 크기 감지 및 레이아웃 조정

### US 2.16.4: 접근성 최적화
**As a** 접근성이 필요한 사용자  
**I want** 색상 대비, 키보드 네비게이션, 모션 감소 등이 지원되는 인터페이스를 사용하기를  
**So that** 신체적 제약에 관계없이 애플리케이션을 완전히 활용할 수 있다.

**인수 조건:**
- [ ] WCAG 2.1 AA 기준 색상 대비율 4.5:1 이상
- [ ] prefers-reduced-motion 지원
- [ ] 키보드 네비게이션 및 포커스 관리
- [ ] 고대비 모드 (prefers-contrast: high) 지원

---

## 🔧 기술적 구현 요구사항

### 1. 테마 컨텍스트 및 관리 시스템

**주요 파일**: `src/contexts/ThemeContext.tsx`

```typescript
// src/contexts/ThemeContext.tsx
import React, { createContext, useContext, useEffect, useState, useCallback } from 'react'

export type ThemeMode = 'light' | 'dark' | 'system'
export type ResolvedTheme = 'light' | 'dark'

interface ThemeContextType {
  theme: ThemeMode
  setTheme: (theme: ThemeMode) => void
  resolvedTheme: ResolvedTheme
  systemTheme: ResolvedTheme
  isThemeLoaded: boolean
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [theme, setThemeState] = useState<ThemeMode>('system')
  const [resolvedTheme, setResolvedTheme] = useState<ResolvedTheme>('light')
  const [systemTheme, setSystemTheme] = useState<ResolvedTheme>('light')
  const [isThemeLoaded, setIsThemeLoaded] = useState(false)
  
  // 시스템 테마 감지
  const getSystemTheme = useCallback((): ResolvedTheme => {
    if (typeof window === 'undefined') return 'light'
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
  }, [])
  
  // 테마 적용 함수
  const applyTheme = useCallback((newTheme: ResolvedTheme) => {
    const root = window.document.documentElement
    
    // 기존 테마 클래스 제거
    root.classList.remove('light', 'dark')
    
    // 새 테마 클래스 추가
    root.classList.add(newTheme)
    
    // 데이터 속성 설정
    root.setAttribute('data-theme', newTheme)
    
    // 메타 테마 컬러 업데이트 (모바일 주소창 색상)
    const metaThemeColor = document.querySelector('meta[name="theme-color"]')
    if (metaThemeColor) {
      metaThemeColor.setAttribute(
        'content', 
        newTheme === 'dark' ? '#0f172a' : '#ffffff'
      )
    }
    
    setResolvedTheme(newTheme)
  }, [])
  
  // 테마 설정 함수
  const setTheme = useCallback((newTheme: ThemeMode) => {
    setThemeState(newTheme)
    
    let resolvedNewTheme: ResolvedTheme
    
    if (newTheme === 'system') {
      resolvedNewTheme = systemTheme
    } else {
      resolvedNewTheme = newTheme
    }
    
    applyTheme(resolvedNewTheme)
    
    // 로컬 스토리지에 저장
    try {
      localStorage.setItem('theme', newTheme)
    } catch (error) {
      console.warn('Failed to save theme preference:', error)
    }
  }, [systemTheme, applyTheme])
  
  // 시스템 테마 변경 감지
  useEffect(() => {
    if (typeof window === 'undefined') return
    
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
    
    const handleSystemThemeChange = (event: MediaQueryListEvent) => {
      const newSystemTheme: ResolvedTheme = event.matches ? 'dark' : 'light'
      setSystemTheme(newSystemTheme)
      
      // 현재 시스템 모드일 경우 테마 업데이트
      if (theme === 'system') {
        applyTheme(newSystemTheme)
      }
    }
    
    // 초기 시스템 테마 설정
    const initialSystemTheme = getSystemTheme()
    setSystemTheme(initialSystemTheme)
    
    // 리스너 등록
    mediaQuery.addEventListener('change', handleSystemThemeChange)
    
    return () => {
      mediaQuery.removeEventListener('change', handleSystemThemeChange)
    }
  }, [theme, getSystemTheme, applyTheme])
  
  // 초기 테마 로드
  useEffect(() => {
    if (typeof window === 'undefined') return
    
    const initializeTheme = () => {
      try {
        // 저장된 테마 설정 불러오기
        const savedTheme = localStorage.getItem('theme') as ThemeMode | null
        const initialSystemTheme = getSystemTheme()
        
        setSystemTheme(initialSystemTheme)
        
        let initialTheme: ThemeMode = 'system'
        let initialResolvedTheme: ResolvedTheme = initialSystemTheme
        
        if (savedTheme && ['light', 'dark', 'system'].includes(savedTheme)) {
          initialTheme = savedTheme
          
          if (savedTheme === 'system') {
            initialResolvedTheme = initialSystemTheme
          } else {
            initialResolvedTheme = savedTheme
          }
        }
        
        setThemeState(initialTheme)
        applyTheme(initialResolvedTheme)
        setIsThemeLoaded(true)
      } catch (error) {
        console.warn('Failed to load theme preference:', error)
        
        // 폴백: 시스템 테마 사용
        const fallbackSystemTheme = getSystemTheme()
        setSystemTheme(fallbackSystemTheme)
        setThemeState('system')
        applyTheme(fallbackSystemTheme)
        setIsThemeLoaded(true)
      }
    }
    
    initializeTheme()
  }, [getSystemTheme, applyTheme])
  
  return (
    <ThemeContext.Provider value={{
      theme,
      setTheme,
      resolvedTheme,
      systemTheme,
      isThemeLoaded,
    }}>
      {children}
    </ThemeContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}

// 테마 로딩 스켈레톤
export const ThemeLoader: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const { isThemeLoaded } = useTheme()
  
  if (!isThemeLoaded) {
    return (
      <div className="animate-pulse bg-muted/50 min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="w-8 h-8 border-2 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p className="text-muted-foreground">테마 로딩 중...</p>
        </div>
      </div>
    )
  }
  
  return <>{children}</>
}
```

### 2. 테마 전환 UI 컴포넌트

**주요 파일**: `src/components/ui/ThemeToggle.tsx`

```typescript
// src/components/ui/ThemeToggle.tsx
import React, { useState } from 'react'
import { Moon, Sun, Monitor, Check } from 'lucide-react'
import { useTheme, ThemeMode } from '@/contexts/ThemeContext'
import { cn } from '@/lib/utils'

// 간단한 토글 버튼
export const SimpleThemeToggle: React.FC<{
  className?: string
  size?: 'sm' | 'md' | 'lg'
}> = ({ className, size = 'md' }) => {
  const { resolvedTheme, setTheme } = useTheme()
  
  const sizeClasses = {
    sm: 'p-1.5',
    md: 'p-2',
    lg: 'p-3',
  }
  
  const iconSizes = {
    sm: 'w-4 h-4',
    md: 'w-5 h-5', 
    lg: 'w-6 h-6',
  }
  
  return (
    <button
      onClick={() => setTheme(resolvedTheme === 'dark' ? 'light' : 'dark')}
      className={cn(
        'rounded-md transition-all duration-200 ease-in-out',
        'bg-muted hover:bg-accent',
        'text-foreground hover:text-accent-foreground',
        'focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
        'active:scale-95',
        sizeClasses[size],
        className
      )}
      aria-label={`${resolvedTheme === 'dark' ? '라이트' : '다크'} 모드로 전환`}
      title={`${resolvedTheme === 'dark' ? '라이트' : '다크'} 모드로 전환`}
    >
      <div className="transition-transform duration-300 ease-in-out">
        {resolvedTheme === 'dark' ? (
          <Sun className={cn(iconSizes[size], 'animate-in spin-in-180 duration-300')} />
        ) : (
          <Moon className={cn(iconSizes[size], 'animate-in spin-in-180 duration-300')} />
        )}
      </div>
    </button>
  )
}

// 3단계 테마 선택기
export const ThemeToggle: React.FC<{
  className?: string
  variant?: 'buttons' | 'dropdown'
}> = ({ className, variant = 'buttons' }) => {
  const { theme, setTheme, resolvedTheme } = useTheme()
  const [isDropdownOpen, setIsDropdownOpen] = useState(false)
  
  const themeOptions: { value: ThemeMode; label: string; icon: React.ReactNode }[] = [
    {
      value: 'light',
      label: '라이트 모드',
      icon: <Sun className="w-4 h-4" />,
    },
    {
      value: 'system',
      label: '시스템 설정',
      icon: <Monitor className="w-4 h-4" />,
    },
    {
      value: 'dark',
      label: '다크 모드',
      icon: <Moon className="w-4 h-4" />,
    },
  ]
  
  if (variant === 'dropdown') {
    const currentOption = themeOptions.find(option => option.value === theme)
    
    return (
      <div className={cn('relative', className)}>
        <button
          onClick={() => setIsDropdownOpen(!isDropdownOpen)}
          className={cn(
            'flex items-center space-x-2 px-3 py-2 rounded-md',
            'bg-muted hover:bg-accent transition-colors',
            'focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2'
          )}
          aria-label="테마 선택"
          aria-expanded={isDropdownOpen}
        >
          {currentOption?.icon}
          <span className="text-sm font-medium">{currentOption?.label}</span>
        </button>
        
        {isDropdownOpen && (
          <>
            {/* 오버레이 */}
            <div
              className="fixed inset-0 z-30"
              onClick={() => setIsDropdownOpen(false)}
            />
            
            {/* 드롭다운 메뉴 */}
            <div className="absolute top-full left-0 mt-2 bg-popover border border-border rounded-md shadow-lg min-w-[160px] z-40">
              {themeOptions.map((option) => (
                <button
                  key={option.value}
                  onClick={() => {
                    setTheme(option.value)
                    setIsDropdownOpen(false)
                  }}
                  className={cn(
                    'flex items-center space-x-3 w-full px-3 py-2 text-left',
                    'hover:bg-accent transition-colors',
                    'first:rounded-t-md last:rounded-b-md',
                    theme === option.value && 'bg-accent'
                  )}
                >
                  {option.icon}
                  <span className="text-sm">{option.label}</span>
                  {theme === option.value && (
                    <Check className="w-4 h-4 ml-auto text-primary" />
                  )}
                </button>
              ))}
            </div>
          </>
        )}
      </div>
    )
  }
  
  return (
    <div className={cn(
      'flex items-center bg-muted rounded-lg p-1',
      className
    )}>
      {themeOptions.map((option) => (
        <button
          key={option.value}
          onClick={() => setTheme(option.value)}
          className={cn(
            'p-2 rounded-md transition-all duration-200',
            'flex items-center justify-center',
            'hover:bg-background hover:shadow-sm',
            'focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
            theme === option.value
              ? 'bg-background text-foreground shadow-sm'
              : 'text-muted-foreground hover:text-foreground'
          )}
          aria-label={option.label}
          title={option.label}
        >
          {option.icon}
        </button>
      ))}
    </div>
  )
}
```

### 3. 프로젝트 테마 시스템

**주요 파일**: `src/lib/themes/project-themes.ts`

```typescript
// src/lib/themes/project-themes.ts
import { useState, useEffect, useCallback } from 'react'

export const PROJECT_COLORS = {
  blue: {
    name: '블루 프로젝트',
    primary: 'var(--project-blue-500)',
    primaryForeground: 'var(--project-blue-50)',
    secondary: 'var(--project-blue-100)',
    accent: 'var(--project-blue-600)',
    gradient: 'linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%)',
    shadow: 'rgb(59 130 246 / 0.2)',
  },
  green: {
    name: '그린 프로젝트',
    primary: 'var(--project-green-500)',
    primaryForeground: 'var(--project-green-50)',
    secondary: 'var(--project-green-100)',
    accent: 'var(--project-green-600)',
    gradient: 'linear-gradient(135deg, #10B981 0%, #047857 100%)',
    shadow: 'rgb(16 185 129 / 0.2)',
  },
  purple: {
    name: '퍼플 프로젝트',
    primary: 'var(--project-purple-500)',
    primaryForeground: 'var(--project-purple-50)',
    secondary: 'var(--project-purple-100)',
    accent: 'var(--project-purple-600)',
    gradient: 'linear-gradient(135deg, #8B5CF6 0%, #6D28D9 100%)',
    shadow: 'rgb(139 92 246 / 0.2)',
  },
  orange: {
    name: '오렌지 프로젝트',
    primary: 'var(--project-orange-500)',
    primaryForeground: 'var(--project-orange-50)',
    secondary: 'var(--project-orange-100)',
    accent: 'var(--project-orange-600)',
    gradient: 'linear-gradient(135deg, #F59E0B 0%, #B45309 100%)',
    shadow: 'rgb(245 158 11 / 0.2)',
  },
  red: {
    name: '레드 프로젝트',
    primary: 'var(--project-red-500)',
    primaryForeground: 'var(--project-red-50)',
    secondary: 'var(--project-red-100)',
    accent: 'var(--project-red-600)',
    gradient: 'linear-gradient(135deg, #EF4444 0%, #B91C1C 100%)',
    shadow: 'rgb(239 68 68 / 0.2)',
  },
  teal: {
    name: '틸 프로젝트',
    primary: 'var(--project-teal-500)',
    primaryForeground: 'var(--project-teal-50)',
    secondary: 'var(--project-teal-100)',
    accent: 'var(--project-teal-600)',
    gradient: 'linear-gradient(135deg, #14B8A6 0%, #0F766E 100%)',
    shadow: 'rgb(20 184 166 / 0.2)',
  },
  pink: {
    name: '핑크 프로젝트',
    primary: 'var(--project-pink-500)',
    primaryForeground: 'var(--project-pink-50)',
    secondary: 'var(--project-pink-100)',
    accent: 'var(--project-pink-600)',
    gradient: 'linear-gradient(135deg, #EC4899 0%, #BE185D 100%)',
    shadow: 'rgb(236 72 153 / 0.2)',
  },
  indigo: {
    name: '인디고 프로젝트',
    primary: 'var(--project-indigo-500)',
    primaryForeground: 'var(--project-indigo-50)',
    secondary: 'var(--project-indigo-100)',
    accent: 'var(--project-indigo-600)',
    gradient: 'linear-gradient(135deg, #6366F1 0%, #4338CA 100%)',
    shadow: 'rgb(99 102 241 / 0.2)',
  },
} as const

export type ProjectColorKey = keyof typeof PROJECT_COLORS

// 프로젝트 ID와 색상 매핑
export const getProjectColorKey = (projectId: number): ProjectColorKey => {
  const colors: ProjectColorKey[] = [
    'blue', 'green', 'purple', 'orange', 
    'red', 'teal', 'pink', 'indigo'
  ]
  return colors[(projectId - 1) % colors.length] || 'blue'
}

// 프로젝트 테마 관리 훅
export const useProjectTheme = () => {
  const [currentProjectTheme, setCurrentProjectTheme] = useState<ProjectColorKey>('blue')
  const [appliedThemes, setAppliedThemes] = useState<Record<number, ProjectColorKey>>({})
  
  // CSS 변수 적용
  const applyCSSVariables = useCallback((colorKey: ProjectColorKey) => {
    const theme = PROJECT_COLORS[colorKey]
    const root = document.documentElement
    
    root.style.setProperty('--current-project-primary', theme.primary)
    root.style.setProperty('--current-project-primary-foreground', theme.primaryForeground)
    root.style.setProperty('--current-project-secondary', theme.secondary)
    root.style.setProperty('--current-project-accent', theme.accent)
    root.style.setProperty('--current-project-gradient', theme.gradient)
    root.style.setProperty('--current-project-shadow', theme.shadow)
  }, [])
  
  // 글로벌 프로젝트 테마 적용
  const applyGlobalTheme = useCallback((colorKey: ProjectColorKey) => {
    setCurrentProjectTheme(colorKey)
    applyCSSVariables(colorKey)
    
    try {
      localStorage.setItem('globalProjectTheme', colorKey)
    } catch (error) {
      console.warn('Failed to save global project theme:', error)
    }
  }, [applyCSSVariables])
  
  // 특정 프로젝트 테마 설정
  const setProjectTheme = useCallback((projectId: number, colorKey: ProjectColorKey) => {
    setAppliedThemes(prev => ({
      ...prev,
      [projectId]: colorKey,
    }))
    
    try {
      const savedThemes = JSON.parse(localStorage.getItem('projectThemes') || '{}')
      savedThemes[projectId] = colorKey
      localStorage.setItem('projectThemes', JSON.stringify(savedThemes))
    } catch (error) {
      console.warn('Failed to save project theme:', error)
    }
  }, [])
  
  // 프로젝트 테마 가져오기
  const getProjectTheme = useCallback((projectId: number): ProjectColorKey => {
    return appliedThemes[projectId] || getProjectColorKey(projectId)
  }, [appliedThemes])
  
  // 초기화
  useEffect(() => {
    try {
      // 글로벌 테마 로드
      const savedGlobalTheme = localStorage.getItem('globalProjectTheme') as ProjectColorKey
      if (savedGlobalTheme && PROJECT_COLORS[savedGlobalTheme]) {
        setCurrentProjectTheme(savedGlobalTheme)
        applyCSSVariables(savedGlobalTheme)
      }
      
      // 프로젝트별 테마 로드
      const savedProjectThemes = JSON.parse(localStorage.getItem('projectThemes') || '{}')
      setAppliedThemes(savedProjectThemes)
    } catch (error) {
      console.warn('Failed to load project themes:', error)
    }
  }, [applyCSSVariables])
  
  return {
    currentProjectTheme,
    availableThemes: PROJECT_COLORS,
    applyGlobalTheme,
    setProjectTheme,
    getProjectTheme,
    appliedThemes,
  }
}

// 프로젝트 색상 유틸리티
export const getProjectColorStyles = (projectId: number) => {
  const colorKey = getProjectColorKey(projectId)
  const theme = PROJECT_COLORS[colorKey]
  
  return {
    primary: theme.primary,
    primaryForeground: theme.primaryForeground,
    secondary: theme.secondary,
    accent: theme.accent,
    gradient: theme.gradient,
    shadow: theme.shadow,
  }
}
```

### 4. 반응형 디자인 시스템

**주요 파일**: `src/lib/hooks/useBreakpoint.ts`

```typescript
// src/lib/hooks/useBreakpoint.ts
import { useState, useEffect } from 'react'

export const BREAKPOINTS = {
  xs: 0,      // 모바일 세로 (0px+)
  sm: 640,    // 모바일 가로 (640px+)
  md: 768,    // 태블릿 (768px+)
  lg: 1024,   // 데스크톱 소형 (1024px+)
  xl: 1280,   // 데스크톱 중형 (1280px+)
  '2xl': 1536, // 데스크톱 대형 (1536px+)
} as const

export type Breakpoint = keyof typeof BREAKPOINTS

export const useBreakpoint = () => {
  const [breakpoint, setBreakpoint] = useState<Breakpoint>('md')
  const [width, setWidth] = useState<number>(1024)
  
  useEffect(() => {
    if (typeof window === 'undefined') return
    
    const handleResize = () => {
      const currentWidth = window.innerWidth
      setWidth(currentWidth)
      
      let currentBreakpoint: Breakpoint = 'xs'
      
      if (currentWidth >= BREAKPOINTS['2xl']) {
        currentBreakpoint = '2xl'
      } else if (currentWidth >= BREAKPOINTS.xl) {
        currentBreakpoint = 'xl'
      } else if (currentWidth >= BREAKPOINTS.lg) {
        currentBreakpoint = 'lg'
      } else if (currentWidth >= BREAKPOINTS.md) {
        currentBreakpoint = 'md'
      } else if (currentWidth >= BREAKPOINTS.sm) {
        currentBreakpoint = 'sm'
      } else {
        currentBreakpoint = 'xs'
      }
      
      setBreakpoint(currentBreakpoint)
    }
    
    // 초기 설정
    handleResize()
    
    // 리사이즈 이벤트 리스너
    window.addEventListener('resize', handleResize)
    
    // 정리
    return () => window.removeEventListener('resize', handleResize)
  }, [])
  
  // 편의 함수들
  const isMobile = breakpoint === 'xs' || breakpoint === 'sm'
  const isTablet = breakpoint === 'md'
  const isDesktop = breakpoint === 'lg' || breakpoint === 'xl' || breakpoint === '2xl'
  
  const isAbove = (bp: Breakpoint): boolean => {
    return width >= BREAKPOINTS[bp]
  }
  
  const isBelow = (bp: Breakpoint): boolean => {
    return width < BREAKPOINTS[bp]
  }
  
  const isBetween = (minBp: Breakpoint, maxBp: Breakpoint): boolean => {
    return width >= BREAKPOINTS[minBp] && width < BREAKPOINTS[maxBp]
  }
  
  return {
    breakpoint,
    width,
    isMobile,
    isTablet,
    isDesktop,
    isAbove,
    isBelow,
    isBetween,
  }
}

// 반응형 값 선택 훅
export const useResponsiveValue = <T>(values: Partial<Record<Breakpoint, T>>) => {
  const { breakpoint } = useBreakpoint()
  
  // 현재 브레이크포인트부터 역순으로 찾기
  const breakpointOrder: Breakpoint[] = ['2xl', 'xl', 'lg', 'md', 'sm', 'xs']
  const currentIndex = breakpointOrder.indexOf(breakpoint)
  
  for (let i = currentIndex; i < breakpointOrder.length; i++) {
    const bp = breakpointOrder[i]
    if (values[bp] !== undefined) {
      return values[bp]
    }
  }
  
  return values[breakpointOrder[breakpointOrder.length - 1]]
}

// 미디어 쿼리 유틸리티
export const createMediaQuery = {
  up: (bp: Breakpoint) => `@media (min-width: ${BREAKPOINTS[bp]}px)`,
  down: (bp: Breakpoint) => `@media (max-width: ${BREAKPOINTS[bp] - 1}px)`,
  between: (minBp: Breakpoint, maxBp: Breakpoint) => 
    `@media (min-width: ${BREAKPOINTS[minBp]}px) and (max-width: ${BREAKPOINTS[maxBp] - 1}px)`,
  only: (bp: Breakpoint) => {
    const breakpointOrder: Breakpoint[] = ['xs', 'sm', 'md', 'lg', 'xl', '2xl']
    const currentIndex = breakpointOrder.indexOf(bp)
    const nextBp = breakpointOrder[currentIndex + 1]
    
    if (!nextBp) {
      return `@media (min-width: ${BREAKPOINTS[bp]}px)`
    }
    
    return `@media (min-width: ${BREAKPOINTS[bp]}px) and (max-width: ${BREAKPOINTS[nextBp] - 1}px)`
  },
}
```

**주요 파일**: `src/components/layout/ResponsiveContainer.tsx`

```typescript
// src/components/layout/ResponsiveContainer.tsx
import React from 'react'
import { cn } from '@/lib/utils'
import { useBreakpoint } from '@/lib/hooks/useBreakpoint'

interface ResponsiveContainerProps {
  children: React.ReactNode
  className?: string
  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | '3xl' | '4xl' | 'full' | 'screen'
  padding?: {
    xs?: string
    sm?: string  
    md?: string
    lg?: string
    xl?: string
  } | string
  center?: boolean
}

export const ResponsiveContainer: React.FC<ResponsiveContainerProps> = ({
  children,
  className,
  maxWidth = 'xl',
  padding = 'px-4 sm:px-6 lg:px-8',
  center = true,
}) => {
  const { isMobile, isTablet } = useBreakpoint()
  
  // 최대 너비 클래스
  const maxWidthClasses = {
    sm: 'max-w-sm',
    md: 'max-w-md', 
    lg: 'max-w-lg',
    xl: 'max-w-xl',
    '2xl': 'max-w-2xl',
    '3xl': 'max-w-3xl',
    '4xl': 'max-w-4xl',
    full: 'max-w-full',
    screen: 'max-w-screen-2xl',
  }
  
  // 반응형 패딩 적용
  const paddingClasses = typeof padding === 'string' ? padding : [
    padding.xs && `px-${padding.xs}`,
    padding.sm && `sm:px-${padding.sm}`,
    padding.md && `md:px-${padding.md}`,
    padding.lg && `lg:px-${padding.lg}`,
    padding.xl && `xl:px-${padding.xl}`,
  ].filter(Boolean).join(' ')
  
  return (
    <div 
      className={cn(
        'w-full',
        maxWidthClasses[maxWidth],
        center && 'mx-auto',
        paddingClasses,
        className
      )}
    >
      {children}
    </div>
  )
}

// 반응형 그리드 시스템
interface ResponsiveGridProps {
  children: React.ReactNode
  cols?: {
    xs?: number
    sm?: number
    md?: number
    lg?: number
    xl?: number
    '2xl'?: number
  }
  gap?: 'xs' | 'sm' | 'md' | 'lg' | 'xl'
  className?: string
}

export const ResponsiveGrid: React.FC<ResponsiveGridProps> = ({
  children,
  cols = { xs: 1, sm: 2, md: 3, lg: 4 },
  gap = 'md',
  className,
}) => {
  const gapClasses = {
    xs: 'gap-1',
    sm: 'gap-2',
    md: 'gap-4',
    lg: 'gap-6',
    xl: 'gap-8',
  }
  
  const gridColClasses = [
    cols.xs && `grid-cols-${cols.xs}`,
    cols.sm && `sm:grid-cols-${cols.sm}`,
    cols.md && `md:grid-cols-${cols.md}`,
    cols.lg && `lg:grid-cols-${cols.lg}`,
    cols.xl && `xl:grid-cols-${cols.xl}`,
    cols['2xl'] && `2xl:grid-cols-${cols['2xl']}`,
  ].filter(Boolean).join(' ')
  
  return (
    <div className={cn(
      'grid',
      gridColClasses,
      gapClasses[gap],
      className
    )}>
      {children}
    </div>
  )
}

// 반응형 텍스트 크기
interface ResponsiveTextProps {
  children: React.ReactNode
  size?: {
    xs?: string
    sm?: string
    md?: string
    lg?: string
    xl?: string
  }
  className?: string
  as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span' | 'div'
}

export const ResponsiveText: React.FC<ResponsiveTextProps> = ({
  children,
  size = { xs: 'text-sm', sm: 'text-base', md: 'text-lg', lg: 'text-xl' },
  className,
  as: Component = 'p',
}) => {
  const textSizeClasses = [
    size.xs && size.xs,
    size.sm && `sm:${size.sm}`,
    size.md && `md:${size.md}`,
    size.lg && `lg:${size.lg}`,
    size.xl && `xl:${size.xl}`,
  ].filter(Boolean).join(' ')
  
  return (
    <Component className={cn(textSizeClasses, className)}>
      {children}
    </Component>
  )
}
```

### 5. 접근성 유틸리티 시스템

**주요 파일**: `src/lib/utils/accessibility.ts`

```typescript
// src/lib/utils/accessibility.ts

// 색상 대비 계산
export const calculateColorContrast = (foreground: string, background: string): number => {
  // HEX 색상을 RGB로 변환
  const hexToRgb = (hex: string): { r: number; g: number; b: number } => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16),
    } : { r: 0, g: 0, b: 0 }
  }
  
  // 상대적 휘도 계산
  const getLuminance = (r: number, g: number, b: number): number => {
    const [rs, gs, bs] = [r, g, b].map(c => {
      const channel = c / 255
      return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4)
    })
    return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs
  }
  
  const fg = hexToRgb(foreground)
  const bg = hexToRgb(background)
  
  const l1 = getLuminance(fg.r, fg.g, fg.b)
  const l2 = getLuminance(bg.r, bg.g, bg.b)
  
  const lighter = Math.max(l1, l2)
  const darker = Math.min(l1, l2)
  
  return (lighter + 0.05) / (darker + 0.05)
}

// 접근성 대비 검사
export const isAccessibleContrast = (
  foreground: string, 
  background: string, 
  level: 'AA' | 'AAA' = 'AA',
  isLargeText = false
): boolean => {
  const contrast = calculateColorContrast(foreground, background)
  
  if (level === 'AAA') {
    return isLargeText ? contrast >= 4.5 : contrast >= 7
  }
  
  // AA 기준
  return isLargeText ? contrast >= 3 : contrast >= 4.5
}

// 사용자 선호도 감지 훅
export const useAccessibilityPreferences = () => {
  const [preferences, setPreferences] = useState({
    reducedMotion: false,
    highContrast: false,
    increasedContrast: false,
  })
  
  useEffect(() => {
    if (typeof window === 'undefined') return
    
    const updatePreferences = () => {
      setPreferences({
        reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
        highContrast: window.matchMedia('(prefers-contrast: high)').matches,
        increasedContrast: window.matchMedia('(prefers-contrast: more)').matches,
      })
    }
    
    // 초기 설정
    updatePreferences()
    
    // 변경 감지
    const mediaQueries = [
      window.matchMedia('(prefers-reduced-motion: reduce)'),
      window.matchMedia('(prefers-contrast: high)'),
      window.matchMedia('(prefers-contrast: more)'),
    ]
    
    mediaQueries.forEach(mq => {
      mq.addEventListener('change', updatePreferences)
    })
    
    return () => {
      mediaQueries.forEach(mq => {
        mq.removeEventListener('change', updatePreferences)
      })
    }
  }, [])
  
  return preferences
}

// 접근성 친화적 애니메이션 유틸리티
export const getAccessibleAnimation = (
  animation: string, 
  fallback: string = 'none',
  respectsMotionPreference = true
): string => {
  if (!respectsMotionPreference) return animation
  
  return `
    animation: ${animation};
    
    @media (prefers-reduced-motion: reduce) {
      animation: ${fallback};
      transition: none;
    }
  `
}

// 포커스 관리 유틸리티
export class FocusManager {
  private static focusableSelectors = [
    'button:not([disabled])',
    'input:not([disabled])',
    'textarea:not([disabled])',
    'select:not([disabled])',
    'a[href]',
    '[tabindex]:not([tabindex="-1"])',
    '[contenteditable="true"]',
  ].join(', ')
  
  static getFocusableElements(container: HTMLElement): HTMLElement[] {
    return Array.from(container.querySelectorAll(this.focusableSelectors))
  }
  
  static trapFocus(container: HTMLElement) {
    const focusableElements = this.getFocusableElements(container)
    const firstFocusable = focusableElements[0]
    const lastFocusable = focusableElements[focusableElements.length - 1]
    
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key !== 'Tab') return
      
      if (event.shiftKey) {
        if (document.activeElement === firstFocusable) {
          event.preventDefault()
          lastFocusable.focus()
        }
      } else {
        if (document.activeElement === lastFocusable) {
          event.preventDefault()
          firstFocusable.focus()
        }
      }
    }
    
    container.addEventListener('keydown', handleKeyDown)
    
    // 초기 포커스
    if (firstFocusable) {
      firstFocusable.focus()
    }
    
    // 정리 함수 반환
    return () => {
      container.removeEventListener('keydown', handleKeyDown)
    }
  }
  
  static restoreFocus(previousActiveElement: Element | null) {
    if (previousActiveElement && 'focus' in previousActiveElement) {
      (previousActiveElement as HTMLElement).focus()
    }
  }
}

// ARIA 속성 유틸리티
export const createAriaProps = {
  describedBy: (id: string) => ({ 'aria-describedby': id }),
  labelledBy: (id: string) => ({ 'aria-labelledby': id }),
  expanded: (expanded: boolean) => ({ 'aria-expanded': expanded }),
  selected: (selected: boolean) => ({ 'aria-selected': selected }),
  pressed: (pressed: boolean) => ({ 'aria-pressed': pressed }),
  hidden: (hidden: boolean) => ({ 'aria-hidden': hidden }),
  disabled: (disabled: boolean) => ({ 'aria-disabled': disabled }),
  required: (required: boolean) => ({ 'aria-required': required }),
  invalid: (invalid: boolean) => ({ 'aria-invalid': invalid }),
  live: (live: 'off' | 'polite' | 'assertive') => ({ 'aria-live': live }),
}
```

---

## 🎨 UX 디자인 고려사항

### 테마 전환 사용자 경험
- **부드러운 전환**: 테마 변경 시 깜빡임 없는 자연스러운 애니메이션
- **시스템 연동**: 사용자 OS 설정과 자동 동기화
- **저장 및 복원**: 사용자 선택 기억 및 재방문 시 자동 적용

### 반응형 디자인 원칙
- **모바일 퍼스트**: 작은 화면부터 점진적 향상
- **터치 친화적**: 44px 이상의 터치 타겟 크기
- **콘텐츠 우선**: 화면 크기에 관계없이 핵심 기능 접근성 보장

### 접근성 중심 설계
- **키보드 네비게이션**: 모든 기능의 키보드 접근성
- **스크린 리더**: 의미있는 ARIA 라벨 및 구조
- **색상 독립성**: 색상만으로 정보 전달하지 않는 설계

---

## ⚡ 성능 최적화

### 테마 로딩 최적화
- **초기 렌더링**: 테마 깜빡임 방지를 위한 블로킹 스크립트
- **CSS 변수**: 런타임 스타일 변경의 효율적 구현
- **로컬 스토리지**: 빠른 테마 복원을 위한 캐싱

### 반응형 성능
- **미디어 쿼리 최적화**: 필요한 브레이크포인트만 사용
- **이미지 반응형**: srcSet과 sizes 속성으로 적절한 이미지 로드
- **지연 로딩**: 화면 밖 컨텐츠의 지연 로딩으로 초기 로딩 최적화

---

## 🧪 Definition of Done

### 테마 시스템 구현 요구사항
- [ ] 라이트/다크/시스템 자동 모드 완전 구현
- [ ] 8가지 프로젝트 테마 색상 시스템 구축
- [ ] 테마 전환 시 깜빡임 없는 부드러운 애니메이션
- [ ] 테마 설정 로컬 스토리지 저장 및 복원

### 반응형 디자인 요구사항
- [ ] 6단계 브레이크포인트 시스템 (xs~2xl) 완성
- [ ] 모바일 퍼스트 CSS 아키텍처 적용
- [ ] 모든 UI 컴포넌트의 반응형 동작 검증
- [ ] 터치 디바이스 최적화 (최소 44px 타겟)

### 접근성 요구사항
- [ ] WCAG 2.1 AA 기준 색상 대비율 4.5:1 이상 달성
- [ ] prefers-reduced-motion 지원으로 모션 민감성 고려
- [ ] 키보드만으로 모든 기능 접근 가능
- [ ] 스크린 리더 호환성 검증

### 성능 및 최적화 요구사항
- [ ] 테마 전환 시간 < 300ms
- [ ] 초기 테마 로딩 시간 < 100ms
- [ ] 반응형 리사이즈 성능 최적화 (60fps 유지)
- [ ] 색상 대비 계산 함수 성능 < 1ms

### 품질 보증 요구사항
- [ ] Jest 단위 테스트 커버리지 > 85%
- [ ] 다양한 디바이스에서 시각적 회귀 테스트 통과
- [ ] 접근성 자동 테스트 도구 (axe) 통과
- [ ] 크로스 브라우저 호환성 검증

---

## 📚 관련 문서

- [07-theme-responsive-design.md](../ui-architecture/07-theme-responsive-design.md) - 테마 및 반응형 아키텍처
- [Story 2.14: Design System Foundations](./2.14.design-system-foundations.md) - 디자인 토큰 기초
- [Story 2.15: Component Styling Patterns](./2.15.component-styling-patterns.md) - 스타일링 패턴
- [Story 2.6: Accessibility Implementation](./2.6.accessibility-implementation.md) - 접근성 구현

---

## 📈 성공 지표

### 사용자 만족도 지표
- **테마 사용률**: 다크 모드 사용률 > 40%
- **프로젝트 테마 활용률**: 커스텀 테마 설정률 > 60%
- **접근성 피드백**: 접근성 관련 사용자 불만 < 1%
- **모바일 사용성**: 모바일 사용자 이탈률 < 15%

### 기술적 성능 지표
- **테마 전환 성능**: 평균 전환 시간 < 200ms
- **반응형 성능**: 리사이즈 시 레이아웃 변경 지연 < 16ms (60fps)
- **접근성 점수**: Lighthouse 접근성 점수 > 95
- **색상 대비 준수율**: 모든 텍스트-배경 조합 AA 기준 통과

### 개발 효율성 지표
- **테마 적용 시간**: 새로운 컴포넌트 테마 적용 시간 70% 단축
- **반응형 구현 시간**: 새로운 레이아웃 반응형 구현 시간 50% 단축
- **버그 발생률**: 테마 및 반응형 관련 버그 < 2%/월
- **코드 재사용률**: 테마 및 반응형 유틸리티 재사용률 > 90%

### 접근성 효과 지표
- **키보드 사용자 만족도**: 키보드 네비게이션 완성도 > 95%
- **스크린 리더 호환성**: 주요 기능 스크린 리더 접근성 100%
- **고대비 모드 지원**: 시각적 대비 필요 사용자 지원률 100%
- **모션 민감성 대응**: prefers-reduced-motion 준수율 100%