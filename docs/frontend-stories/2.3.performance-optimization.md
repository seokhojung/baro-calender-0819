# Story 2.5: 성능 최적화 시스템

## Status
Ready for Development

## Priority & Dependencies
- **Priority**: P1 (High)
- **Story Points**: 5
- **Dependencies**: [1.2, 2.2, 2.4]
- **Blocked By**: None

## Success Metrics
- **Business KPI**: 
  - 페이지 로드 시간 2초 이내
  - 사용자 이탈률 10% 감소
  - 모바일 사용자 만족도 4.3/5.0 이상
- **Technical KPI**:
  - Core Web Vitals: LCP <2.5s, FID <100ms, CLS <0.1
  - 메모리 사용량 100MB 이하
  - 60fps 유지 (1000개 이벤트)
- **Definition of Success**: 모든 Core Web Vitals "Good" 달성

## Risks & Mitigations
- **Technical Risks**: 
  - Risk: 과도한 최적화로 코드 복잡도 증가
  - Impact: Medium
  - Mitigation: 성능 버젯 적용, 점진적 최적화
- **Schedule Risks**:
  - Risk: 브라우저별 성능 차이
  - Impact: Low
  - Mitigation: 폴리필 전략, 점진적 향상

---

## 🎯 **스토리 목표**

**완전한 성능 최적화 시스템 구현**
- 런타임 성능 최적화 (메모이제이션, 가상화)
- 빌드 및 번들 최적화
- 네트워크 성능 최적화
- 메모리 사용량 최적화
- Core Web Vitals 개선

---

## Story
**As a** 사용자,
**I want** 빠르고 부드럽게 작동하는 고성능 캘린더 애플리케이션을 사용하여,
**so that** 대량의 일정도 끊김 없이 관리하고 어떤 디바이스에서도 쿨적한 사용 경험을 느낄 수 있다.

## Acceptance Criteria
1. 앱이 빠르게 로딩되고 부드럽게 작동하기를 원한다
2. 많은 이벤트가 있어도 스크롤이 끊기지 않기를 원한다
3. 네트워크가 느려도 기본 기능은 사용할 수 있기를 원한다
4. 메모리 부족으로 인한 브라우저 크래시가 없기를 원한다
5. 모든 디바이스에서 일관된 성능을 경험하고 싶다

---

## 🏗️ **기술적 구현 요구사항**

### **1. 런타임 성능 최적화**

**React 메모이제이션 최적화**
```typescript
// src/lib/performance/memo-utils.ts
import React, { useMemo, useCallback, useRef } from 'react'
import { isEqual } from 'lodash-es'

// 깊은 메모이제이션을 위한 커스텀 훅
export const useDeepMemo = <T>(factory: () => T, deps: React.DependencyList) => {
  const ref = useRef<{ deps: React.DependencyList; value: T }>()
  
  if (!ref.current || !isEqual(ref.current.deps, deps)) {
    ref.current = { deps, value: factory() }
  }
  
  return ref.current.value
}

// 안정적인 콜백 참조를 위한 훅
export const useStableCallback = <T extends (...args: any[]) => any>(callback: T): T => {
  const callbackRef = useRef(callback)
  callbackRef.current = callback
  
  return useCallback(((...args: Parameters<T>) => {
    return callbackRef.current(...args)
  }) as T, [])
}

// 비싼 계산을 위한 메모이제이션
export const useMemoizedEvents = (events: CalendarEvent[], filters: EventFilters) => {
  return useMemo(() => {
    console.time('Event filtering')
    
    let filtered = events
    
    // 날짜 필터링
    if (filters.startDate && filters.endDate) {
      filtered = filtered.filter(event => 
        event.startDate >= filters.startDate! && 
        event.endDate <= filters.endDate!
      )
    }
    
    // 프로젝트 필터링
    if (filters.projectIds?.length) {
      filtered = filtered.filter(event => 
        filters.projectIds!.includes(event.projectId)
      )
    }
    
    // 상태 필터링
    if (filters.status?.length) {
      filtered = filtered.filter(event => 
        filters.status!.includes(event.status)
      )
    }
    
    // 정렬
    const sorted = filtered.sort((a, b) => 
      a.startDate.getTime() - b.startDate.getTime()
    )
    
    console.timeEnd('Event filtering')
    return sorted
  }, [events, filters.startDate, filters.endDate, filters.projectIds, filters.status])
}

// 최적화된 이벤트 컴포넌트
export const OptimizedEventItem = React.memo<{
  event: CalendarEvent
  onClick?: (event: CalendarEvent) => void
  onUpdate?: (id: string, updates: Partial<CalendarEvent>) => void
}>(({ event, onClick, onUpdate }) => {
  const handleClick = useStableCallback(() => onClick?.(event))
  const handleUpdate = useStableCallback((updates: Partial<CalendarEvent>) => 
    onUpdate?.(event.id, updates)
  )
  
  return (
    <div 
      className="event-item"
      onClick={handleClick}
      style={{ borderColor: event.projectColor }}
    >
      <h3>{event.title}</h3>
      <p>{format(event.startDate, 'MMM d, h:mm a')}</p>
    </div>
  )
}, (prevProps, nextProps) => {
  // 커스텀 비교 함수
  return (
    prevProps.event.id === nextProps.event.id &&
    prevProps.event.title === nextProps.event.title &&
    prevProps.event.startDate.getTime() === nextProps.event.startDate.getTime() &&
    prevProps.event.updatedAt?.getTime() === nextProps.event.updatedAt?.getTime()
  )
})
```

**가상화 구현**
```typescript
// src/components/performance/VirtualizedCalendar.tsx
import React, { useMemo, useCallback, useRef, useEffect, useState } from 'react'
import { VariableSizeList as List, areEqual } from 'react-window'
import { CalendarEvent } from '@/types/calendar'

interface VirtualizedCalendarProps {
  events: CalendarEvent[]
  containerHeight: number
  onEventClick?: (event: CalendarEvent) => void
}

const ITEM_HEIGHT = 80
const OVERSCAN_COUNT = 5

export const VirtualizedCalendar: React.FC<VirtualizedCalendarProps> = ({
  events,
  containerHeight,
  onEventClick
}) => {
  const listRef = useRef<List>(null)
  const [scrollOffset, setScrollOffset] = useState(0)
  
  // 이벤트 그룹화 (날짜별)
  const groupedEvents = useMemo(() => {
    const groups = new Map<string, CalendarEvent[]>()
    
    events.forEach(event => {
      const dateKey = format(event.startDate, 'yyyy-MM-dd')
      if (!groups.has(dateKey)) {
        groups.set(dateKey, [])
      }
      groups.get(dateKey)!.push(event)
    })
    
    return Array.from(groups.entries()).map(([date, events]) => ({
      date,
      events,
      type: 'group' as const
    }))
  }, [events])
  
  // 가변 높이 계산
  const getItemSize = useCallback((index: number) => {
    const group = groupedEvents[index]
    return 40 + (group.events.length * ITEM_HEIGHT) // 헤더 + 이벤트들
  }, [groupedEvents])
  
  // 스크롤 최적화를 위한 debounce
  const debouncedScrollHandler = useCallback(
    debounce((scrollTop: number) => {
      setScrollOffset(scrollTop)
    }, 16), // ~60fps
    []
  )
  
  const handleScroll = ({ scrollTop }: { scrollTop: number }) => {
    debouncedScrollHandler(scrollTop)
  }
  
  return (
    <List
      ref={listRef}
      height={containerHeight}
      itemCount={groupedEvents.length}
      itemSize={getItemSize}
      overscanCount={OVERSCAN_COUNT}
      onScroll={handleScroll}
    >
      {({ index, style }) => (
        <VirtualizedEventGroup
          index={index}
          style={style}
          group={groupedEvents[index]}
          onEventClick={onEventClick}
        />
      )}
    </List>
  )
}

// 가상화된 이벤트 그룹 컴포넌트
const VirtualizedEventGroup = React.memo<{
  index: number
  style: React.CSSProperties
  group: { date: string; events: CalendarEvent[] }
  onEventClick?: (event: CalendarEvent) => void
}>(({ index, style, group, onEventClick }) => {
  return (
    <div style={style} className="virtual-event-group">
      {/* 날짜 헤더 */}
      <div className="event-group-header">
        <h3>{format(new Date(group.date), 'EEEE, MMMM d')}</h3>
      </div>
      
      {/* 이벤트 목록 */}
      <div className="event-list">
        {group.events.map(event => (
          <OptimizedEventItem
            key={event.id}
            event={event}
            onClick={onEventClick}
          />
        ))}
      </div>
    </div>
  )
}, areEqual)
```

### **2. 빌드 및 번들 최적화**

**Next.js 설정 최적화**
```javascript
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

/** @type {import('next').NextConfig} */
const nextConfig = {
  // 실험적 기능
  experimental: {
    optimizeCss: true,
    modularizeImports: {
      'lucide-react': {
        transform: 'lucide-react/dist/esm/icons/{{member}}',
        skipDefaultConversion: true,
      },
      'date-fns': {
        transform: 'date-fns/{{member}}',
      },
    },
  },
  
  // 컴파일러 최적화
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
    styledComponents: true,
  },
  
  // 이미지 최적화
  images: {
    domains: ['example.com'],
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
  
  // Webpack 설정
  webpack: (config, { dev, isServer }) => {
    // 프로덕션에서 소스맵 최적화
    if (!dev && !isServer) {
      config.devtool = 'source-map'
    }
    
    // 번들 분할 최적화
    config.optimization = {
      ...config.optimization,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
          common: {
            name: 'common',
            minChunks: 2,
            priority: -10,
            reuseExistingChunk: true,
          },
        },
      },
    }
    
    // Tree shaking 최적화
    config.optimization.usedExports = true
    config.optimization.sideEffects = false
    
    // Gzip 압축
    if (!dev) {
      const CompressionPlugin = require('compression-webpack-plugin')
      config.plugins.push(
        new CompressionPlugin({
          algorithm: 'gzip',
          test: /\.(js|css|html|svg)$/,
          threshold: 8192,
          minRatio: 0.8,
        })
      )
    }
    
    return config
  },
  
  // 헤더 설정
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
        ],
      },
      // 정적 자산 캐싱
      {
        source: '/static/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ]
  },
}

module.exports = withBundleAnalyzer(nextConfig)
```

**코드 스플리팅 최적화**
```typescript
// src/lib/performance/code-splitting.ts
import { lazy, Suspense } from 'react'
import { ErrorBoundary } from 'react-error-boundary'

// 지연 로딩된 컴포넌트들
export const LazyEventModal = lazy(() => 
  import('../components/event/EventModal').then(module => ({
    default: module.EventModal
  }))
)

export const LazyCalendarSettings = lazy(() => 
  import('../components/settings/CalendarSettings')
)

export const LazyReportDashboard = lazy(() => 
  import('../components/reports/ReportDashboard')
)

// HOC for lazy loading with error boundary
export function withLazyLoading<P extends object>(
  Component: React.LazyExoticComponent<React.ComponentType<P>>,
  fallback?: React.ReactNode
) {
  return function LazyComponent(props: P) {
    return (
      <ErrorBoundary
        fallback={<div>컴포넌트 로딩 중 오류가 발생했습니다.</div>}
        onError={(error) => console.error('Lazy loading error:', error)}
      >
        <Suspense fallback={fallback || <LoadingSpinner />}>
          <Component {...props} />
        </Suspense>
      </ErrorBoundary>
    )
  }
}

// 동적 import helper
export const dynamicImport = {
  eventModal: () => import('../components/event/EventModal'),
  reportDashboard: () => import('../components/reports/ReportDashboard'),
  settingsPanel: () => import('../components/settings/SettingsPanel'),
}

// Preload critical components
export const preloadComponents = () => {
  if (typeof window !== 'undefined') {
    // Critical components 미리 로드
    setTimeout(() => {
      dynamicImport.eventModal()
    }, 2000)
  }
}
```

### **3. 네트워크 성능 최적화**

**HTTP 캐싱 전략**
```typescript
// src/lib/performance/cache-manager.ts
interface CacheConfig {
  maxAge: number
  staleWhileRevalidate?: number
  maxEntries?: number
}

export class CacheManager {
  private cache = new Map<string, { data: any; timestamp: number; maxAge: number }>()
  private maxEntries: number
  
  constructor(maxEntries = 100) {
    this.maxEntries = maxEntries
  }
  
  set(key: string, data: any, config: CacheConfig) {
    // LRU 캐시 구현
    if (this.cache.size >= this.maxEntries) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      maxAge: config.maxAge
    })
  }
  
  get(key: string): any | null {
    const cached = this.cache.get(key)
    
    if (!cached) return null
    
    const isExpired = Date.now() - cached.timestamp > cached.maxAge
    
    if (isExpired) {
      this.cache.delete(key)
      return null
    }
    
    // Move to end (LRU)
    this.cache.delete(key)
    this.cache.set(key, cached)
    
    return cached.data
  }
  
  invalidate(key: string) {
    this.cache.delete(key)
  }
  
  clear() {
    this.cache.clear()
  }
}

// API 요청 최적화
export const optimizedFetch = async <T>(
  url: string,
  options: RequestInit & { cache?: CacheConfig } = {}
): Promise<T> => {
  const cacheKey = `${url}-${JSON.stringify(options)}`
  const cacheManager = new CacheManager()
  
  // 캐시 확인
  if (options.cache) {
    const cached = cacheManager.get(cacheKey)
    if (cached) return cached
  }
  
  try {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 10000) // 10초 타임아웃
    
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    })
    
    clearTimeout(timeoutId)
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    
    const data = await response.json()
    
    // 캐시 저장
    if (options.cache) {
      cacheManager.set(cacheKey, data, options.cache)
    }
    
    return data
  } catch (error) {
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error('Request timeout')
    }
    throw error
  }
}
```

**데이터 패칭 최적화**
```typescript
// src/hooks/useOptimizedQuery.ts
import { useQuery, useQueryClient } from '@tanstack/react-query'
import { useIntersectionObserver } from './useIntersectionObserver'

export const useOptimizedEvents = (filters: EventFilters) => {
  const queryClient = useQueryClient()
  
  return useQuery({
    queryKey: ['events', filters],
    queryFn: async () => {
      // 백그라운드에서 다음 페이지 미리 로드
      setTimeout(() => {
        const nextFilters = { ...filters, page: (filters.page || 1) + 1 }
        queryClient.prefetchQuery({
          queryKey: ['events', nextFilters],
          queryFn: () => fetchEvents(nextFilters)
        })
      }, 1000)
      
      return fetchEvents(filters)
    },
    staleTime: 5 * 60 * 1000, // 5분간 fresh
    cacheTime: 30 * 60 * 1000, // 30분간 캐시
    refetchOnWindowFocus: false,
    retry: 3,
  })
}

// Intersection Observer를 활용한 무한 스크롤
export const useInfiniteEvents = () => {
  const [hasMore, setHasMore] = useState(true)
  const [isIntersecting, targetRef] = useIntersectionObserver({
    threshold: 0.1,
    rootMargin: '100px'
  })
  
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useInfiniteQuery({
    queryKey: ['events-infinite'],
    queryFn: ({ pageParam = 0 }) => fetchEvents({ page: pageParam }),
    getNextPageParam: (lastPage) => lastPage.nextPage,
  })
  
  useEffect(() => {
    if (isIntersecting && hasNextPage && !isFetchingNextPage) {
      fetchNextPage()
    }
  }, [isIntersecting, hasNextPage, isFetchingNextPage, fetchNextPage])
  
  return {
    events: data?.pages.flatMap(page => page.events) || [],
    targetRef,
    hasMore,
    isLoading: isFetchingNextPage
  }
}
```

### **4. 메모리 관리 최적화**

**메모리 누수 방지**
```typescript
// src/lib/performance/memory-manager.ts
export class MemoryManager {
  private static timers = new Set<NodeJS.Timeout>()
  private static listeners = new Set<{ element: EventTarget; event: string; listener: EventListener }>()
  private static observers = new Set<IntersectionObserver | ResizeObserver | MutationObserver>()
  
  // 타이머 관리
  static setTimeout(callback: () => void, ms: number): NodeJS.Timeout {
    const timer = setTimeout(() => {
      callback()
      this.timers.delete(timer)
    }, ms)
    
    this.timers.add(timer)
    return timer
  }
  
  static setInterval(callback: () => void, ms: number): NodeJS.Timeout {
    const timer = setInterval(callback, ms)
    this.timers.add(timer)
    return timer
  }
  
  static clearTimer(timer: NodeJS.Timeout) {
    clearTimeout(timer)
    clearInterval(timer)
    this.timers.delete(timer)
  }
  
  // 이벤트 리스너 관리
  static addEventListener(
    element: EventTarget,
    event: string,
    listener: EventListener,
    options?: boolean | AddEventListenerOptions
  ) {
    element.addEventListener(event, listener, options)
    this.listeners.add({ element, event, listener })
  }
  
  static removeEventListener(
    element: EventTarget,
    event: string,
    listener: EventListener
  ) {
    element.removeEventListener(event, listener)
    this.listeners.delete(
      Array.from(this.listeners).find(l => 
        l.element === element && l.event === event && l.listener === listener
      )!
    )
  }
  
  // Observer 관리
  static addObserver(observer: IntersectionObserver | ResizeObserver | MutationObserver) {
    this.observers.add(observer)
  }
  
  static removeObserver(observer: IntersectionObserver | ResizeObserver | MutationObserver) {
    observer.disconnect()
    this.observers.delete(observer)
  }
  
  // 모든 리소스 정리
  static cleanup() {
    // 타이머 정리
    this.timers.forEach(timer => this.clearTimer(timer))
    this.timers.clear()
    
    // 이벤트 리스너 정리
    this.listeners.forEach(({ element, event, listener }) => {
      element.removeEventListener(event, listener)
    })
    this.listeners.clear()
    
    // Observer 정리
    this.observers.forEach(observer => observer.disconnect())
    this.observers.clear()
  }
}

// 자동 정리 Hook
export const useAutoCleanup = () => {
  useEffect(() => {
    return () => {
      MemoryManager.cleanup()
    }
  }, [])
}
```

### **5. 성능 모니터링**

**Core Web Vitals 모니터링**
```typescript
// src/lib/performance/vitals.ts
export const measureWebVitals = () => {
  if (typeof window === 'undefined') return
  
  // LCP (Largest Contentful Paint)
  new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries()
    const lastEntry = entries[entries.length - 1] as PerformanceEventTiming
    
    console.log('LCP:', lastEntry.startTime)
    
    // 분석 도구로 전송
    sendAnalytics('lcp', lastEntry.startTime)
  }).observe({ type: 'largest-contentful-paint', buffered: true })
  
  // FID (First Input Delay)
  new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries()
    entries.forEach((entry) => {
      console.log('FID:', entry.processingStart - entry.startTime)
      sendAnalytics('fid', entry.processingStart - entry.startTime)
    })
  }).observe({ type: 'first-input', buffered: true })
  
  // CLS (Cumulative Layout Shift)
  let clsValue = 0
  new PerformanceObserver((entryList) => {
    const entries = entryList.getEntries()
    entries.forEach((entry) => {
      if (!(entry as any).hadRecentInput) {
        clsValue += (entry as any).value
      }
    })
    
    console.log('CLS:', clsValue)
    sendAnalytics('cls', clsValue)
  }).observe({ type: 'layout-shift', buffered: true })
  
  // Runtime Performance
  const measureRenderTime = () => {
    const start = performance.now()
    
    requestAnimationFrame(() => {
      const end = performance.now()
      const renderTime = end - start
      
      if (renderTime > 16) { // 60fps를 못 맞췄을 때
        console.warn('Slow render:', renderTime)
        sendAnalytics('slow-render', renderTime)
      }
    })
  }
  
  // 주기적으로 렌더링 시간 측정
  setInterval(measureRenderTime, 5000)
}

const sendAnalytics = (metric: string, value: number) => {
  if (process.env.NODE_ENV === 'production') {
    fetch('/api/analytics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ metric, value, url: window.location.pathname })
    })
  }
}
```

---

## 📊 **성능 목표**

### **Core Web Vitals 목표**
- LCP (Largest Contentful Paint): < 2.5초
- FID (First Input Delay): < 100ms  
- CLS (Cumulative Layout Shift): < 0.1

### **기타 성능 지표**
- Time to Interactive (TTI): < 3.8초
- First Contentful Paint (FCP): < 1.8초
- Bundle Size: < 500KB (gzipped)
- Memory Usage: < 50MB

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] 메모이제이션 및 가상화 구현
- [ ] 코드 스플리팅 및 지연 로딩
- [ ] 캐싱 전략 구현
- [ ] 메모리 누수 방지
- [ ] 성능 모니터링 시스템

### **기술 요구사항**
- [ ] React 최적화 패턴 적용
- [ ] Webpack/Next.js 빌드 최적화
- [ ] HTTP 캐싱 구현
- [ ] 번들 크기 최적화

### **성능 요구사항**
- [ ] Lighthouse 성능 점수 90+
- [ ] Core Web Vitals 기준 충족
- [ ] 60fps 스크롤 성능 유지
- [ ] 메모리 사용량 최적화

### **테스트 요구사항**
- [ ] 성능 회귀 테스트
- [ ] 번들 크기 모니터링
- [ ] 메모리 누수 테스트
- [ ] 다양한 디바이스 성능 테스트

---

## 📚 **관련 문서 참조**

- [08. Runtime Performance](../ui-architecture/08-runtime-performance.md)
- [09. Build & Bundle Optimization](../ui-architecture/09-build-bundle-optimization.md)
- [21. Observability & Monitoring](../ui-architecture/21-observability-monitoring.md)

---

**이 스토리는 바로캘린더의 성능 최적화 구현을 위한 종합적인 기술 가이드입니다. 사용자에게 빠르고 부드러운 경험을 제공하기 위한 모든 최적화 기법을 포함합니다.**