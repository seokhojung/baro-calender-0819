# Story 2.24: 파일 첨부 시스템 구현

## Status
Draft

## Story
**As a** 사용자,
**I want** 일정에 파일을 첨부하고 관리할 수 있는 시스템을 통해,
**so that** 회의 자료, 이미지, 문서 등을 일정과 함께 체계적으로 보관하고 공유할 수 있다.

## Story Points
**10**

## Prerequisites
- [ ] Story 2.11 (REST API 통합) 완료
- [ ] Story 2.3 (일정 CRUD 시스템) 완료
- [ ] Story 2.1 (프로젝트 관리 시스템) 완료

## Acceptance Criteria
1. **드래그 앤 드롭 업로드**: 직관적인 파일 첨부를 위한 드래그 앤 드롭 영역 제공해야 한다
2. **다중 파일 지원**: 최대 10개 파일, 총 100MB까지 첨부 지원해야 한다
3. **파일 타입 제한**: 이미지, PDF, 오피스 문서, 텍스트 파일만 허용해야 한다
4. **미리보기 기능**: 이미지/PDF 파일 인라인 미리보기 제공해야 한다
5. **업로드 진행률**: 실시간 업로드 진행률 표시 및 취소 기능 제공해야 한다
6. **파일 관리**: 첨부파일 목록, 다운로드, 삭제 기능 제공해야 한다
7. **보안 검증**: 파일 타입, 크기, 악성코드 검사 구현해야 한다
8. **접근성 준수**: WCAG 2.1 AA 기준, 키보드 탐색 및 스크린 리더 지원해야 한다

## Tasks / Subtasks

- [ ] **1단계: 파일 업로드 컴포넌트** (AC: 1, 2, 8)
  - [ ] FileUploadZone.tsx 구현
    ```tsx
    interface FileUploadProps {
      maxFiles?: number
      maxTotalSize?: number
      acceptedTypes?: string[]
      onFilesAdded: (files: File[]) => void
      onError: (error: FileUploadError) => void
    }
    
    const FileUploadZone: React.FC<FileUploadProps> = ({
      maxFiles = 10,
      maxTotalSize = 100 * 1024 * 1024, // 100MB
      acceptedTypes = [
        'image/*',
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'text/plain'
      ],
      onFilesAdded,
      onError
    }) => {
      const [isDragActive, setIsDragActive] = useState(false)
      const [uploadQueue, setUploadQueue] = useState<FileUpload[]>([])
      const fileInputRef = useRef<HTMLInputElement>(null)
      
      const handleDrop = useCallback((event: React.DragEvent) => {
        event.preventDefault()
        setIsDragActive(false)
        
        const files = Array.from(event.dataTransfer.files)
        validateAndAddFiles(files)
      }, [])
      
      const validateAndAddFiles = (files: File[]) => {
        const validFiles: File[] = []
        
        for (const file of files) {
          // 파일 타입 검증
          if (!acceptedTypes.some(type => {
            if (type.endsWith('/*')) {
              return file.type.startsWith(type.replace('/*', '/'))
            }
            return file.type === type
          })) {
            onError({
              type: 'INVALID_TYPE',
              message: `${file.name}은 지원하지 않는 파일 형식입니다.`,
              fileName: file.name
            })
            continue
          }
          
          // 파일 크기 검증
          if (file.size > 10 * 1024 * 1024) { // 10MB per file
            onError({
              type: 'FILE_TOO_LARGE',
              message: `${file.name}이 너무 큽니다. (최대 10MB)`,
              fileName: file.name
            })
            continue
          }
          
          validFiles.push(file)
        }
        
        // 총 파일 수 검증
        if (uploadQueue.length + validFiles.length > maxFiles) {
          onError({
            type: 'TOO_MANY_FILES',
            message: `최대 ${maxFiles}개 파일만 첨부할 수 있습니다.`
          })
          return
        }
        
        // 총 파일 크기 검증
        const totalSize = [...uploadQueue, ...validFiles]
          .reduce((sum, item) => sum + ('size' in item ? item.size : item.file.size), 0)
        
        if (totalSize > maxTotalSize) {
          onError({
            type: 'TOTAL_SIZE_EXCEEDED',
            message: `총 파일 크기가 ${formatFileSize(maxTotalSize)}를 초과했습니다.`
          })
          return
        }
        
        onFilesAdded(validFiles)
      }
      
      return (
        <div
          className={cn(
            "border-2 border-dashed rounded-lg p-8 text-center transition-colors",
            isDragActive 
              ? "border-primary bg-primary/5" 
              : "border-muted-foreground/25 hover:border-muted-foreground/50"
          )}
          onDrop={handleDrop}
          onDragOver={(e) => { e.preventDefault(); setIsDragActive(true) }}
          onDragLeave={() => setIsDragActive(false)}
          role="button"
          tabIndex={0}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault()
              fileInputRef.current?.click()
            }
          }}
          aria-label="파일 업로드 영역. 파일을 드래그하거나 클릭하여 선택하세요."
        >
          <Upload className="mx-auto h-12 w-12 text-muted-foreground mb-4" />
          <h3 className="text-lg font-semibold mb-2">
            파일을 드래그하거나 클릭하여 업로드
          </h3>
          <p className="text-sm text-muted-foreground mb-4">
            최대 {maxFiles}개, 총 {formatFileSize(maxTotalSize)}까지
          </p>
          <Button
            variant="outline"
            onClick={() => fileInputRef.current?.click()}
            className="mb-2"
          >
            파일 선택
          </Button>
          <p className="text-xs text-muted-foreground">
            지원 형식: 이미지, PDF, MS Office, 텍스트
          </p>
          
          <input
            ref={fileInputRef}
            type="file"
            multiple
            accept={acceptedTypes.join(',')}
            onChange={(e) => {
              if (e.target.files) {
                validateAndAddFiles(Array.from(e.target.files))
              }
            }}
            className="hidden"
            aria-hidden="true"
          />
        </div>
      )
    }
    ```
  - [ ] 파일 타입 아이콘 매핑 시스템
  - [ ] 접근성 키보드 탐색 구현
  - [ ] 에러 메시지 다국어 지원

- [ ] **2단계: 업로드 진행률 및 큐 관리** (AC: 5)
  - [ ] FileUploadProgress.tsx 구현
    ```tsx
    interface FileUpload {
      id: string
      file: File
      progress: number
      status: 'pending' | 'uploading' | 'completed' | 'error'
      error?: string
      cancelToken?: CancelTokenSource
    }
    
    const FileUploadProgress: React.FC<Props> = ({ uploads, onCancel, onRetry }) => {
      return (
        <Card className="p-4">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-sm font-medium">파일 업로드</h3>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onCancel(uploads.filter(u => u.status === 'uploading'))}
              disabled={!uploads.some(u => u.status === 'uploading')}
            >
              모두 취소
            </Button>
          </div>
          
          <div className="space-y-3">
            {uploads.map((upload) => (
              <div key={upload.id} className="space-y-2">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2 flex-1 min-w-0">
                    <FileIcon type={upload.file.type} className="h-4 w-4 flex-shrink-0" />
                    <span className="text-sm truncate" title={upload.file.name}>
                      {upload.file.name}
                    </span>
                    <span className="text-xs text-muted-foreground flex-shrink-0">
                      {formatFileSize(upload.file.size)}
                    </span>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    {upload.status === 'uploading' && (
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => onCancel([upload])}
                        aria-label={`${upload.file.name} 업로드 취소`}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    )}
                    
                    {upload.status === 'error' && (
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => onRetry(upload)}
                        aria-label={`${upload.file.name} 재시도`}
                      >
                        <RotateCcw className="h-4 w-4" />
                      </Button>
                    )}
                    
                    {upload.status === 'completed' && (
                      <CheckCircle className="h-4 w-4 text-green-500" />
                    )}
                    
                    {upload.status === 'error' && (
                      <AlertCircle className="h-4 w-4 text-red-500" />
                    )}
                  </div>
                </div>
                
                <div className="space-y-1">
                  <Progress value={upload.progress} className="h-2" />
                  <div className="flex justify-between text-xs text-muted-foreground">
                    <span>
                      {upload.status === 'error' 
                        ? upload.error 
                        : `${Math.round(upload.progress)}%`
                      }
                    </span>
                    {upload.status === 'uploading' && (
                      <span>{upload.progress}% 완료</span>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </Card>
      )
    }
    ```
  - [ ] 청크 업로드로 대용량 파일 처리
  - [ ] 업로드 재시도 메커니즘
  - [ ] 업로드 취소 및 정리 로직

- [ ] **3단계: 파일 미리보기 시스템** (AC: 4)
  - [ ] FilePreview.tsx 구현
    ```tsx
    const FilePreview: React.FC<{ file: AttachedFile }> = ({ file }) => {
      const [previewData, setPreviewData] = useState<string | null>(null)
      const [isLoading, setIsLoading] = useState(false)
      
      const isImage = file.mimeType.startsWith('image/')
      const isPDF = file.mimeType === 'application/pdf'
      const isPreviewable = isImage || isPDF
      
      const loadPreview = async () => {
        if (!isPreviewable || previewData) return
        
        setIsLoading(true)
        try {
          if (isImage) {
            setPreviewData(file.url)
          } else if (isPDF) {
            // PDF 첫 페이지 썸네일 생성
            const thumbnail = await generatePDFThumbnail(file.url)
            setPreviewData(thumbnail)
          }
        } catch (error) {
          console.error('미리보기 생성 실패:', error)
        } finally {
          setIsLoading(false)
        }
      }
      
      useEffect(() => {
        loadPreview()
      }, [file.url])
      
      return (
        <div className="border rounded-lg p-4">
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0">
              {isPreviewable ? (
                <div className="w-16 h-16 bg-muted rounded overflow-hidden">
                  {isLoading ? (
                    <div className="flex items-center justify-center h-full">
                      <Loader2 className="h-4 w-4 animate-spin" />
                    </div>
                  ) : previewData ? (
                    <img
                      src={previewData}
                      alt={file.name}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="flex items-center justify-center h-full">
                      <FileIcon type={file.mimeType} className="h-6 w-6" />
                    </div>
                  )}
                </div>
              ) : (
                <div className="w-16 h-16 bg-muted rounded flex items-center justify-center">
                  <FileIcon type={file.mimeType} className="h-6 w-6" />
                </div>
              )}
            </div>
            
            <div className="flex-1 min-w-0">
              <h4 className="text-sm font-medium truncate" title={file.name}>
                {file.name}
              </h4>
              <p className="text-xs text-muted-foreground">
                {formatFileSize(file.size)} • {formatDate(file.uploadedAt)}
              </p>
              
              <div className="flex gap-2 mt-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => window.open(file.url, '_blank')}
                >
                  <Eye className="h-3 w-3 mr-1" />
                  미리보기
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => downloadFile(file)}
                >
                  <Download className="h-3 w-3 mr-1" />
                  다운로드
                </Button>
              </div>
            </div>
            
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm">
                  <MoreVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => window.open(file.url)}>
                  새 창에서 열기
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => copyToClipboard(file.url)}>
                  링크 복사
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem 
                  onClick={() => onDelete(file.id)}
                  className="text-red-600"
                >
                  삭제
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      )
    }
    ```
  - [ ] PDF 썸네일 생성 (PDF.js 활용)
  - [ ] 이미지 최적화 및 리사이징
  - [ ] Lazy loading으로 성능 최적화

- [ ] **4단계: 파일 보안 및 검증** (AC: 7)
  - [ ] 클라이언트 측 파일 검증 시스템
    ```tsx
    export class FileSecurityValidator {
      private static readonly ALLOWED_EXTENSIONS = [
        '.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg',
        '.pdf',
        '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
        '.txt', '.rtf', '.csv'
      ]
      
      private static readonly MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB
      private static readonly SUSPICIOUS_PATTERNS = [
        /\.exe$/i, /\.bat$/i, /\.cmd$/i, /\.scr$/i, /\.pif$/i,
        /\.vbs$/i, /\.js$/i, /\.jar$/i, /\.com$/i
      ]
      
      static async validateFile(file: File): Promise<ValidationResult> {
        const result: ValidationResult = {
          isValid: true,
          errors: [],
          warnings: []
        }
        
        // 확장자 검증
        const extension = this.getFileExtension(file.name)
        if (!this.ALLOWED_EXTENSIONS.includes(extension.toLowerCase())) {
          result.isValid = false
          result.errors.push(`허용되지 않는 파일 형식입니다: ${extension}`)
        }
        
        // 악의적 파일명 패턴 검사
        if (this.SUSPICIOUS_PATTERNS.some(pattern => pattern.test(file.name))) {
          result.isValid = false
          result.errors.push('의심스러운 파일명 패턴이 감지되었습니다.')
        }
        
        // MIME 타입과 확장자 일치성 검증
        const expectedMimeType = this.getMimeTypeByExtension(extension)
        if (expectedMimeType && !file.type.startsWith(expectedMimeType)) {
          result.warnings.push('파일 확장자와 타입이 일치하지 않습니다.')
        }
        
        // 파일 크기 검증
        if (file.size > this.MAX_FILE_SIZE) {
          result.isValid = false
          result.errors.push(`파일 크기가 너무 큽니다. (최대 ${formatFileSize(this.MAX_FILE_SIZE)})`)
        }
        
        // 파일 시그니처 검증 (매직 넘버)
        try {
          const signature = await this.getFileSignature(file)
          if (!this.verifyFileSignature(signature, file.type)) {
            result.warnings.push('파일 시그니처가 예상과 다릅니다.')
          }
        } catch (error) {
          result.warnings.push('파일 시그니처를 확인할 수 없습니다.')
        }
        
        return result
      }
      
      private static async getFileSignature(file: File): Promise<Uint8Array> {
        const slice = file.slice(0, 8)
        const buffer = await slice.arrayBuffer()
        return new Uint8Array(buffer)
      }
      
      private static verifyFileSignature(signature: Uint8Array, mimeType: string): boolean {
        const hex = Array.from(signature).map(b => b.toString(16).padStart(2, '0')).join('')
        
        const signatures: Record<string, string[]> = {
          'image/jpeg': ['ffd8ff'],
          'image/png': ['89504e47'],
          'application/pdf': ['25504446'],
          'application/zip': ['504b0304', '504b0506', '504b0708'],
          // Office documents (ZIP-based)
          'application/vnd.openxmlformats': ['504b0304']
        }
        
        const expectedSignatures = signatures[mimeType.split('/')[0] + '/' + mimeType.split('/')[1]] ||
                                   signatures[mimeType.split('/')[0] + '/*'] ||
                                   []
        
        return expectedSignatures.some(sig => hex.startsWith(sig))
      }
    }
    ```
  - [ ] 서버 측 파일 스캔 API 연동
  - [ ] 파일 격리 및 안전한 저장소 구현
  - [ ] 악성코드 검사 결과 처리

- [ ] **5단계: 파일 관리 인터페이스** (AC: 6)
  - [ ] AttachmentManager.tsx 구현
    ```tsx
    const AttachmentManager: React.FC<Props> = ({ 
      eventId, 
      attachments, 
      onUpload, 
      onDelete 
    }) => {
      const [isUploading, setIsUploading] = useState(false)
      const [uploadQueue, setUploadQueue] = useState<FileUpload[]>([])
      
      const handleFilesAdded = async (files: File[]) => {
        const uploads: FileUpload[] = files.map(file => ({
          id: generateId(),
          file,
          progress: 0,
          status: 'pending'
        }))
        
        setUploadQueue(prev => [...prev, ...uploads])
        setIsUploading(true)
        
        try {
          await Promise.all(uploads.map(upload => uploadFile(upload)))
        } finally {
          setIsUploading(false)
        }
      }
      
      const uploadFile = async (upload: FileUpload) => {
        const formData = new FormData()
        formData.append('file', upload.file)
        formData.append('eventId', eventId)
        
        const cancelToken = axios.CancelToken.source()
        
        setUploadQueue(prev => 
          prev.map(u => u.id === upload.id 
            ? { ...u, status: 'uploading', cancelToken }
            : u
          )
        )
        
        try {
          const response = await filesApi.uploadFile(formData, {
            cancelToken: cancelToken.token,
            onUploadProgress: (progressEvent) => {
              const progress = Math.round(
                (progressEvent.loaded * 100) / progressEvent.total!
              )
              
              setUploadQueue(prev =>
                prev.map(u => u.id === upload.id ? { ...u, progress } : u)
              )
            }
          })
          
          setUploadQueue(prev =>
            prev.map(u => u.id === upload.id 
              ? { ...u, status: 'completed', progress: 100 }
              : u
            )
          )
          
          onUpload(response.data)
          
          // 완료된 항목 3초 후 제거
          setTimeout(() => {
            setUploadQueue(prev => prev.filter(u => u.id !== upload.id))
          }, 3000)
          
        } catch (error) {
          if (axios.isCancel(error)) {
            setUploadQueue(prev => prev.filter(u => u.id !== upload.id))
          } else {
            setUploadQueue(prev =>
              prev.map(u => u.id === upload.id 
                ? { ...u, status: 'error', error: getErrorMessage(error) }
                : u
              )
            )
          }
        }
      }
      
      return (
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="text-sm font-medium">첨부파일</h3>
            <Badge variant="secondary">
              {attachments.length}/{10}
            </Badge>
          </div>
          
          {/* 기존 첨부파일 목록 */}
          {attachments.length > 0 && (
            <div className="space-y-2">
              {attachments.map(file => (
                <FilePreview
                  key={file.id}
                  file={file}
                  onDelete={onDelete}
                />
              ))}
            </div>
          )}
          
          {/* 업로드 진행률 */}
          {uploadQueue.length > 0 && (
            <FileUploadProgress
              uploads={uploadQueue}
              onCancel={handleCancelUpload}
              onRetry={handleRetryUpload}
            />
          )}
          
          {/* 파일 업로드 영역 */}
          {attachments.length < 10 && !isUploading && (
            <FileUploadZone
              maxFiles={10 - attachments.length}
              onFilesAdded={handleFilesAdded}
              onError={handleUploadError}
            />
          )}
        </div>
      )
    }
    ```
  - [ ] 파일 정렬 및 필터링 기능
  - [ ] 대량 파일 다운로드 (ZIP 압축)
  - [ ] 파일 메타데이터 편집 기능

- [ ] **6단계: REST API 연동** (AC: 1-7)
  - [ ] 파일 관리 API 엔드포인트 연동
    ```tsx
    export class FilesApi extends ApiClient {
      async uploadFile(
        formData: FormData, 
        config?: { 
          onUploadProgress?: (progress: ProgressEvent) => void
          cancelToken?: CancelToken 
        }
      ): Promise<AttachedFile> {
        const response = await this.client.post<AttachedFile>('/files/upload', formData, {
          headers: {
            'Content-Type': 'multipart/form-data'
          },
          timeout: 300000, // 5분
          ...config
        })
        return response.data
      }
      
      async attachFileToEvent(eventId: string, fileId: string): Promise<void> {
        await this.client.post(`/events/${eventId}/attachments`, { fileId })
      }
      
      async getEventAttachments(eventId: string): Promise<AttachedFile[]> {
        const response = await this.client.get<AttachedFile[]>(`/events/${eventId}/attachments`)
        return response.data
      }
      
      async deleteAttachment(eventId: string, fileId: string): Promise<void> {
        await this.client.delete(`/events/${eventId}/attachments/${fileId}`)
      }
      
      async downloadFile(fileId: string): Promise<Blob> {
        const response = await this.client.get(`/files/${fileId}/download`, {
          responseType: 'blob'
        })
        return response.data
      }
      
      async generateDownloadUrl(fileId: string, expiresIn?: number): Promise<string> {
        const response = await this.client.post<{ url: string }>(`/files/${fileId}/download-url`, {
          expiresIn: expiresIn || 3600 // 1시간
        })
        return response.data.url
      }
      
      async scanFile(fileId: string): Promise<FileScanResult> {
        const response = await this.client.post<FileScanResult>(`/files/${fileId}/scan`)
        return response.data
      }
    }
    ```
  - [ ] 청크 업로드 재시도 로직
  - [ ] 파일 메타데이터 캐싱
  - [ ] 업로드 실패 시 정리 작업

- [ ] **7단계: 상태 관리 통합** (AC: 6)
  - [ ] Zustand 스토어에 파일 상태 추가
    ```tsx
    interface FileStore {
      attachments: Map<string, AttachedFile[]> // eventId -> files
      uploadQueue: FileUpload[]
      
      // Actions
      setEventAttachments: (eventId: string, files: AttachedFile[]) => void
      addAttachment: (eventId: string, file: AttachedFile) => void
      removeAttachment: (eventId: string, fileId: string) => void
      updateUploadProgress: (uploadId: string, progress: number) => void
      
      // Selectors
      getEventAttachments: (eventId: string) => AttachedFile[]
      getTotalAttachmentSize: (eventId: string) => number
      getAttachmentCount: (eventId: string) => number
    }
    
    export const useFileStore = create<FileStore>((set, get) => ({
      attachments: new Map(),
      uploadQueue: [],
      
      setEventAttachments: (eventId, files) => set((state) => {
        const newMap = new Map(state.attachments)
        newMap.set(eventId, files)
        return { attachments: newMap }
      }),
      
      addAttachment: (eventId, file) => set((state) => {
        const newMap = new Map(state.attachments)
        const existing = newMap.get(eventId) || []
        newMap.set(eventId, [...existing, file])
        return { attachments: newMap }
      }),
      
      removeAttachment: (eventId, fileId) => set((state) => {
        const newMap = new Map(state.attachments)
        const existing = newMap.get(eventId) || []
        newMap.set(eventId, existing.filter(f => f.id !== fileId))
        return { attachments: newMap }
      }),
      
      getEventAttachments: (eventId) => {
        return get().attachments.get(eventId) || []
      },
      
      getTotalAttachmentSize: (eventId) => {
        const files = get().attachments.get(eventId) || []
        return files.reduce((total, file) => total + file.size, 0)
      }
    }))
    ```
  - [ ] TanStack Query를 통한 파일 메타데이터 캐싱
  - [ ] 낙관적 업데이트 구현
  - [ ] 오프라인 업로드 대기열 관리

## Dev Notes

### 파일 보안 모범 사례
**[Source: docs/ui-architecture/10-security-best-practices.md]**
- **클라이언트 검증**: 1차 필터링, 사용자 경험 개선
- **서버 검증**: 최종 보안 검증, 악성코드 스캔
- **파일 격리**: 업로드된 파일을 안전한 격리 영역에 저장
- **액세스 제어**: 권한 기반 파일 접근 제어

### 성능 최적화 전략
**[Source: docs/ui-architecture/08-runtime-performance.md]**
- **청크 업로드**: 1MB 단위로 분할하여 안정성 확보
- **병렬 업로드**: 최대 3개 파일 동시 업로드
- **압축**: 이미지 자동 최적화 및 압축
- **CDN 활용**: 정적 파일 전용 CDN 서비스 활용

### 접근성 구현 세부사항
**[Source: docs/ui-architecture/11-accessibility-implementation.md]**
- **키보드 탐색**: Tab으로 업로드 영역 포커스, Enter/Space로 파일 선택
- **스크린 리더**: 파일 업로드 진행률, 첨부파일 목록 음성 안내
- **ARIA 라벨**: 업로드 영역, 진행률 표시기 적절한 라벨링
- **고대비 모드**: 진행률 표시기 색상 대비 강화

---

*이 스토리는 안전하고 사용자 친화적인 파일 첨부 시스템을 제공합니다. 보안을 우선시하면서도 직관적인 드래그 앤 드롭 인터페이스를 통해 뛰어난 사용자 경험을 보장합니다.*