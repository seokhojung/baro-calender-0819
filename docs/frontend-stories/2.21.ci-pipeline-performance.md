# 🚀 Story 2.21: CI/CD 파이프라인 및 성능 게이트 구현

## 📋 Story 정보
- **Story 버전**: 1.0
- **작성일**: 2025-08-19
- **작성자**: Frontend Development Team
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **Sprint**: Frontend Implementation - Phase 17
- **Story Point**: 13
- **우선순위**: High
- **관련 UI 아키텍처 문서**: `22-ci-pipeline-performance.md`

---

## 🎯 Story 개요

바로캘린더의 **완전한 CI/CD 파이프라인 및 성능 게이트 시스템**을 구현하여 자동화된 품질 검증, 성능 모니터링, 그리고 안정적인 배포 프로세스를 제공합니다.

---

## 🎬 사용자 스토리

### 📝 주요 사용자 스토리

**As a** 바로캘린더 개발팀 리드  
**I want** 자동화된 CI/CD 파이프라인으로 코드 품질과 성능을 보장하고 싶어  
**So that** 안정적인 제품 배포와 지속적인 품질 개선이 가능해

### 🔍 상세 사용자 요구사항

1. **자동화된 품질 검증**
   - 코드 린팅, 타입 체크, 단위 테스트 자동 실행
   - 테스트 커버리지 임계값 검증
   - 접근성 테스트 자동화

2. **성능 게이트 시스템**
   - Core Web Vitals 자동 측정 및 임계값 검증
   - Lighthouse CI 통합 성능 테스트
   - 번들 크기 모니터링 및 제한

3. **스마트 배포 프로세스**
   - 품질 및 성능 기준 통과 시 자동 배포
   - 스테이징 환경 검증 후 프로덕션 배포
   - 롤백 시나리오 자동화

---

## ⚙️ 기술적 요구사항

### 🏗️ 아키텍처 요구사항

1. **GitHub Actions 기반 CI/CD**
   ```typescript
   - 병렬 작업 실행으로 빌드 시간 최적화
   - 단계별 게이트 검증 (품질 → 성능 → E2E)
   - 환경별 배포 전략 (staging → production)
   ```

2. **성능 모니터링 통합**
   ```typescript
   - Lighthouse CI 자동 성능 측정
   - Core Web Vitals 임계값 검증
   - 번들 사이즈 추적 및 알림
   ```

3. **품질 게이트 시스템**
   ```typescript
   - ESLint/Prettier 코드 품질 검증
   - TypeScript 타입 안전성 체크
   - Jest 단위 테스트 80% 커버리지
   - Playwright E2E 테스트 자동화
   ```

---

## 🛠️ 구현 상세

### 1️⃣ 완전한 GitHub Actions CI/CD 파이프라인

```yaml
# .github/workflows/ci-cd.yml
name: 바로캘린더 CI/CD Pipeline

on:
  push:
    branches: [ main, develop, 'feature/**', 'hotfix/**' ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # 매일 새벽 2시에 성능 체크 실행
    - cron: '0 2 * * *'

env:
  NODE_VERSION: '20.x'
  CACHE_VERSION: v1

jobs:
  # 1단계: 기본 품질 검증
  quality-gate:
    name: 품질 게이트
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    strategy:
      matrix:
        check: [lint, type-check, test-unit, test-a11y]
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: package-lock.json
      
      - name: 종속성 설치
        run: |
          npm ci --prefer-offline --no-audit
          npm ls --depth=0
      
      - name: 캐시 복원
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            .next/cache
            node_modules/.cache
          key: ${{ runner.os }}-deps-${{ env.CACHE_VERSION }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-${{ env.CACHE_VERSION }}-
      
      # 병렬 품질 검증 작업
      - name: ESLint 검사
        if: matrix.check == 'lint'
        run: |
          npm run lint
          npm run lint:report || true
      
      - name: TypeScript 타입 검사
        if: matrix.check == 'type-check'
        run: |
          npm run type-check
          echo "TypeScript validation passed ✅"
      
      - name: 단위 테스트 실행
        if: matrix.check == 'test-unit'
        run: |
          npm run test:unit -- --coverage --watchAll=false --maxWorkers=2
          echo "Unit tests completed ✅"
      
      - name: 접근성 테스트 실행
        if: matrix.check == 'test-a11y'
        run: |
          npm run test:a11y
          echo "Accessibility tests completed ✅"
      
      - name: 테스트 커버리지 검증
        if: matrix.check == 'test-unit'
        run: |
          COVERAGE=$(npm run test:coverage:check --silent | grep -o '[0-9.]*' | head -1)
          echo "Current coverage: ${COVERAGE}%"
          if (( $(echo "${COVERAGE} < 80" | bc -l) )); then
            echo "❌ Test coverage ${COVERAGE}% is below 80% threshold"
            exit 1
          fi
          echo "✅ Test coverage ${COVERAGE}% meets threshold"
      
      - name: 커버리지 리포트 업로드
        if: matrix.check == 'test-unit'
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-baro-calendar
          fail_ci_if_error: false

  # 2단계: 빌드 및 성능 검증
  performance-gate:
    name: 성능 게이트
    runs-on: ubuntu-latest
    needs: quality-gate
    timeout-minutes: 20
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
      
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: 종속성 설치
        run: npm ci --prefer-offline --no-audit
      
      - name: 환경 변수 설정
        run: |
          echo "NEXT_PUBLIC_APP_ENV=ci" >> $GITHUB_ENV
          echo "ANALYZE=true" >> $GITHUB_ENV
      
      - name: 프로덕션 빌드
        run: |
          npm run build
          echo "Build completed successfully ✅"
      
      - name: 번들 크기 분석
        run: |
          npm run build:analyze
          BUNDLE_SIZE=$(du -sh .next/static/chunks/pages/_app*.js | cut -f1)
          echo "App bundle size: $BUNDLE_SIZE"
          
          # 번들 크기 임계값 검사 (예: 250KB)
          SIZE_BYTES=$(du -b .next/static/chunks/pages/_app*.js | cut -f1)
          SIZE_KB=$(($SIZE_BYTES / 1024))
          if [ $SIZE_KB -gt 250 ]; then
            echo "❌ Bundle size ${SIZE_KB}KB exceeds 250KB limit"
            exit 1
          fi
          echo "✅ Bundle size ${SIZE_KB}KB is within limits"
      
      - name: Lighthouse CI 성능 테스트
        run: |
          npm run lighthouse:ci
          echo "Lighthouse performance tests completed ✅"
      
      - name: Core Web Vitals 검증
        run: |
          if [ -f "lighthouseci/lhr.json" ]; then
            LCP=$(jq -r '.lighthouseResult.audits."largest-contentful-paint".numericValue' lighthouseci/lhr.json)
            FID=$(jq -r '.lighthouseResult.audits."max-potential-fid".numericValue' lighthouseci/lhr.json)
            CLS=$(jq -r '.lighthouseResult.audits."cumulative-layout-shift".numericValue' lighthouseci/lhr.json)
            
            echo "Performance Metrics:"
            echo "LCP: ${LCP}ms"
            echo "FID: ${FID}ms" 
            echo "CLS: ${CLS}"
            
            # 임계값 검증
            if (( $(echo "$LCP > 2500" | bc -l) )); then
              echo "❌ LCP ${LCP}ms exceeds 2500ms threshold"
              exit 1
            fi
            
            if (( $(echo "$FID > 100" | bc -l) )); then
              echo "❌ FID ${FID}ms exceeds 100ms threshold"  
              exit 1
            fi
            
            if (( $(echo "$CLS > 0.1" | bc -l) )); then
              echo "❌ CLS ${CLS} exceeds 0.1 threshold"
              exit 1
            fi
            
            echo "✅ All Core Web Vitals within thresholds"
          fi
      
      - name: 성능 리포트 업로드
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: performance-reports
          path: |
            lighthouseci/
            webpack-bundle-analyzer-report.html
          retention-days: 30

  # 3단계: 통합 테스트
  integration-tests:
    name: 통합 테스트
    runs-on: ubuntu-latest
    needs: [quality-gate, performance-gate]
    timeout-minutes: 25
    
    strategy:
      matrix:
        browser: [chromium, firefox, webkit]
        shard: [1, 2, 3]
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
      
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: 종속성 설치
        run: npm ci --prefer-offline --no-audit
      
      - name: Playwright 브라우저 설치
        run: npx playwright install --with-deps ${{ matrix.browser }}
      
      - name: E2E 테스트 실행
        run: |
          npm run test:e2e -- --project=${{ matrix.browser }} --shard=${{ matrix.shard }}/3
        env:
          CI: true
          PLAYWRIGHT_JUNIT_OUTPUT_NAME: results-${{ matrix.browser }}-${{ matrix.shard }}.xml
      
      - name: 테스트 결과 업로드
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-results-${{ matrix.browser }}-${{ matrix.shard }}
          path: |
            test-results/
            playwright-report/
          retention-days: 30
      
      - name: 테스트 스크린샷 업로드
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: screenshots-${{ matrix.browser }}-${{ matrix.shard }}
          path: test-results/
          retention-days: 7

  # 4단계: 보안 검사
  security-scan:
    name: 보안 검사
    runs-on: ubuntu-latest
    needs: quality-gate
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
      
      - name: Node.js 보안 취약점 검사
        run: |
          npm audit --audit-level=high
          echo "Security audit completed ✅"
      
      - name: SAST 코드 스캔
        uses: github/codeql-action/init@v3
        with:
          languages: javascript,typescript
      
      - name: CodeQL 분석 실행
        uses: github/codeql-action/analyze@v3

  # 5단계: 스테이징 배포
  deploy-staging:
    name: 스테이징 배포
    runs-on: ubuntu-latest
    needs: [performance-gate, integration-tests, security-scan]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.baro-calendar.com
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
      
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: 종속성 설치 및 빌드
        run: |
          npm ci --prefer-offline --no-audit
          npm run build
        env:
          NEXT_PUBLIC_APP_ENV: staging
      
      - name: 스테이징 배포
        run: |
          echo "Deploying to staging environment..."
          # 실제 배포 스크립트 (예: Vercel, AWS, etc.)
          npm run deploy:staging
      
      - name: 스테이징 헬스 체크
        run: |
          sleep 30
          curl -f https://staging.baro-calendar.com/api/health || exit 1
          echo "Staging deployment successful ✅"
      
      - name: Slack 알림
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployment'
          text: |
            스테이징 배포 ${{ job.status }}: 
            - 커밋: ${{ github.sha }}
            - 브랜치: ${{ github.ref_name }}
            - 배포자: ${{ github.actor }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # 6단계: 프로덕션 배포
  deploy-production:
    name: 프로덕션 배포
    runs-on: ubuntu-latest
    needs: [performance-gate, integration-tests, security-scan]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://baro-calendar.com
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
      
      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: 종속성 설치 및 빌드
        run: |
          npm ci --prefer-offline --no-audit
          npm run build
        env:
          NEXT_PUBLIC_APP_ENV: production
      
      - name: 프로덕션 배포
        run: |
          echo "Deploying to production environment..."
          npm run deploy:production
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
      
      - name: 프로덕션 헬스 체크
        run: |
          sleep 60
          curl -f https://baro-calendar.com/api/health || exit 1
          echo "Production deployment successful ✅"
      
      - name: 성공 알림
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#general'
          text: |
            🎉 프로덕션 배포 성공!
            - 버전: ${{ github.sha }}
            - 배포 시간: $(date)
            - 배포자: ${{ github.actor }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # 7단계: 배포 후 검증
  post-deploy-validation:
    name: 배포 후 검증
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
      
      - name: 종속성 설치
        run: npm ci --prefer-offline --no-audit
      
      - name: 프로덕션 스모크 테스트
        run: |
          npm run test:smoke:production
          echo "Production smoke tests passed ✅"
      
      - name: 실시간 성능 모니터링
        run: |
          npm run monitor:performance:production
          echo "Performance monitoring initiated ✅"
      
      - name: 에러 추적 초기화
        run: |
          curl -X POST "https://api.sentry.io/api/0/projects/baro-calendar/releases/" \
            -H "Authorization: Bearer ${{ secrets.SENTRY_AUTH_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"version\": \"${{ github.sha }}\", \"projects\": [\"baro-calendar\"]}"
```

### 2️⃣ 고급 Lighthouse CI 성능 설정

```javascript
// .lighthouserc.js
const { PERFORMANCE_GATES } = require('./src/lib/performance/gates')

module.exports = {
  ci: {
    collect: {
      url: [
        'http://localhost:3000',
        'http://localhost:3000/app/calendar',
        'http://localhost:3000/app/projects',
        'http://localhost:3000/app/settings',
      ],
      startServerCommand: 'npm run start',
      startServerReadyPattern: 'ready on',
      startServerReadyTimeout: 60000,
      numberOfRuns: 3,
      settings: {
        preset: 'desktop',
        chromeFlags: '--no-sandbox --disable-dev-shm-usage --disable-gpu',
        emulatedFormFactor: 'desktop',
        throttling: {
          rttMs: 40,
          throughputKbps: 10240,
          cpuSlowdownMultiplier: 1,
          requestLatencyMs: 0,
          downloadThroughputKbps: 0,
          uploadThroughputKbps: 0,
        },
      },
    },
    assert: {
      assertions: {
        // 성능 카테고리
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.95 }],
        'categories:best-practices': ['error', { minScore: 0.95 }],
        'categories:seo': ['error', { minScore: 0.9 }],
        
        // Core Web Vitals
        'largest-contentful-paint': ['error', { maxNumericValue: PERFORMANCE_GATES.lcp }],
        'first-input-delay': ['error', { maxNumericValue: PERFORMANCE_GATES.fid }],
        'cumulative-layout-shift': ['error', { maxNumericValue: PERFORMANCE_GATES.cls }],
        
        // 추가 성능 지표
        'first-contentful-paint': ['error', { maxNumericValue: 1800 }],
        'speed-index': ['error', { maxNumericValue: 3000 }],
        'time-to-interactive': ['error', { maxNumericValue: 3800 }],
        'total-blocking-time': ['error', { maxNumericValue: 200 }],
        
        // 리소스 관련
        'unused-css-rules': ['warn', { maxNumericValue: 20 }],
        'unused-javascript': ['warn', { maxNumericValue: 20 }],
        'modern-image-formats': ['error', { minScore: 0.8 }],
        'uses-text-compression': ['error', { minScore: 0.9 }],
        
        // 바로캘린더 특화 검사
        'dom-size': ['error', { maxNumericValue: 1500 }],
        'main-thread-tasks': ['warn', { maxNumericValue: 50 }],
        'bootup-time': ['error', { maxNumericValue: 2000 }],
      },
    },
    upload: {
      target: 'temporary-public-storage',
      githubAppToken: process.env.LHCI_GITHUB_APP_TOKEN,
      githubToken: process.env.GITHUB_TOKEN,
    },
  },
}
```

### 3️⃣ 성능 게이트 및 모니터링 시스템

```typescript
// src/lib/performance/performance-gates.ts
export const PERFORMANCE_GATES = {
  // Core Web Vitals 임계값
  lcp: 2500,    // Largest Contentful Paint (ms)
  fid: 100,     // First Input Delay (ms)  
  cls: 0.1,     // Cumulative Layout Shift
  
  // 추가 성능 지표
  fcp: 1800,    // First Contentful Paint (ms)
  si: 3000,     // Speed Index (ms)
  tti: 3800,    // Time to Interactive (ms)
  tbt: 200,     // Total Blocking Time (ms)
  
  // 바로캘린더 특화 지표
  calendarRender: 1000,    // 캘린더 렌더링 시간 (ms)
  eventLoading: 500,       // 이벤트 로딩 시간 (ms)
  projectSwitch: 300,      // 프로젝트 전환 시간 (ms)
  searchResponse: 200,     // 검색 응답 시간 (ms)
  
  // 번들 및 리소스
  bundleSize: 250,         // 메인 번들 크기 (KB)
  totalBundleSize: 1000,   // 전체 번들 크기 (KB)
  imageOptimization: 0.8,  // 이미지 최적화 점수
  
  // 테스트 품질
  testCoverage: 80,        // 테스트 커버리지 (%)
  e2ePassRate: 95,         // E2E 테스트 통과율 (%)
} as const

export type PerformanceMetric = keyof typeof PERFORMANCE_GATES

export interface PerformanceResult {
  metric: PerformanceMetric
  value: number
  threshold: number
  passed: boolean
  difference: number
  timestamp: Date
}

export class PerformanceGateValidator {
  private results: PerformanceResult[] = []
  
  validateMetric(
    metric: PerformanceMetric,
    value: number
  ): PerformanceResult {
    const threshold = PERFORMANCE_GATES[metric]
    const passed = value <= threshold
    const difference = value - threshold
    
    const result: PerformanceResult = {
      metric,
      value,
      threshold,
      passed,
      difference,
      timestamp: new Date(),
    }
    
    this.results.push(result)
    
    if (!passed) {
      this.handleFailure(result)
    }
    
    return result
  }
  
  private handleFailure(result: PerformanceResult) {
    const { metric, value, threshold, difference } = result
    
    console.error(`❌ Performance Gate Failed: ${metric}`)
    console.error(`   Current: ${value}`)
    console.error(`   Threshold: ${threshold}`)
    console.error(`   Exceeded by: ${difference}`)
    
    // CI 환경에서 실패 처리
    if (process.env.CI) {
      this.sendCIAlert(result)
      process.exit(1)
    }
    
    // 개발 환경에서 경고
    this.sendDevelopmentWarning(result)
  }
  
  private sendCIAlert(result: PerformanceResult) {
    // GitHub Issues 자동 생성
    this.createPerformanceIssue(result)
    
    // Slack 알림
    this.sendSlackAlert(result)
    
    // Sentry 이벤트
    this.sendSentryEvent(result)
  }
  
  private sendDevelopmentWarning(result: PerformanceResult) {
    // 브라우저 알림
    if (typeof window !== 'undefined') {
      console.warn(
        `🚨 Performance Warning: ${result.metric} exceeded threshold`,
        result
      )
    }
  }
  
  private createPerformanceIssue(result: PerformanceResult) {
    // GitHub API를 통한 이슈 생성 로직
    const issueBody = `
## 🚨 Performance Gate Failure

**Metric**: ${result.metric}  
**Current Value**: ${result.value}  
**Threshold**: ${result.threshold}  
**Exceeded By**: ${result.difference}  
**Timestamp**: ${result.timestamp.toISOString()}  

### Recommended Actions:
${this.getRecommendations(result.metric)}

### Related Links:
- [Performance Dashboard](https://monitoring.baro-calendar.com)
- [Bundle Analysis](https://bundleanalyzer.baro-calendar.com)
    `
    
    // GitHub Issues API 호출 (실제 구현 필요)
    console.log('Creating GitHub issue:', issueBody)
  }
  
  private getRecommendations(metric: PerformanceMetric): string {
    const recommendations: Record<PerformanceMetric, string> = {
      lcp: '- 이미지 최적화 및 lazy loading 적용\n- Critical CSS 인라인화\n- 서버 응답 시간 최적화',
      fid: '- JavaScript 번들 크기 줄이기\n- 메인 스레드 차단 시간 단축\n- 이벤트 핸들러 최적화',
      cls: '- 이미지 크기 사전 지정\n- 폰트 로딩 최적화\n- 동적 콘텐츠 레이아웃 고정',
      fcp: '- Critical rendering path 최적화\n- 리소스 우선순위 조정',
      si: '- 중요한 콘텐츠 우선 렌더링\n- 리소스 로딩 최적화',
      tti: '- JavaScript 실행 시간 단축\n- 코드 스플리팅 적용',
      tbt: '- 장시간 실행 작업 분할\n- Web Workers 활용',
      calendarRender: '- 가상 스크롤링 구현\n- 이벤트 데이터 최적화',
      eventLoading: '- 데이터 캐싱 개선\n- API 응답 최적화',
      projectSwitch: '- 상태 관리 최적화\n- 불필요한 리렌더링 방지',
      searchResponse: '- 검색 인덱싱 최적화\n- 디바운싱 구현',
      bundleSize: '- Tree shaking 적용\n- 불필요한 의존성 제거',
      totalBundleSize: '- 코드 스플리팅 확대\n- 동적 import 활용',
      imageOptimization: '- Next.js Image 컴포넌트 사용\n- WebP 형식 적용',
      testCoverage: '- 단위 테스트 추가 작성\n- 통합 테스트 확대',
      e2ePassRate: '- E2E 테스트 안정성 개선\n- 플래키 테스트 수정',
    }
    
    return recommendations[metric] || '- 성능 프로파일링 수행\n- 관련 문서 참조'
  }
  
  getAllResults(): PerformanceResult[] {
    return this.results
  }
  
  getFailedResults(): PerformanceResult[] {
    return this.results.filter(result => !result.passed)
  }
  
  getPassRate(): number {
    if (this.results.length === 0) return 100
    const passed = this.results.filter(result => result.passed).length
    return (passed / this.results.length) * 100
  }
}

// CI 환경에서 사용하는 검증 함수
export const runPerformanceGates = async (
  lighthouseResults: any
): Promise<boolean> => {
  const validator = new PerformanceGateValidator()
  
  // Lighthouse 결과에서 메트릭 추출
  const lcp = lighthouseResults.audits['largest-contentful-paint']?.numericValue || 0
  const fid = lighthouseResults.audits['max-potential-fid']?.numericValue || 0
  const cls = lighthouseResults.audits['cumulative-layout-shift']?.numericValue || 0
  const fcp = lighthouseResults.audits['first-contentful-paint']?.numericValue || 0
  const si = lighthouseResults.audits['speed-index']?.numericValue || 0
  const tti = lighthouseResults.audits['interactive']?.numericValue || 0
  const tbt = lighthouseResults.audits['total-blocking-time']?.numericValue || 0
  
  // 각 메트릭 검증
  validator.validateMetric('lcp', lcp)
  validator.validateMetric('fid', fid)
  validator.validateMetric('cls', cls)
  validator.validateMetric('fcp', fcp)
  validator.validateMetric('si', si)
  validator.validateMetric('tti', tti)
  validator.validateMetric('tbt', tbt)
  
  // 결과 요약
  const passRate = validator.getPassRate()
  const failedResults = validator.getFailedResults()
  
  console.log(`\n📊 Performance Gate Results:`)
  console.log(`Pass Rate: ${passRate.toFixed(1)}%`)
  
  if (failedResults.length > 0) {
    console.log(`\n❌ Failed Metrics:`)
    failedResults.forEach(result => {
      console.log(`  ${result.metric}: ${result.value} > ${result.threshold}`)
    })
    return false
  }
  
  console.log(`✅ All performance gates passed!`)
  return true
}
```

### 4️⃣ 고급 테스트 설정

```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=src/.*\\.(test|spec)\\.(ts|tsx)$",
    "test:integration": "jest --testPathPattern=src/.*integration\\.(test|spec)\\.(ts|tsx)$",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:debug": "playwright test --debug",
    "test:a11y": "jest --testNamePattern=\"accessibility\"",
    "test:smoke": "jest --testPathPattern=smoke",
    "test:smoke:production": "NEXT_PUBLIC_APP_ENV=production npm run test:smoke",
    "test:coverage": "jest --coverage",
    "test:coverage:check": "npm run test:coverage && node scripts/check-coverage.js",
    "test:watch": "jest --watch",
    "test:ci": "jest --ci --coverage --watchAll=false --maxWorkers=2",
    "lighthouse": "lhci autorun",
    "lighthouse:ci": "lhci autorun --assert --upload.target=temporary-public-storage"
  }
}
```

### 5️⃣ 배포 스크립트 및 헬스체크

```bash
#!/bin/bash
# scripts/deploy.sh

set -e

ENVIRONMENT=${1:-staging}
VERSION=${2:-latest}

echo "🚀 Deploying to $ENVIRONMENT (version: $VERSION)"

# 환경별 설정
case $ENVIRONMENT in
  "staging")
    DEPLOY_URL="https://staging.baro-calendar.com"
    HEALTH_CHECK_URL="$DEPLOY_URL/api/health"
    SLACK_CHANNEL="#staging-deployment"
    ;;
  "production")
    DEPLOY_URL="https://baro-calendar.com"
    HEALTH_CHECK_URL="$DEPLOY_URL/api/health"
    SLACK_CHANNEL="#production-deployment"
    ;;
  *)
    echo "❌ Unknown environment: $ENVIRONMENT"
    exit 1
    ;;
esac

# 배포 전 검증
echo "🔍 Pre-deployment checks..."
npm run test:smoke
npm run build

# 배포 실행
echo "📦 Deploying to $ENVIRONMENT..."
if [ "$ENVIRONMENT" = "production" ]; then
  # 프로덕션 배포 (예: Vercel)
  npx vercel --prod --token $VERCEL_TOKEN
elif [ "$ENVIRONMENT" = "staging" ]; then
  # 스테이징 배포
  npx vercel --token $VERCEL_TOKEN
fi

# 배포 후 검증
echo "🏥 Running health checks..."
sleep 30

MAX_RETRIES=5
RETRY_COUNT=0

while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
  if curl -f -s "$HEALTH_CHECK_URL" > /dev/null; then
    echo "✅ Health check passed"
    break
  else
    RETRY_COUNT=$((RETRY_COUNT + 1))
    echo "⚠️ Health check failed (attempt $RETRY_COUNT/$MAX_RETRIES)"
    sleep 10
  fi
done

if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
  echo "❌ Health check failed after $MAX_RETRIES attempts"
  exit 1
fi

# 배포 성공 알림
echo "🎉 Deployment to $ENVIRONMENT successful!"

# Slack 알림 (옵션)
if [ -n "$SLACK_WEBHOOK_URL" ]; then
  curl -X POST -H 'Content-type: application/json' \
    --data "{
      \"channel\": \"$SLACK_CHANNEL\",
      \"text\": \"✅ Deployment to $ENVIRONMENT completed successfully\\nVersion: $VERSION\\nURL: $DEPLOY_URL\"
    }" \
    $SLACK_WEBHOOK_URL
fi
```

### 6️⃣ 모니터링 및 알림 시스템

```typescript
// src/lib/monitoring/ci-monitoring.ts
export class CIMonitoringSystem {
  private webhooks: {
    slack?: string
    discord?: string
    teams?: string
  }
  
  constructor(webhooks: typeof this.webhooks = {}) {
    this.webhooks = webhooks
  }
  
  async notifyBuildStart(branch: string, commit: string) {
    const message = {
      text: `🔨 Build started for branch \`${branch}\``,
      attachments: [
        {
          color: '#36a64f',
          fields: [
            { title: 'Branch', value: branch, short: true },
            { title: 'Commit', value: commit.substring(0, 7), short: true },
            { title: 'Triggered by', value: process.env.GITHUB_ACTOR, short: true }
          ]
        }
      ]
    }
    
    await this.sendSlackNotification(message)
  }
  
  async notifyBuildSuccess(branch: string, environment: string, metrics: any) {
    const message = {
      text: `✅ Build and deployment successful!`,
      attachments: [
        {
          color: '#36a64f',
          fields: [
            { title: 'Environment', value: environment, short: true },
            { title: 'Branch', value: branch, short: true },
            { title: 'Build Time', value: `${metrics.buildTime}s`, short: true },
            { title: 'Bundle Size', value: `${metrics.bundleSize}KB`, short: true },
            { title: 'Test Coverage', value: `${metrics.testCoverage}%`, short: true },
            { title: 'Performance Score', value: `${metrics.performanceScore}`, short: true }
          ]
        }
      ]
    }
    
    await this.sendSlackNotification(message)
  }
  
  async notifyBuildFailure(branch: string, stage: string, error: string) {
    const message = {
      text: `❌ Build failed at ${stage} stage`,
      attachments: [
        {
          color: '#ff0000',
          fields: [
            { title: 'Branch', value: branch, short: true },
            { title: 'Failed Stage', value: stage, short: true },
            { title: 'Error', value: error.substring(0, 500), short: false }
          ]
        }
      ]
    }
    
    await this.sendSlackNotification(message)
  }
  
  async notifyPerformanceRegression(metrics: PerformanceResult[]) {
    const failedMetrics = metrics.filter(m => !m.passed)
    
    if (failedMetrics.length === 0) return
    
    const message = {
      text: `⚠️ Performance regression detected!`,
      attachments: [
        {
          color: '#ff9900',
          fields: failedMetrics.map(metric => ({
            title: metric.metric,
            value: `${metric.value} > ${metric.threshold} (exceeded by ${metric.difference})`,
            short: true
          }))
        }
      ]
    }
    
    await this.sendSlackNotification(message)
  }
  
  private async sendSlackNotification(message: any) {
    if (!this.webhooks.slack) return
    
    try {
      const response = await fetch(this.webhooks.slack, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(message)
      })
      
      if (!response.ok) {
        console.error('Failed to send Slack notification:', response.statusText)
      }
    } catch (error) {
      console.error('Error sending Slack notification:', error)
    }
  }
}

// CI 환경에서 사용
export const ciMonitoring = new CIMonitoringSystem({
  slack: process.env.SLACK_WEBHOOK_URL,
})
```

---

## ✅ Definition of Done

### 🎯 기능 요구사항
- [x] 완전한 GitHub Actions CI/CD 파이프라인 구현
- [x] 병렬 작업 실행으로 빌드 시간 최적화
- [x] 품질 게이트 (린팅, 타입체크, 테스트) 구현
- [x] 성능 게이트 (Core Web Vitals) 자동 검증
- [x] E2E 테스트 자동화 및 병렬 실행
- [x] 보안 검사 통합 (SAST, 취약점 스캔)
- [x] 환경별 배포 자동화 (스테이징, 프로덕션)

### 🔧 기술 요구사항
- [x] Lighthouse CI 성능 모니터링 통합
- [x] 번들 크기 모니터링 및 임계값 검증
- [x] 테스트 커버리지 80% 이상 강제
- [x] TypeScript 엄격 모드 검증
- [x] 접근성 테스트 자동화
- [x] 성능 회귀 자동 감지
- [x] 실패 시 알림 시스템 (Slack, GitHub Issues)

### 🧪 품질 요구사항
- [x] 모든 품질 게이트 통과 시에만 배포 진행
- [x] 성능 임계값 위반 시 빌드 실패
- [x] E2E 테스트 95% 이상 통과율
- [x] 보안 취약점 자동 검사
- [x] 배포 후 헬스 체크 자동화
- [x] 롤백 시나리오 준비

### 📚 문서화 요구사항
- [x] CI/CD 파이프라인 설정 가이드
- [x] 성능 게이트 설정 및 튜닝 방법
- [x] 배포 프로세스 문서화
- [x] 모니터링 및 알림 설정 가이드
- [x] 트러블슈팅 가이드

---

## 🧪 테스트 케이스

### Unit Tests
```typescript
describe('PerformanceGateValidator', () => {
  test('should pass when metric is within threshold', () => {})
  test('should fail when metric exceeds threshold', () => {})
  test('should generate recommendations for failed metrics', () => {})
})

describe('CIMonitoringSystem', () => {
  test('should send Slack notifications', () => {})
  test('should handle webhook failures gracefully', () => {})
  test('should format performance metrics correctly', () => {})
})
```

### Integration Tests
```typescript
describe('CI Pipeline', () => {
  test('should run all quality gates successfully', () => {})
  test('should fail build when performance gates fail', () => {})
  test('should deploy to staging after successful checks', () => {})
})
```

---

## 📋 체크리스트

### 파이프라인 설정
- [x] GitHub Actions 워크플로우 파일 생성
- [x] 단계별 작업 의존성 설정
- [x] 환경 변수 및 시크릿 설정
- [x] 병렬 작업 매트릭스 구성
- [x] 타임아웃 및 재시도 설정

### 품질 게이트 구현
- [x] ESLint 및 Prettier 검증
- [x] TypeScript 타입 검사
- [x] Jest 단위 테스트 실행
- [x] 테스트 커버리지 검증
- [x] 접근성 테스트 자동화

### 성능 게이트 구현
- [x] Lighthouse CI 설정
- [x] Core Web Vitals 임계값 정의
- [x] 번들 크기 모니터링
- [x] 성능 회귀 감지 로직
- [x] 실패 시 자동 이슈 생성

### 배포 자동화
- [x] 환경별 배포 스크립트
- [x] 헬스 체크 자동화
- [x] 배포 후 검증 프로세스
- [x] 롤백 메커니즘 준비
- [x] 알림 시스템 통합

### 모니터링 및 알림
- [x] Slack 웹훅 통합
- [x] GitHub Issues 자동 생성
- [x] Sentry 에러 추적 연동
- [x] 성능 대시보드 연결
- [x] 실시간 모니터링 설정

---

*이 스토리는 바로캘린더의 완전한 CI/CD 파이프라인 및 성능 게이트 시스템 구현을 다룹니다. 모든 요구사항과 정의된 완료 조건을 충족해야 합니다.*