# Story 2.23: 반복 일정 UI 시스템 구현

## Status
Draft

## Story
**As a** 사용자,
**I want** 반복 일정을 직관적으로 생성하고 관리할 수 있는 UI 시스템을 통해,
**so that** 매일/매주/매월 반복되는 일정을 효율적으로 관리하고 예외 처리까지 완벽하게 제어할 수 있다.

## Story Points
**13**

## Prerequisites
- [ ] Story 2.11 (REST API 통합) 완료
- [ ] Story 2.3 (일정 CRUD 시스템) 완료
- [ ] Story 2.1 (프로젝트 관리 시스템) 완료

## Acceptance Criteria
1. **반복 패턴 선택 UI**: 일간/주간/월간/연간 반복 패턴과 세부 옵션 제공해야 한다
2. **반복 규칙 설정**: RRULE 표준 기반 복잡한 반복 규칙 생성 지원해야 한다  
3. **시각적 미리보기**: 반복 패턴 선택 시 향후 10개 인스턴스 미리보기 제공해야 한다
4. **예외 처리 UI**: 특정 인스턴스 수정/삭제/건너뛰기 옵션 제공해야 한다
5. **반복 종료 설정**: 날짜별/횟수별/무기한 반복 종료 조건 설정해야 한다
6. **일괄 편집 모드**: 전체 시리즈/이후 모든 일정/단일 인스턴스 편집 옵션 제공해야 한다
7. **성능 최적화**: 가상 스크롤링으로 1년치 반복 일정 렌더링 지원해야 한다
8. **접근성 준수**: WCAG 2.1 AA 기준, 스크린 리더 지원 구현해야 한다

## Tasks / Subtasks

- [ ] **1단계: 반복 패턴 선택 컴포넌트** (AC: 1, 8)
  - [ ] RecurrencePatternSelector.tsx 구현
    ```tsx
    interface RecurrencePattern {
      frequency: 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY'
      interval: number
      byWeekDay?: WeekDay[]
      byMonthDay?: number[]
      byMonth?: number[]
      bySetPos?: number
    }
    
    const RecurrencePatternSelector: React.FC<Props> = ({ value, onChange }) => {
      const [selectedFrequency, setSelectedFrequency] = useState<Frequency>('DAILY')
      const [customOptions, setCustomOptions] = useState<CustomOptions>({})
      
      return (
        <Card className="p-6">
          <div className="grid gap-6">
            {/* 기본 빈도 선택 */}
            <RadioGroup value={selectedFrequency} onValueChange={handleFrequencyChange}>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="DAILY" id="daily" />
                <Label htmlFor="daily">매일</Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="WEEKLY" id="weekly" />
                <Label htmlFor="weekly">매주</Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="MONTHLY" id="monthly" />
                <Label htmlFor="monthly">매월</Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="YEARLY" id="yearly" />
                <Label htmlFor="yearly">매년</Label>
              </div>
            </RadioGroup>
            
            {/* 세부 옵션 */}
            {renderDetailOptions()}
          </div>
        </Card>
      )
    }
    ```
  - [ ] 주간 반복 요일 선택 UI (월~일 체크박스)
  - [ ] 월간 반복 옵션 (날짜 기준 vs 순서 기준)
  - [ ] 간격 설정 (매 N일/주/월마다)
  - [ ] ARIA 라벨 및 키보드 탐색 지원

- [ ] **2단계: RRULE 엔진 통합** (AC: 2)
  - [ ] rrule 라이브러리 통합 및 타입 정의
    ```tsx
    import { RRule, RRuleSet, rrulestr } from 'rrule'
    
    export class RecurrenceRuleManager {
      static createRRule(pattern: RecurrencePattern): RRule {
        const options: Partial<RRule.Options> = {
          freq: this.mapFrequency(pattern.frequency),
          interval: pattern.interval,
          dtstart: pattern.startDate,
        }
        
        if (pattern.byWeekDay) {
          options.byweekday = pattern.byWeekDay.map(day => RRule[day])
        }
        
        if (pattern.endType === 'COUNT') {
          options.count = pattern.endCount
        } else if (pattern.endType === 'UNTIL') {
          options.until = pattern.endDate
        }
        
        return new RRule(options)
      }
      
      static generateInstances(rrule: RRule, limit: number = 100): Date[] {
        return rrule.all().slice(0, limit)
      }
      
      static parseRRuleString(rruleString: string): RecurrencePattern {
        const rule = rrulestr(rruleString)
        return this.ruleToPattern(rule)
      }
    }
    ```
  - [ ] 복잡한 규칙 조합 (RRuleSet으로 예외 날짜 처리)
  - [ ] RRULE 문자열 생성/파싱 유틸리티
  - [ ] 규칙 유효성 검증 로직

- [ ] **3단계: 반복 미리보기 시스템** (AC: 3)
  - [ ] RecurrencePreview.tsx 구현
    ```tsx
    const RecurrencePreview: React.FC<Props> = ({ rrule, startDate, limit = 10 }) => {
      const instances = useMemo(() => {
        if (!rrule) return []
        return RecurrenceRuleManager.generateInstances(rrule, limit)
      }, [rrule, limit])
      
      return (
        <Card className="p-4">
          <h3 className="text-sm font-medium mb-3">미리보기</h3>
          <ScrollArea className="h-48">
            <div className="space-y-2">
              {instances.map((date, index) => (
                <div key={index} className="flex items-center gap-2 text-sm">
                  <Calendar className="h-4 w-4 text-muted-foreground" />
                  <span>{formatDate(date, 'YYYY년 M월 D일 (ddd)')}</span>
                  {index === 0 && (
                    <Badge variant="outline" className="text-xs">첫 번째</Badge>
                  )}
                </div>
              ))}
              {instances.length === limit && (
                <div className="text-xs text-muted-foreground pt-2 border-t">
                  ... 및 추가 반복 일정
                </div>
              )}
            </div>
          </ScrollArea>
        </Card>
      )
    }
    ```
  - [ ] 실시간 미리보기 업데이트 (패턴 변경 시)
  - [ ] 날짜 포맷팅 및 현지화 지원
  - [ ] 미리보기 개수 제한 및 더보기 기능

- [ ] **4단계: 반복 종료 조건 UI** (AC: 5)
  - [ ] RecurrenceEndOptions.tsx 구현
    ```tsx
    type EndType = 'NEVER' | 'COUNT' | 'UNTIL'
    
    const RecurrenceEndOptions: React.FC<Props> = ({ value, onChange }) => {
      const [endType, setEndType] = useState<EndType>('NEVER')
      const [endCount, setEndCount] = useState(10)
      const [endDate, setEndDate] = useState<Date>()
      
      return (
        <Card className="p-4">
          <Label className="text-sm font-medium">반복 종료</Label>
          <RadioGroup value={endType} onValueChange={handleEndTypeChange} className="mt-3">
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="NEVER" id="never" />
              <Label htmlFor="never">종료하지 않음</Label>
            </div>
            
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="COUNT" id="count" />
              <Label htmlFor="count">횟수로 종료</Label>
              {endType === 'COUNT' && (
                <div className="flex items-center gap-2 ml-4">
                  <Input
                    type="number"
                    value={endCount}
                    onChange={(e) => setEndCount(Number(e.target.value))}
                    className="w-20"
                    min="1"
                    max="999"
                  />
                  <span className="text-sm">회 반복</span>
                </div>
              )}
            </div>
            
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="UNTIL" id="until" />
              <Label htmlFor="until">날짜로 종료</Label>
              {endType === 'UNTIL' && (
                <DatePicker
                  date={endDate}
                  onDateChange={setEndDate}
                  className="ml-4"
                />
              )}
            </div>
          </RadioGroup>
        </Card>
      )
    }
    ```
  - [ ] 종료 조건 유효성 검증 (시작일 이후 등)
  - [ ] 종료 조건별 미리보기 반영
  - [ ] 사용자 친화적 안내 메시지

- [ ] **5단계: 예외 처리 및 편집 시스템** (AC: 4, 6)
  - [ ] RecurrenceExceptionHandler.tsx 구현
    ```tsx
    type EditScope = 'THIS_ONLY' | 'THIS_AND_FOLLOWING' | 'ALL_SERIES'
    
    const RecurrenceExceptionHandler: React.FC<Props> = ({ 
      eventId, 
      instanceDate, 
      onEdit 
    }) => {
      const [editScope, setEditScope] = useState<EditScope>('THIS_ONLY')
      
      const handleEditConfirm = () => {
        switch (editScope) {
          case 'THIS_ONLY':
            onEdit({ type: 'exception', instanceDate, changes })
            break
          case 'THIS_AND_FOLLOWING':
            onEdit({ type: 'split', splitDate: instanceDate, changes })
            break
          case 'ALL_SERIES':
            onEdit({ type: 'series', changes })
            break
        }
      }
      
      return (
        <Dialog open={isOpen} onOpenChange={setIsOpen}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>반복 일정 편집</DialogTitle>
              <DialogDescription>
                이 일정은 반복 일정의 일부입니다. 어떤 범위를 편집하시겠습니까?
              </DialogDescription>
            </DialogHeader>
            
            <RadioGroup value={editScope} onValueChange={setEditScope}>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="THIS_ONLY" id="this-only" />
                <div>
                  <Label htmlFor="this-only">이 일정만</Label>
                  <p className="text-xs text-muted-foreground">
                    {formatDate(instanceDate)} 일정만 변경합니다
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="THIS_AND_FOLLOWING" id="this-following" />
                <div>
                  <Label htmlFor="this-following">이 일정 이후 모두</Label>
                  <p className="text-xs text-muted-foreground">
                    이 날짜부터 향후 모든 반복 일정을 변경합니다
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="ALL_SERIES" id="all-series" />
                <div>
                  <Label htmlFor="all-series">전체 시리즈</Label>
                  <p className="text-xs text-muted-foreground">
                    모든 반복 일정을 동일하게 변경합니다
                  </p>
                </div>
              </div>
            </RadioGroup>
            
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsOpen(false)}>취소</Button>
              <Button onClick={handleEditConfirm}>적용</Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )
    }
    ```
  - [ ] 단일 인스턴스 예외 생성 (EXDATE 활용)
  - [ ] 시리즈 분할 로직 (UNTIL 조정 + 새 시리즈 생성)
  - [ ] 예외 인스턴스 시각적 표시 (아이콘, 색상 구분)

- [ ] **6단계: 반복 일정 성능 최적화** (AC: 7)
  - [ ] 가상 스크롤링으로 반복 인스턴스 렌더링
    ```tsx
    import { FixedSizeList as List } from 'react-window'
    
    const VirtualizedRecurrenceList: React.FC<Props> = ({ 
      rrule, 
      startDate, 
      endDate 
    }) => {
      const instances = useMemo(() => {
        return RecurrenceRuleManager.generateInstancesInRange(
          rrule, 
          startDate, 
          endDate
        )
      }, [rrule, startDate, endDate])
      
      const renderRow = ({ index, style }: ListChildComponentProps) => (
        <div style={style}>
          <RecurrenceEventCard 
            event={instances[index]} 
            isRecurring 
            onEdit={handleEditInstance}
            onDelete={handleDeleteInstance}
          />
        </div>
      )
      
      return (
        <List
          height={600}
          itemCount={instances.length}
          itemSize={80}
          width="100%"
        >
          {renderRow}
        </List>
      )
    }
    ```
  - [ ] 인스턴스 생성 최적화 (청크 단위 처리)
  - [ ] 메모이제이션을 통한 리렌더링 최소화
  - [ ] 백그라운드 스레드에서 대량 계산 처리

- [ ] **7단계: REST API 연동** (AC: 2, 4, 6)
  - [ ] 반복 일정 API 엔드포인트 연동
    ```tsx
    export class RecurringEventsApi extends ApiClient {
      async createRecurringEvent(eventData: CreateRecurringEventDto): Promise<RecurringEvent> {
        const response = await this.client.post<RecurringEvent>('/events/recurring', {
          ...eventData,
          recurrence: {
            rrule: eventData.rrule,
            timezone: eventData.timezone,
            exceptions: []
          }
        })
        return response.data
      }
      
      async updateRecurringEvent(
        eventId: string, 
        updates: UpdateRecurringEventDto, 
        scope: EditScope
      ): Promise<RecurringEvent> {
        const response = await this.client.put<RecurringEvent>(`/events/recurring/${eventId}`, {
          ...updates,
          editScope: scope
        })
        return response.data
      }
      
      async createException(
        eventId: string, 
        instanceDate: string, 
        exceptionData?: Partial<Event>
      ): Promise<Event> {
        const response = await this.client.post<Event>(
          `/events/recurring/${eventId}/exceptions`, {
            instanceDate,
            ...exceptionData
          }
        )
        return response.data
      }
      
      async deleteInstance(
        eventId: string, 
        instanceDate: string, 
        scope: 'THIS_ONLY' | 'THIS_AND_FOLLOWING'
      ): Promise<void> {
        await this.client.delete(`/events/recurring/${eventId}/instances/${instanceDate}`, {
          params: { scope }
        })
      }
    }
    ```
  - [ ] 반복 일정 생성/수정/삭제 API 연동
  - [ ] 예외 인스턴스 관리 API 연동
  - [ ] 에러 처리 및 재시도 로직

- [ ] **8단계: 상태 관리 통합** (AC: 1-6)
  - [ ] Zustand 스토어에 반복 일정 상태 추가
    ```tsx
    interface RecurrenceStore {
      recurringEvents: Map<string, RecurringEvent>
      recurrenceExceptions: Map<string, Event[]>
      
      // Actions
      setRecurringEvent: (event: RecurringEvent) => void
      updateRecurringEvent: (eventId: string, updates: Partial<RecurringEvent>) => void
      addException: (eventId: string, exception: Event) => void
      removeException: (eventId: string, instanceDate: string) => void
      
      // Selectors
      getRecurringEventInstances: (eventId: string, range: DateRange) => Event[]
      getExceptionsForEvent: (eventId: string) => Event[]
      hasRecurrence: (eventId: string) => boolean
    }
    
    export const useRecurrenceStore = create<RecurrenceStore>((set, get) => ({
      recurringEvents: new Map(),
      recurrenceExceptions: new Map(),
      
      setRecurringEvent: (event) => set((state) => {
        const newMap = new Map(state.recurringEvents)
        newMap.set(event.id, event)
        return { recurringEvents: newMap }
      }),
      
      getRecurringEventInstances: (eventId, range) => {
        const event = get().recurringEvents.get(eventId)
        if (!event?.recurrence?.rrule) return []
        
        const rule = rrulestr(event.recurrence.rrule)
        const instances = rule.between(range.start, range.end, true)
        const exceptions = get().recurrenceExceptions.get(eventId) || []
        
        return instances
          .filter(date => !exceptions.some(ex => 
            isSameDay(new Date(ex.startTime), date)
          ))
          .map(date => ({
            ...event,
            id: `${event.id}-${format(date, 'yyyy-MM-dd')}`,
            startTime: date.toISOString(),
            endTime: addHours(date, 1).toISOString(), // 기본 1시간
            isRecurringInstance: true,
            parentEventId: event.id
          }))
      }
    }))
    ```
  - [ ] TanStack Query를 통한 캐싱 및 동기화
  - [ ] 반복 일정 로딩 상태 관리
  - [ ] 낙관적 업데이트 구현

## Dev Notes

### RRULE 표준 준수
**[Source: RFC 5545 - Internet Calendaring and Scheduling Core Object Specification]**
```
RRULE:FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE,FR;COUNT=10
```

**지원하는 반복 패턴:**
- **DAILY**: 매일, 매 N일, 평일만, 주말만
- **WEEKLY**: 매주, 매 N주, 특정 요일 조합
- **MONTHLY**: 매월, 매 N월, 특정 날짜/순서
- **YEARLY**: 매년, 매 N년, 특정 월/날짜

### 성능 최적화 전략
**[Source: docs/ui-architecture/08-runtime-performance.md]**
- **가상 스크롤링**: react-window로 대량 인스턴스 렌더링
- **청크 단위 계산**: 1000개씩 나누어 인스턴스 생성
- **메모이제이션**: RRULE 파싱 결과 캐싱
- **백그라운드 처리**: Web Worker로 복잡한 계산 분리

### 접근성 구현 세부사항
**[Source: docs/ui-architecture/11-accessibility-implementation.md]**
- **키보드 탐색**: Tab, Arrow 키로 반복 옵션 순회
- **스크린 리더**: 반복 패턴 설명 음성 안내
- **ARIA 라벨**: 복잡한 UI 요소 역할 명시
- **포커스 관리**: 다이얼로그 내 포커스 트랩

---

*이 스토리는 사용자 친화적인 반복 일정 관리를 위한 완전한 UI 시스템을 제공합니다. RRULE 표준을 준수하면서도 직관적인 사용자 경험을 보장합니다.*