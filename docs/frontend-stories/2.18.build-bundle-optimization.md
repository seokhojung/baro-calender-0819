# Story 2.18: Build & Bundle Optimization Implementation

## 📋 문서 정보
- **문서 버전**: 1.0
- **작성일**: 2025-08-28
- **작성자**: Frontend Team
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **상태**: Active
- **관련 아키텍처 문서**: [09-build-bundle-optimization.md](../ui-architecture/09-build-bundle-optimization.md)

---

## 🎯 스토리 목표

바로캘린더 애플리케이션의 **빌드 및 번들 최적화**를 구현하여 사용자에게 빠른 초기 로딩과 효율적인 리소스 사용을 제공하며, 개발팀에게는 최적화된 배포 파이프라인을 제공한다.

### 주요 구현 사항
- **지능적 코드 스플리팅** 및 청크 최적화
- **트리 셰이킹** 및 데드 코드 제거
- **이미지 및 미디어 최적화** 파이프라인
- **서비스 워커 기반 캐싱** 전략

---

## 👤 사용자 스토리

### US 2.18.1: 빠른 초기 로딩
**As a** 사용자  
**I want** 바로캘린더가 최소한의 파일만 로드하여 빠르게 시작되기를  
**So that** 네트워크 상황에 관계없이 신속하게 애플리케이션을 사용할 수 있다.

**인수 조건:**
- [ ] 초기 JavaScript 번들 크기 < 250KB (gzipped)
- [ ] 주요 CSS 파일 크기 < 50KB (gzipped)
- [ ] 폰트 및 이미지 파일 최적화로 로딩 시간 단축
- [ ] 코드 스플리팅으로 필요한 코드만 로드

### US 2.18.2: 효율적인 리소스 관리
**As a** 사용자  
**I want** 사용하지 않는 기능의 코드는 로드하지 않기를  
**So that** 모바일 데이터나 느린 네트워크에서도 원활하게 사용할 수 있다.

**인수 조건:**
- [ ] 트리 셰이킹으로 미사용 코드 완전 제거
- [ ] 라이브러리 선택적 임포트로 번들 크기 최소화
- [ ] 동적 임포트로 필요 시점에만 코드 로드
- [ ] 중복 코드 제거 및 청크 최적화

### US 2.18.3: 최적화된 미디어 처리
**As a** 사용자  
**I want** 이미지와 미디어 파일이 내 디바이스에 맞게 최적화되어 로드되기를  
**So that** 빠른 로딩과 데이터 절약을 동시에 달성할 수 있다.

**인수 조건:**
- [ ] WebP/AVIF 형식 이미지 자동 제공
- [ ] 반응형 이미지로 디바이스별 최적화
- [ ] 지연 로딩으로 필요한 이미지만 로드
- [ ] 이미지 압축 및 크기 최적화

### US 2.18.4: 오프라인 지원 및 캐싱
**As a** 사용자  
**I want** 한 번 로드한 리소스는 오프라인에서도 사용할 수 있기를  
**So that** 네트워크 연결이 불안정해도 기본 기능을 계속 사용할 수 있다.

**인수 조건:**
- [ ] 서비스 워커 기반 오프라인 지원
- [ ] 정적 리소스 효율적 캐싱
- [ ] 네트워크 우선 + 캐시 폴백 전략
- [ ] 오프라인 상태에서 기본 기능 사용 가능

---

## 🔧 기술적 구현 요구사항

### 1. Next.js 번들 최적화 설정

**주요 파일**: `next.config.ts`

```typescript
// next.config.ts
import type { NextConfig } from 'next'
import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer'
import CompressionPlugin from 'compression-webpack-plugin'

const nextConfig: NextConfig = {
  // 실험적 기능 활용
  experimental: {
    // 패키지 임포트 최적화
    optimizePackageImports: [
      'lucide-react',
      'date-fns',
      '@radix-ui/react-icons',
      'class-variance-authority'
    ],
    
    // Turbo 설정
    turbo: {
      rules: {
        '*.svg': {
          loaders: ['@svgr/webpack'],
          as: '*.js',
        },
      },
    },
    
    // 서버 컴포넌트 및 액션 최적화
    serverComponentsExternalPackages: ['sharp'],
  },
  
  // 이미지 최적화 설정
  images: {
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 31536000, // 1년
    dangerouslyAllowSVG: true,
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
  
  // 웹팩 최적화
  webpack: (config, { dev, isServer, buildId }) => {
    // 프로덕션 빌드에서만 최적화 적용
    if (!dev && !isServer) {
      
      // 번들 분석기 (환경 변수로 제어)
      if (process.env.ANALYZE === 'true') {
        config.plugins.push(
          new BundleAnalyzerPlugin({
            analyzerMode: 'static',
            reportFilename: '../analyze/bundle-report.html',
            openAnalyzer: false,
          })
        )
      }
      
      // 압축 플러그인
      config.plugins.push(
        new CompressionPlugin({
          algorithm: 'gzip',
          test: /\.(js|css|html|svg)$/,
          threshold: 8192,
          minRatio: 0.8,
        })
      )
      
      // 코드 스플리팅 최적화
      config.optimization.splitChunks = {
        chunks: 'all',
        minSize: 20000,
        maxSize: 250000,
        cacheGroups: {
          // React 관련 라이브러리
          react: {
            test: /[\\/]node_modules[\\/](react|react-dom|scheduler)[\\/]/,
            name: 'react-vendor',
            chunks: 'all',
            priority: 40,
            enforce: true,
          },
          
          // Next.js 코어
          nextjs: {
            test: /[\\/]node_modules[\\/]next[\\/]/,
            name: 'nextjs-vendor',
            chunks: 'all',
            priority: 35,
            enforce: true,
          },
          
          // UI 라이브러리
          ui: {
            test: /[\\/]node_modules[\\/](@radix-ui|lucide-react|class-variance-authority)[\\/]/,
            name: 'ui-vendor',
            chunks: 'all',
            priority: 30,
          },
          
          // 날짜 및 유틸리티 라이브러리
          utils: {
            test: /[\\/]node_modules[\\/](date-fns|clsx|tailwind-merge)[\\/]/,
            name: 'utils-vendor',
            chunks: 'all',
            priority: 25,
          },
          
          // 폼 관련 라이브러리
          forms: {
            test: /[\\/]node_modules[\\/](react-hook-form|@hookform)[\\/]/,
            name: 'forms-vendor',
            chunks: 'all',
            priority: 20,
          },
          
          // 캘린더 관련 컴포넌트
          calendar: {
            name: 'calendar-chunk',
            test: /[\\/]src[\\/]components[\\/]calendar[\\/]/,
            chunks: 'async',
            priority: 15,
            minChunks: 2,
          },
          
          // 프로젝트 관련 컴포넌트
          projects: {
            name: 'projects-chunk',
            test: /[\\/]src[\\/]components[\\/]projects[\\/]/,
            chunks: 'async',
            priority: 15,
            minChunks: 2,
          },
          
          // 기타 벤더 라이브러리
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
            priority: 10,
          },
          
          // 공통 모듈
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'all',
            priority: 5,
            reuseExistingChunk: true,
          },
        },
      }
      
      // 모듈 연결 최적화
      config.optimization.concatenateModules = true
      
      // 사이드 이펙트 최적화
      config.optimization.sideEffects = false
    }
    
    // SVG 최적화
    config.module.rules.push({
      test: /\.svg$/i,
      issuer: /\.[jt]sx?$/,
      use: ['@svgr/webpack'],
    })
    
    return config
  },
  
  // 컴파일러 최적화
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // 정적 파일 최적화
  assetPrefix: process.env.CDN_URL || '',
  
  // 성능 설정
  onDemandEntries: {
    maxInactiveAge: 25 * 1000,
    pagesBufferLength: 2,
  },
  
  // HTTP 헤더 최적화
  async headers() {
    return [
      {
        source: '/(.*)\\.(js|css|woff2|woff|png|jpg|jpeg|webp|avif|svg|ico)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on',
          },
        ],
      },
    ]
  },
}

export default nextConfig
```

### 2. 트리 셰이킹 최적화 시스템

**주요 파일**: `src/lib/utils/tree-shaking.ts`

```typescript
// src/lib/utils/tree-shaking.ts

// ✅ 올바른 선택적 임포트 패턴
export const optimizedImports = {
  // 날짜 유틸리티 선택적 임포트
  dateUtils: {
    // ✅ 좋은 예
    good: () => import('date-fns/format'),
    format: () => import('date-fns/format'),
    parseISO: () => import('date-fns/parseISO'),
    isValid: () => import('date-fns/isValid'),
    
    // ❌ 나쁜 예 (전체 임포트)
    // bad: () => import('date-fns'),
  },
  
  // 아이콘 선택적 임포트
  icons: {
    Calendar: () => import('lucide-react/dist/esm/icons/calendar'),
    Plus: () => import('lucide-react/dist/esm/icons/plus'),
    Settings: () => import('lucide-react/dist/esm/icons/settings'),
    User: () => import('lucide-react/dist/esm/icons/user'),
  },
  
  // UI 컴포넌트 선택적 임포트
  ui: {
    Button: () => import('@/components/ui/Button'),
    Dialog: () => import('@/components/ui/Dialog'),
    Card: () => import('@/components/ui/Card'),
    Input: () => import('@/components/ui/Input'),
  },
}

// 동적 임포트 헬퍼
export const createLazyLoader = <T>(
  importFn: () => Promise<{ default: T }>,
  fallback?: T
) => {
  let cached: T | null = null
  let loading: Promise<T> | null = null
  
  return {
    load: async (): Promise<T> => {
      if (cached) return cached
      
      if (!loading) {
        loading = importFn().then(module => {
          cached = module.default
          loading = null
          return cached
        }).catch(error => {
          loading = null
          if (fallback) {
            cached = fallback
            return fallback
          }
          throw error
        })
      }
      
      return loading
    },
    
    preload: () => {
      if (!cached && !loading) {
        loading = importFn().then(module => {
          cached = module.default
          loading = null
          return cached
        }).catch(() => {
          loading = null
          return null
        })
      }
    },
    
    get cached() {
      return cached
    },
  }
}

// 번들 분석 유틸리티
export class BundleAnalyzer {
  private static importSizes = new Map<string, number>()
  
  static trackImport(name: string, size: number) {
    this.importSizes.set(name, size)
  }
  
  static getImportStats() {
    return Array.from(this.importSizes.entries())
      .sort(([, a], [, b]) => b - a)
      .map(([name, size]) => ({
        name,
        size: `${(size / 1024).toFixed(2)}KB`,
        percentage: `${((size / this.getTotalSize()) * 100).toFixed(1)}%`,
      }))
  }
  
  private static getTotalSize() {
    return Array.from(this.importSizes.values())
      .reduce((total, size) => total + size, 0)
  }
  
  static generateReport() {
    const stats = this.getImportStats()
    const report = {
      totalImports: stats.length,
      totalSize: `${(this.getTotalSize() / 1024).toFixed(2)}KB`,
      largestImports: stats.slice(0, 10),
      recommendations: this.generateRecommendations(stats),
    }
    
    if (process.env.NODE_ENV === 'development') {
      console.table(stats)
      console.log('Bundle Analysis Report:', report)
    }
    
    return report
  }
  
  private static generateRecommendations(stats: any[]) {
    const recommendations = []
    
    const largeImports = stats.filter(stat => parseInt(stat.size) > 50)
    if (largeImports.length > 0) {
      recommendations.push('Consider code splitting for large imports')
    }
    
    const duplicatePatterns = this.findDuplicatePatterns(stats)
    if (duplicatePatterns.length > 0) {
      recommendations.push('Potential duplicate imports detected')
    }
    
    return recommendations
  }
  
  private static findDuplicatePatterns(stats: any[]) {
    const patterns = new Map<string, number>()
    
    stats.forEach(({ name }) => {
      const pattern = name.split('/')[0] // 패키지명 추출
      patterns.set(pattern, (patterns.get(pattern) || 0) + 1)
    })
    
    return Array.from(patterns.entries())
      .filter(([, count]) => count > 3)
      .map(([pattern]) => pattern)
  }
}

// 사이드 이펙트 최적화를 위한 pure 함수들
export const pureFunctions = {
  // 순수 함수로 마킹하여 트리 셰이킹 최적화
  /*#__PURE__*/ formatDate: (date: Date, format: string) => {
    // 외부 의존성 없는 순수 함수
    return date.toISOString()
  },
  
  /*#__PURE__*/ calculateDays: (start: Date, end: Date) => {
    const diffTime = Math.abs(end.getTime() - start.getTime())
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24))
  },
  
  /*#__PURE__*/ generateId: () => {
    return Math.random().toString(36).substr(2, 9)
  },
}
```

### 3. 이미지 최적화 파이프라인

**주요 파일**: `src/components/ui/OptimizedImage.tsx`

```typescript
// src/components/ui/OptimizedImage.tsx
import React, { useState, useCallback, useRef } from 'react'
import Image from 'next/image'
import { cn } from '@/lib/utils'

interface OptimizedImageProps {
  src: string
  alt: string
  width: number
  height: number
  className?: string
  priority?: boolean
  quality?: number
  placeholder?: 'blur' | 'empty'
  blurDataURL?: string
  sizes?: string
  fill?: boolean
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down'
  loading?: 'lazy' | 'eager'
  onLoad?: () => void
  onError?: () => void
}

// 이미지 플레이스홀더 생성
const generateBlurDataURL = (width: number, height: number): string => {
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  
  const ctx = canvas.getContext('2d')
  if (!ctx) return ''
  
  // 그라데이션 플레이스홀더
  const gradient = ctx.createLinearGradient(0, 0, width, height)
  gradient.addColorStop(0, '#f3f4f6')
  gradient.addColorStop(1, '#e5e7eb')
  
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, width, height)
  
  return canvas.toDataURL()
}

export const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  width,
  height,
  className,
  priority = false,
  quality = 85,
  placeholder = 'blur',
  blurDataURL,
  sizes,
  fill = false,
  objectFit = 'cover',
  loading = 'lazy',
  onLoad,
  onError,
}) => {
  const [isLoading, setIsLoading] = useState(true)
  const [hasError, setHasError] = useState(false)
  const [actualSrc, setActualSrc] = useState(src)
  const imgRef = useRef<HTMLImageElement>(null)
  
  // 이미지 로드 완료 처리
  const handleLoad = useCallback(() => {
    setIsLoading(false)
    onLoad?.()
  }, [onLoad])
  
  // 이미지 에러 처리
  const handleError = useCallback(() => {
    setHasError(true)
    setIsLoading(false)
    
    // 폴백 이미지 시도
    if (actualSrc !== '/images/placeholder.webp') {
      setActualSrc('/images/placeholder.webp')
      return
    }
    
    onError?.()
  }, [actualSrc, onError])
  
  // 에러 상태 렌더링
  if (hasError && actualSrc === '/images/placeholder.webp') {
    return (
      <div
        className={cn(
          'flex items-center justify-center bg-muted text-muted-foreground border border-border rounded-md',
          className
        )}
        style={{ width, height }}
      >
        <div className="text-center p-4">
          <div className="w-8 h-8 mx-auto mb-2 opacity-50">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              <circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21,15 16,10 5,21"/>
            </svg>
          </div>
          <span className="text-xs">이미지 로드 실패</span>
        </div>
      </div>
    )
  }
  
  // 기본 블러 데이터 URL 생성
  const defaultBlurDataURL = blurDataURL || (
    typeof window !== 'undefined' && placeholder === 'blur'
      ? generateBlurDataURL(width, height)
      : undefined
  )
  
  return (
    <div className={cn('relative overflow-hidden', className)}>
      <Image
        ref={imgRef}
        src={actualSrc}
        alt={alt}
        width={fill ? undefined : width}
        height={fill ? undefined : height}
        fill={fill}
        className={cn(
          'transition-opacity duration-300',
          isLoading ? 'opacity-0' : 'opacity-100',
          fill ? `object-${objectFit}` : ''
        )}
        style={!fill ? { objectFit } : undefined}
        priority={priority}
        quality={quality}
        placeholder={placeholder}
        blurDataURL={defaultBlurDataURL}
        sizes={sizes}
        loading={loading}
        onLoad={handleLoad}
        onError={handleError}
      />
      
      {/* 로딩 스켈레톤 */}
      {isLoading && !hasError && (
        <div
          className="absolute inset-0 bg-muted animate-pulse flex items-center justify-center"
          style={{ width: fill ? '100%' : width, height: fill ? '100%' : height }}
        >
          <div className="w-6 h-6 text-muted-foreground opacity-50">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              <circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21,15 16,10 5,21"/>
            </svg>
          </div>
        </div>
      )}
    </div>
  )
}

// 반응형 이미지 컴포넌트
interface ResponsiveImageProps extends Omit<OptimizedImageProps, 'width' | 'height' | 'sizes'> {
  aspectRatio: number // width/height
  maxWidth?: number
  breakpoints?: {
    sm?: number
    md?: number
    lg?: number
    xl?: number
  }
}

export const ResponsiveImage: React.FC<ResponsiveImageProps> = ({
  aspectRatio,
  maxWidth = 1920,
  breakpoints = { sm: 640, md: 768, lg: 1024, xl: 1280 },
  ...props
}) => {
  // sizes 속성 자동 생성
  const sizes = Object.entries(breakpoints)
    .reverse() // 큰 크기부터
    .map(([key, value]) => `(min-width: ${value}px) ${maxWidth}px`)
    .concat([`${maxWidth}px`])
    .join(', ')
  
  return (
    <div className="relative w-full" style={{ aspectRatio: aspectRatio }}>
      <OptimizedImage
        {...props}
        fill
        sizes={sizes}
        className="w-full h-full"
      />
    </div>
  )
}

// 지연 로딩 이미지 컴포넌트
export const LazyImage: React.FC<OptimizedImageProps> = (props) => {
  const [isInView, setIsInView] = useState(false)
  const imgRef = useRef<HTMLDivElement>(null)
  
  // Intersection Observer를 사용한 지연 로딩
  React.useEffect(() => {
    if (!imgRef.current) return
    
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true)
          observer.disconnect()
        }
      },
      {
        rootMargin: '50px', // 50px 전에 미리 로드
        threshold: 0.1,
      }
    )
    
    observer.observe(imgRef.current)
    
    return () => observer.disconnect()
  }, [])
  
  if (!isInView) {
    return (
      <div
        ref={imgRef}
        className={cn('bg-muted animate-pulse', props.className)}
        style={{ width: props.width, height: props.height }}
      />
    )
  }
  
  return <OptimizedImage {...props} />
}
```

### 4. 서비스 워커 및 캐싱 전략

**주요 파일**: `public/sw.js`

```javascript
// public/sw.js
const CACHE_NAME = 'baro-calendar-v2'
const STATIC_CACHE = 'baro-static-v2'
const DYNAMIC_CACHE = 'baro-dynamic-v2'
const IMAGE_CACHE = 'baro-images-v2'

// 캐시할 정적 자원
const STATIC_ASSETS = [
  '/',
  '/calendar',
  '/projects',
  '/manifest.json',
  '/offline.html',
]

// 캐시 전략
const CACHE_STRATEGIES = {
  // 정적 자원: 캐시 우선
  static: ['/_next/static/', '/static/', '.css', '.js', '.woff2', '.woff'],
  // 이미지: 캐시 우선, 오래된 것 허용
  images: ['.jpg', '.jpeg', '.png', '.webp', '.avif', '.svg'],
  // API: 네트워크 우선, 캐시 폴백
  api: ['/api/'],
  // HTML: 네트워크 우선
  html: ['.html', '/'],
}

// 설치 이벤트
self.addEventListener('install', (event) => {
  console.log('[SW] Install event')
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('[SW] Caching static assets')
        return cache.addAll(STATIC_ASSETS)
      })
      .then(() => {
        // 즉시 활성화
        return self.skipWaiting()
      })
  )
})

// 활성화 이벤트
self.addEventListener('activate', (event) => {
  console.log('[SW] Activate event')
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((cacheName) => {
              // 현재 버전이 아닌 캐시 삭제
              return ![CACHE_NAME, STATIC_CACHE, DYNAMIC_CACHE, IMAGE_CACHE].includes(cacheName)
            })
            .map((cacheName) => {
              console.log('[SW] Deleting old cache:', cacheName)
              return caches.delete(cacheName)
            })
        )
      })
      .then(() => {
        // 모든 클라이언트를 즉시 제어
        return self.clients.claim()
      })
  )
})

// 요청 가로채기
self.addEventListener('fetch', (event) => {
  const { request } = event
  const url = new URL(request.url)
  
  // Chrome extension 요청 무시
  if (url.protocol === 'chrome-extension:') {
    return
  }
  
  // HTTPS가 아닌 요청 무시
  if (url.protocol !== 'https:' && url.hostname !== 'localhost') {
    return
  }
  
  event.respondWith(handleRequest(request))
})

// 요청 처리 함수
async function handleRequest(request) {
  const url = new URL(request.url)
  
  // API 요청 처리
  if (isAPIRequest(url)) {
    return handleAPIRequest(request)
  }
  
  // 이미지 요청 처리
  if (isImageRequest(url)) {
    return handleImageRequest(request)
  }
  
  // 정적 자원 처리
  if (isStaticAsset(url)) {
    return handleStaticAsset(request)
  }
  
  // HTML 페이지 처리
  return handleHTMLRequest(request)
}

// API 요청 처리 (네트워크 우선)
async function handleAPIRequest(request) {
  try {
    // 네트워크 요청 시도
    const response = await fetch(request)
    
    // 성공한 GET 요청만 캐시
    if (response.ok && request.method === 'GET') {
      const cache = await caches.open(DYNAMIC_CACHE)
      cache.put(request, response.clone())
    }
    
    return response
  } catch (error) {
    // 네트워크 실패 시 캐시에서 응답
    console.log('[SW] Network failed for API, trying cache:', request.url)
    
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      return cachedResponse
    }
    
    // 오프라인 응답
    return new Response(
      JSON.stringify({ error: 'Offline', message: '네트워크 연결을 확인해주세요' }),
      {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      }
    )
  }
}

// 이미지 요청 처리 (캐시 우선)
async function handleImageRequest(request) {
  const cache = await caches.open(IMAGE_CACHE)
  const cachedResponse = await cache.match(request)
  
  if (cachedResponse) {
    // 백그라운드에서 업데이트 확인
    fetch(request).then((response) => {
      if (response.ok) {
        cache.put(request, response.clone())
      }
    }).catch(() => {
      // 네트워크 에러 무시
    })
    
    return cachedResponse
  }
  
  try {
    const response = await fetch(request)
    
    if (response.ok) {
      cache.put(request, response.clone())
    }
    
    return response
  } catch (error) {
    // 플레이스홀더 이미지 반환
    return new Response(
      generatePlaceholderImage(),
      {
        headers: { 'Content-Type': 'image/svg+xml' }
      }
    )
  }
}

// 정적 자원 처리 (캐시 우선)
async function handleStaticAsset(request) {
  const cachedResponse = await caches.match(request)
  
  if (cachedResponse) {
    return cachedResponse
  }
  
  try {
    const response = await fetch(request)
    
    if (response.ok) {
      const cache = await caches.open(STATIC_CACHE)
      cache.put(request, response.clone())
    }
    
    return response
  } catch (error) {
    console.log('[SW] Failed to fetch static asset:', request.url)
    throw error
  }
}

// HTML 요청 처리 (네트워크 우선)
async function handleHTMLRequest(request) {
  try {
    return await fetch(request)
  } catch (error) {
    // 오프라인 페이지 반환
    const offlinePage = await caches.match('/offline.html')
    return offlinePage || new Response(
      '<h1>오프라인 상태입니다</h1><p>네트워크 연결을 확인해주세요.</p>',
      {
        headers: { 'Content-Type': 'text/html' }
      }
    )
  }
}

// 요청 타입 판별 함수들
function isAPIRequest(url) {
  return CACHE_STRATEGIES.api.some(pattern => url.pathname.includes(pattern))
}

function isImageRequest(url) {
  return CACHE_STRATEGIES.images.some(ext => url.pathname.endsWith(ext))
}

function isStaticAsset(url) {
  return CACHE_STRATEGIES.static.some(pattern => 
    url.pathname.includes(pattern) || url.pathname.endsWith(pattern)
  )
}

// 플레이스홀더 이미지 생성
function generatePlaceholderImage() {
  return `
    <svg width="400" height="300" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#f3f4f6"/>
      <text x="50%" y="50%" text-anchor="middle" dy="0.3em" fill="#9ca3af" font-family="sans-serif" font-size="16">
        이미지를 불러올 수 없습니다
      </text>
    </svg>
  `
}

// 메시지 처리
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
  
  if (event.data && event.data.type === 'GET_CACHE_SIZE') {
    getCacheSize().then(size => {
      event.ports[0].postMessage({ cacheSize: size })
    })
  }
})

// 캐시 크기 계산
async function getCacheSize() {
  const cacheNames = await caches.keys()
  let totalSize = 0
  
  for (const cacheName of cacheNames) {
    const cache = await caches.open(cacheName)
    const requests = await cache.keys()
    
    for (const request of requests) {
      const response = await cache.match(request)
      if (response) {
        const blob = await response.blob()
        totalSize += blob.size
      }
    }
  }
  
  return totalSize
}
```

### 5. 번들 분석 및 최적화 도구

**주요 파일**: `scripts/analyze-bundle.ts`

```typescript
// scripts/analyze-bundle.ts
import fs from 'fs'
import path from 'path'
import { gzipSync } from 'zlib'
import { execSync } from 'child_process'

interface BundleStats {
  totalSize: number
  gzippedSize: number
  assets: BundleAsset[]
  chunks: BundleChunk[]
  recommendations: string[]
}

interface BundleAsset {
  name: string
  size: number
  gzippedSize: number
  type: 'js' | 'css' | 'image' | 'font' | 'other'
}

interface BundleChunk {
  name: string
  size: number
  files: string[]
  isInitial: boolean
}

export class BundleAnalyzer {
  private buildPath: string
  private thresholds = {
    initialBundleSize: 250 * 1024, // 250KB
    chunkSize: 100 * 1024, // 100KB
    assetSize: 50 * 1024, // 50KB
  }
  
  constructor(buildPath = '.next') {
    this.buildPath = path.join(process.cwd(), buildPath)
  }
  
  async analyze(): Promise<BundleStats> {
    console.log('🔍 Analyzing bundle...')
    
    const assets = await this.analyzeAssets()
    const chunks = await this.analyzeChunks()
    
    const totalSize = assets.reduce((sum, asset) => sum + asset.size, 0)
    const gzippedSize = assets.reduce((sum, asset) => sum + asset.gzippedSize, 0)
    
    const recommendations = this.generateRecommendations(assets, chunks)
    
    const stats: BundleStats = {
      totalSize,
      gzippedSize,
      assets,
      chunks,
      recommendations,
    }
    
    this.printReport(stats)
    await this.saveReport(stats)
    
    return stats
  }
  
  private async analyzeAssets(): Promise<BundleAsset[]> {
    const staticPath = path.join(this.buildPath, 'static')
    
    if (!fs.existsSync(staticPath)) {
      throw new Error('Build directory not found. Run `npm run build` first.')
    }
    
    const assets: BundleAsset[] = []
    
    const scanDir = (dir: string) => {
      const entries = fs.readdirSync(dir)
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry)
        const stat = fs.statSync(fullPath)
        
        if (stat.isDirectory()) {
          scanDir(fullPath)
        } else {
          const content = fs.readFileSync(fullPath)
          const gzippedContent = gzipSync(content)
          
          assets.push({
            name: path.relative(this.buildPath, fullPath),
            size: content.length,
            gzippedSize: gzippedContent.length,
            type: this.getAssetType(fullPath),
          })
        }
      }
    }
    
    scanDir(staticPath)
    
    return assets.sort((a, b) => b.gzippedSize - a.gzippedSize)
  }
  
  private async analyzeChunks(): Promise<BundleChunk[]> {
    // Next.js build 통계 파일 읽기
    const buildManifestPath = path.join(this.buildPath, 'build-manifest.json')
    
    if (!fs.existsSync(buildManifestPath)) {
      return []
    }
    
    const buildManifest = JSON.parse(fs.readFileSync(buildManifestPath, 'utf8'))
    const chunks: BundleChunk[] = []
    
    // 페이지별 청크 분석
    for (const [page, files] of Object.entries(buildManifest.pages)) {
      const chunkFiles = files as string[]
      const chunkSize = chunkFiles.reduce((sum, file) => {
        const fullPath = path.join(this.buildPath, 'static', file)
        
        if (fs.existsSync(fullPath)) {
          return sum + fs.statSync(fullPath).size
        }
        
        return sum
      }, 0)
      
      chunks.push({
        name: page,
        size: chunkSize,
        files: chunkFiles,
        isInitial: page === '/_app' || page === '/index',
      })
    }
    
    return chunks.sort((a, b) => b.size - a.size)
  }
  
  private getAssetType(filePath: string): BundleAsset['type'] {
    const ext = path.extname(filePath)
    
    switch (ext) {
      case '.js':
        return 'js'
      case '.css':
        return 'css'
      case '.jpg':
      case '.jpeg':
      case '.png':
      case '.webp':
      case '.avif':
      case '.svg':
        return 'image'
      case '.woff':
      case '.woff2':
      case '.ttf':
        return 'font'
      default:
        return 'other'
    }
  }
  
  private generateRecommendations(assets: BundleAsset[], chunks: BundleChunk[]): string[] {
    const recommendations: string[] = []
    
    // 초기 번들 크기 체크
    const initialChunks = chunks.filter(chunk => chunk.isInitial)
    const initialSize = initialChunks.reduce((sum, chunk) => sum + chunk.size, 0)
    
    if (initialSize > this.thresholds.initialBundleSize) {
      recommendations.push(`Initial bundle size (${(initialSize / 1024).toFixed(2)}KB) exceeds threshold. Consider code splitting.`)
    }
    
    // 큰 청크 식별
    const largeChunks = chunks.filter(chunk => chunk.size > this.thresholds.chunkSize)
    if (largeChunks.length > 0) {
      recommendations.push(`Found ${largeChunks.length} large chunks. Consider further splitting.`)
    }
    
    // 큰 자산 식별
    const largeAssets = assets.filter(asset => asset.gzippedSize > this.thresholds.assetSize)
    if (largeAssets.length > 0) {
      recommendations.push(`Found ${largeAssets.length} large assets. Consider optimization.`)
    }
    
    // 중복 라이브러리 감지
    const jsAssets = assets.filter(asset => asset.type === 'js')
    const duplicateLibs = this.findDuplicateLibraries(jsAssets)
    if (duplicateLibs.length > 0) {
      recommendations.push(`Potential duplicate libraries: ${duplicateLibs.join(', ')}`)
    }
    
    // 이미지 최적화
    const unoptimizedImages = assets.filter(asset => 
      asset.type === 'image' && 
      !asset.name.includes('.webp') && 
      !asset.name.includes('.avif')
    )
    if (unoptimizedImages.length > 0) {
      recommendations.push(`${unoptimizedImages.length} images could be converted to WebP/AVIF`)
    }
    
    return recommendations
  }
  
  private findDuplicateLibraries(jsAssets: BundleAsset[]): string[] {
    const libCounts = new Map<string, number>()
    
    jsAssets.forEach(asset => {
      // 라이브러리명 추출 시도
      const matches = asset.name.match(/webpack\/(.+?)\./)
      if (matches && matches[1]) {
        const lib = matches[1].split('-')[0]
        libCounts.set(lib, (libCounts.get(lib) || 0) + 1)
      }
    })
    
    return Array.from(libCounts.entries())
      .filter(([, count]) => count > 1)
      .map(([lib]) => lib)
  }
  
  private printReport(stats: BundleStats) {
    console.log('\n📊 Bundle Analysis Report\n')
    
    // 총 크기
    console.log(`Total Size: ${(stats.totalSize / 1024 / 1024).toFixed(2)}MB`)
    console.log(`Gzipped: ${(stats.gzippedSize / 1024 / 1024).toFixed(2)}MB`)
    console.log(`Compression: ${(((stats.totalSize - stats.gzippedSize) / stats.totalSize) * 100).toFixed(1)}%\n`)
    
    // 가장 큰 자산들
    console.log('🏆 Largest Assets (Gzipped):')
    stats.assets.slice(0, 10).forEach((asset, i) => {
      const size = `${(asset.gzippedSize / 1024).toFixed(2)}KB`
      console.log(`  ${i + 1}. ${asset.name} (${asset.type}) - ${size}`)
    })
    
    // 청크 분석
    if (stats.chunks.length > 0) {
      console.log('\n📦 Largest Chunks:')
      stats.chunks.slice(0, 5).forEach((chunk, i) => {
        const size = `${(chunk.size / 1024).toFixed(2)}KB`
        const type = chunk.isInitial ? '(initial)' : '(async)'
        console.log(`  ${i + 1}. ${chunk.name} ${type} - ${size}`)
      })
    }
    
    // 권장사항
    if (stats.recommendations.length > 0) {
      console.log('\n💡 Recommendations:')
      stats.recommendations.forEach((rec, i) => {
        console.log(`  ${i + 1}. ${rec}`)
      })
    }
    
    // 성능 등급
    const grade = this.calculateGrade(stats)
    console.log(`\n🎯 Performance Grade: ${grade}`)
  }
  
  private calculateGrade(stats: BundleStats): string {
    const gzippedMB = stats.gzippedSize / 1024 / 1024
    
    if (gzippedMB < 0.25) return 'A+ (Excellent)'
    if (gzippedMB < 0.5) return 'A (Very Good)'
    if (gzippedMB < 1) return 'B (Good)'
    if (gzippedMB < 2) return 'C (Fair)'
    return 'D (Needs Improvement)'
  }
  
  private async saveReport(stats: BundleStats) {
    const reportPath = path.join(process.cwd(), 'bundle-report.json')
    
    const report = {
      timestamp: new Date().toISOString(),
      ...stats,
    }
    
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2))
    console.log(`\n📄 Report saved to ${reportPath}`)
  }
  
  async compareWithPrevious(): Promise<void> {
    const reportPath = path.join(process.cwd(), 'bundle-report.json')
    
    if (!fs.existsSync(reportPath)) {
      console.log('No previous report found.')
      return
    }
    
    const currentStats = await this.analyze()
    const previousReport = JSON.parse(fs.readFileSync(reportPath, 'utf8'))
    
    console.log('\n📈 Comparison with Previous Build:')
    
    const sizeDiff = currentStats.gzippedSize - previousReport.gzippedSize
    const sizeDiffPercent = ((sizeDiff / previousReport.gzippedSize) * 100).toFixed(1)
    
    if (sizeDiff > 0) {
      console.log(`📈 Bundle size increased by ${(sizeDiff / 1024).toFixed(2)}KB (${sizeDiffPercent}%)`)
    } else if (sizeDiff < 0) {
      console.log(`📉 Bundle size decreased by ${Math.abs(sizeDiff / 1024).toFixed(2)}KB (${Math.abs(parseFloat(sizeDiffPercent))}%)`)
    } else {
      console.log('➡️ Bundle size unchanged')
    }
  }
}

// CLI 실행
if (require.main === module) {
  const analyzer = new BundleAnalyzer()
  
  const command = process.argv[2]
  
  switch (command) {
    case 'compare':
      analyzer.compareWithPrevious().catch(console.error)
      break
    default:
      analyzer.analyze().catch(console.error)
  }
}
```

---

## 🎨 UX 디자인 고려사항

### 로딩 경험 개선
- **점진적 로딩**: 중요한 콘텐츠부터 우선 표시
- **스켈레톤 UI**: 실제 레이아웃과 유사한 로딩 인디케이터
- **성능 인사이트**: 개발자 도구에서 로딩 성능 시각화

### 오프라인 대응
- **오프라인 알림**: 네트워크 상태 변화 사용자 알림
- **캐시된 콘텐츠**: 오프라인에서도 기본 기능 제공
- **동기화**: 온라인 복구 시 자동 데이터 동기화

### 성능 피드백
- **로딩 진행률**: 큰 리소스 로딩 시 진행률 표시
- **에러 복구**: 로딩 실패 시 재시도 옵션 제공
- **데이터 사용량**: 모바일 사용자를 위한 데이터 절약 모드

---

## ⚡ 성능 최적화

### 번들 크기 최적화
- **코드 스플리팅**: 라우트 및 기능별 청크 분리
- **트리 셰이킹**: 미사용 코드 완전 제거
- **라이브러리 최적화**: 필요한 부분만 선택적 임포트

### 리소스 최적화
- **이미지 압축**: WebP/AVIF 형식으로 자동 변환
- **폰트 서브셋**: 사용하는 문자만 포함한 경량 폰트
- **CSS 최적화**: 미사용 스타일 제거 및 압축

### 네트워크 최적화
- **HTTP/2 활용**: 다중 요청 병렬 처리
- **캐싱 전략**: 적절한 캐시 헤더로 재방문 성능 향상
- **CDN 활용**: 전 세계 사용자에게 빠른 리소스 제공

---

## 🧪 Definition of Done

### 번들 크기 달성 요구사항
- [ ] 초기 JavaScript 번들 < 250KB (gzipped)
- [ ] 주요 CSS 번들 < 50KB (gzipped)
- [ ] 개별 청크 크기 < 100KB (gzipped)
- [ ] 전체 정적 리소스 < 2MB (gzipped)

### 최적화 기능 구현 요구사항
- [ ] 자동 코드 스플리팅 및 지연 로딩
- [ ] 트리 셰이킹으로 미사용 코드 제거
- [ ] 이미지 자동 최적화 (WebP/AVIF 변환)
- [ ] 서비스 워커 기반 캐싱 시스템

### 개발 도구 요구사항
- [ ] 번들 분석 도구 및 리포트 생성
- [ ] 성능 회귀 감지 시스템
- [ ] 자동화된 최적화 제안
- [ ] CI/CD 통합 번들 크기 체크

### 사용자 경험 요구사항
- [ ] 초기 로딩 시간 < 3초 (3G 네트워크)
- [ ] 오프라인에서 기본 기능 사용 가능
- [ ] 이미지 로딩 실패 시 적절한 폴백
- [ ] 네트워크 상태 변화 시 사용자 알림

### 품질 보증 요구사항
- [ ] Lighthouse 성능 점수 > 90
- [ ] WebPageTest 등급 A 달성
- [ ] 다양한 네트워크 조건에서 테스트 통과
- [ ] 모바일 디바이스 성능 검증

---

## 📚 관련 문서

- [09-build-bundle-optimization.md](../ui-architecture/09-build-bundle-optimization.md) - 빌드 최적화 아키텍처
- [Story 2.17: Runtime Performance](./2.17.runtime-performance.md) - 런타임 성능 최적화
- [Story 2.5: Performance Optimization](./2.5.performance-optimization.md) - 기존 성능 최적화
- [Story 2.22: CI Pipeline Performance](./2.22.ci-pipeline-performance.md) - CI/CD 성능

---

## 📈 성공 지표

### 성능 지표
- **번들 크기**: 전체 번들 크기 40% 감소
- **로딩 속도**: 초기 로딩 시간 50% 단축
- **캐시 적중률**: 정적 리소스 캐시 적중률 > 85%
- **압축률**: Gzip 압축으로 평균 70% 크기 감소

### 사용자 경험 지표
- **이탈률 감소**: 로딩 시간 개선으로 이탈률 30% 감소
- **페이지 뷰**: 빠른 로딩으로 페이지 뷰 20% 증가
- **사용자 만족도**: 성능 관련 만족도 점수 > 8/10
- **재방문률**: 캐싱 효과로 재방문 시 로딩 속도 80% 향상

### 개발 효율성 지표
- **배포 시간**: 최적화된 빌드로 배포 시간 25% 단축
- **디버깅 시간**: 번들 분석 도구로 성능 이슈 파악 시간 60% 단축
- **개발 생산성**: 최적화 자동화로 개발자 수작업 시간 70% 감소
- **CI/CD 안정성**: 성능 회귀 자동 감지로 안정성 95% 달성

### 비즈니스 지표
- **데이터 절약**: 모바일 사용자 데이터 사용량 40% 감소
- **서버 비용**: CDN 캐싱으로 서버 부하 30% 감소
- **전환율**: 빠른 로딩으로 사용자 전환율 15% 향상
- **경쟁 우위**: 동종 업계 대비 로딩 속도 2배 빠른 성능 달성