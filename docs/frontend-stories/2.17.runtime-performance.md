# Story 2.17: Runtime Performance Optimization Implementation

## 📋 문서 정보
- **문서 버전**: 1.0
- **작성일**: 2025-08-28
- **작성자**: Frontend Team
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **상태**: Active
- **관련 아키텍처 문서**: [08-runtime-performance.md](../ui-architecture/08-runtime-performance.md)

---

## 🎯 스토리 목표

바로캘린더 애플리케이션의 **런타임 성능을 최적화**하여 사용자가 빠르고 반응적인 인터페이스를 경험할 수 있도록 하며, Core Web Vitals 기준을 충족하는 고성능 웹 애플리케이션을 구축한다.

### 주요 구현 사항
- **Core Web Vitals 목표 달성** (LCP < 2.5s, FID < 100ms, CLS < 0.1)
- **지능적 코드 스플리팅** 및 레이지 로딩 구현
- **가상 스크롤링** 및 메모리 최적화
- **실시간 성능 모니터링** 및 분석 시스템

---

## 👤 사용자 스토리

### US 2.17.1: 빠른 초기 로딩
**As a** 사용자  
**I want** 바로캘린더가 빠르게 로드되고 곧바로 사용할 수 있기를  
**So that** 기다림 없이 즉시 일정을 확인하고 관리할 수 있다.

**인수 조건:**
- [ ] LCP (Largest Contentful Paint) < 2.5초
- [ ] FCP (First Contentful Paint) < 1.8초
- [ ] TTI (Time to Interactive) < 3.8초
- [ ] 캘린더 뷰 전환 시간 < 150ms

### US 2.17.2: 부드러운 인터랙션
**As a** 사용자  
**I want** 캘린더에서 날짜를 선택하거나 이벤트를 조작할 때 즉각적으로 반응하기를  
**So that** 자연스럽고 매끄러운 사용 경험을 얻을 수 있다.

**인수 조건:**
- [ ] FID (First Input Delay) < 100ms
- [ ] 모든 애니메이션 60fps 유지
- [ ] 사용자 인터랙션 응답 시간 < 100ms
- [ ] 스크롤 성능 최적화 (no jank)

### US 2.17.3: 안정적인 레이아웃
**As a** 사용자  
**I want** 페이지 로딩 중이나 콘텐츠 변경 시 레이아웃이 갑자기 변경되지 않기를  
**So that** 의도하지 않은 클릭이나 혼란을 겪지 않을 수 있다.

**인수 조건:**
- [ ] CLS (Cumulative Layout Shift) < 0.1
- [ ] 이미지 로딩 시 레이아웃 시프트 방지
- [ ] 동적 콘텐츠 로딩 시 공간 미리 확보
- [ ] 웹폰트 로딩으로 인한 FOIT/FOUT 최소화

### US 2.17.4: 대용량 데이터 처리
**As a** 대량의 일정을 관리하는 사용자  
**I want** 수백 개의 이벤트가 있어도 캘린더가 빠르게 동작하기를  
**So that** 많은 일정이 있어도 원활하게 관리할 수 있다.

**인수 조건:**
- [ ] 1000+ 이벤트 처리 시 성능 저하 < 10%
- [ ] 가상 스크롤링으로 메모리 사용량 최적화
- [ ] 메모이제이션으로 불필요한 재렌더링 방지
- [ ] 메모리 누수 방지 및 자동 정리

---

## 🔧 기술적 구현 요구사항

### 1. Core Web Vitals 모니터링 시스템

**주요 파일**: `src/lib/performance/web-vitals.ts`

```typescript
// src/lib/performance/web-vitals.ts
import { getCLS, getFID, getFCP, getLCP, getTTI } from 'web-vitals'

interface WebVitalsMetrics {
  lcp: number
  fid: number
  cls: number
  fcp: number
  tti: number
}

interface PerformanceTarget {
  lcp: number    // 2.5초
  fid: number    // 100ms
  cls: number    // 0.1
  fcp: number    // 1.8초
  tti: number    // 3.8초
}

export const PERFORMANCE_TARGETS: PerformanceTarget = {
  lcp: 2500,
  fid: 100,
  cls: 0.1,
  fcp: 1800,
  tti: 3800,
}

export class WebVitalsMonitor {
  private static metrics: Partial<WebVitalsMetrics> = {}
  private static callbacks: ((metric: string, value: number) => void)[] = []
  
  static initialize() {
    // LCP 측정
    getLCP((metric) => {
      this.recordMetric('lcp', metric.value)
    })
    
    // FID 측정
    getFID((metric) => {
      this.recordMetric('fid', metric.value)
    })
    
    // CLS 측정
    getCLS((metric) => {
      this.recordMetric('cls', metric.value)
    })
    
    // FCP 측정
    getFCP((metric) => {
      this.recordMetric('fcp', metric.value)
    })
    
    // TTI 측정
    getTTI((metric) => {
      this.recordMetric('tti', metric.value)
    })
  }
  
  private static recordMetric(name: keyof WebVitalsMetrics, value: number) {
    this.metrics[name] = value
    
    // 목표치 확인
    const target = PERFORMANCE_TARGETS[name]
    const isGood = value <= target
    
    console.log(`${name.toUpperCase()}: ${value}ms ${isGood ? '✅' : '⚠️'}`)
    
    // 콜백 실행
    this.callbacks.forEach(callback => callback(name, value))
    
    // 성능 이벤트 발송
    this.sendToAnalytics(name, value, isGood)
    
    // 목표치 초과 시 알림
    if (!isGood) {
      this.emitPerformanceWarning(name, value, target)
    }
  }
  
  static onMetric(callback: (metric: string, value: number) => void) {
    this.callbacks.push(callback)
  }
  
  static getMetrics(): Partial<WebVitalsMetrics> {
    return { ...this.metrics }
  }
  
  static getScore(): { score: number; grade: 'A' | 'B' | 'C' | 'D' | 'F' } {
    const scores = Object.entries(this.metrics).map(([key, value]) => {
      const target = PERFORMANCE_TARGETS[key as keyof PerformanceTarget]
      return Math.min(100, (target / value) * 100)
    })
    
    const averageScore = scores.reduce((sum, score) => sum + score, 0) / scores.length
    
    let grade: 'A' | 'B' | 'C' | 'D' | 'F'
    if (averageScore >= 90) grade = 'A'
    else if (averageScore >= 80) grade = 'B'
    else if (averageScore >= 70) grade = 'C'
    else if (averageScore >= 60) grade = 'D'
    else grade = 'F'
    
    return { score: Math.round(averageScore), grade }
  }
  
  private static sendToAnalytics(metric: string, value: number, isGood: boolean) {
    // Google Analytics 4 전송
    if (typeof gtag !== 'undefined') {
      gtag('event', 'web_vitals', {
        event_category: 'Performance',
        event_label: metric.toUpperCase(),
        value: Math.round(value),
        custom_metric_good: isGood,
      })
    }
    
    // 내부 분석 서버 전송
    fetch('/api/analytics/web-vitals', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        metric,
        value,
        isGood,
        url: window.location.href,
        timestamp: Date.now(),
      }),
    }).catch(console.error)
  }
  
  private static emitPerformanceWarning(metric: string, value: number, target: number) {
    const event = new CustomEvent('performance-warning', {
      detail: { metric, value, target },
    })
    window.dispatchEvent(event)
    
    // 개발 환경에서만 콘솔 경고
    if (process.env.NODE_ENV === 'development') {
      console.warn(
        `🚨 성능 목표 미달성: ${metric.toUpperCase()} = ${value}ms (목표: ${target}ms)`
      )
    }
  }
}

// React Hook
export const useWebVitals = () => {
  const [metrics, setMetrics] = useState<Partial<WebVitalsMetrics>>({})
  const [score, setScore] = useState<{ score: number; grade: string }>({ score: 0, grade: 'F' })
  
  useEffect(() => {
    WebVitalsMonitor.initialize()
    
    const updateMetrics = () => {
      setMetrics(WebVitalsMonitor.getMetrics())
      setScore(WebVitalsMonitor.getScore())
    }
    
    WebVitalsMonitor.onMetric(updateMetrics)
    
    // 성능 경고 리스너
    const handlePerformanceWarning = (event: CustomEvent) => {
      const { metric, value, target } = event.detail
      // 사용자에게 알림 (개발 환경에서만)
      if (process.env.NODE_ENV === 'development') {
        console.warn(`Performance issue: ${metric} = ${value}ms > ${target}ms`)
      }
    }
    
    window.addEventListener('performance-warning', handlePerformanceWarning as EventListener)
    
    return () => {
      window.removeEventListener('performance-warning', handlePerformanceWarning as EventListener)
    }
  }, [])
  
  return { metrics, score }
}
```

### 2. 지능적 코드 스플리팅 시스템

**주요 파일**: `src/lib/performance/code-splitting.ts`

```typescript
// src/lib/performance/code-splitting.ts
import { lazy, Suspense, ComponentType } from 'react'
import dynamic from 'next/dynamic'

interface LazyLoadConfig {
  loading?: ComponentType
  delay?: number
  timeout?: number
  retries?: number
}

// 지연 로딩 컴포넌트 팩토리
export const createLazyComponent = <T extends ComponentType<any>>(
  importFn: () => Promise<{ default: T }>,
  config: LazyLoadConfig = {}
) => {
  const { loading: LoadingComponent, delay = 200, timeout = 10000, retries = 3 } = config
  
  const LazyComponent = lazy(() => {
    let retryCount = 0
    
    const loadWithRetry = (): Promise<{ default: T }> => {
      return importFn().catch((error) => {
        if (retryCount < retries) {
          retryCount++
          console.warn(`Component load failed, retrying... (${retryCount}/${retries})`)
          return new Promise(resolve => {
            setTimeout(() => resolve(loadWithRetry()), 1000 * retryCount)
          })
        }
        throw error
      })
    }
    
    return Promise.race([
      loadWithRetry(),
      new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Component load timeout')), timeout)
      })
    ])
  })
  
  const WrappedComponent = (props: any) => (
    <Suspense fallback={LoadingComponent ? <LoadingComponent /> : null}>
      <LazyComponent {...props} />
    </Suspense>
  )
  
  return WrappedComponent
}

// 캘린더 뷰 컴포넌트들의 지연 로딩
export const LazyCalendarViews = {
  MonthView: createLazyComponent(
    () => import('@/components/calendar/MonthView'),
    { loading: () => <CalendarSkeleton type="month" /> }
  ),
  
  WeekView: createLazyComponent(
    () => import('@/components/calendar/WeekView'),
    { loading: () => <CalendarSkeleton type="week" /> }
  ),
  
  DayView: createLazyComponent(
    () => import('@/components/calendar/DayView'),
    { loading: () => <CalendarSkeleton type="day" /> }
  ),
  
  ListView: createLazyComponent(
    () => import('@/components/calendar/ListView'),
    { loading: () => <CalendarSkeleton type="list" /> }
  ),
}

// 스켈레톤 로딩 컴포넌트
const CalendarSkeleton: React.FC<{ type: 'month' | 'week' | 'day' | 'list' }> = ({ type }) => {
  const skeletonClasses = "animate-pulse bg-muted rounded-md"
  
  switch (type) {
    case 'month':
      return (
        <div className="grid grid-cols-7 gap-2 p-4">
          {Array.from({ length: 35 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} aspect-square`} />
          ))}
        </div>
      )
    
    case 'week':
      return (
        <div className="space-y-2 p-4">
          {Array.from({ length: 7 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} h-20`} />
          ))}
        </div>
      )
    
    case 'day':
      return (
        <div className="space-y-1 p-4">
          {Array.from({ length: 24 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} h-12`} />
          ))}
        </div>
      )
    
    case 'list':
      return (
        <div className="space-y-2 p-4">
          {Array.from({ length: 10 }, (_, i) => (
            <div key={i} className={`${skeletonClasses} h-16`} />
          ))}
        </div>
      )
    
    default:
      return <div className={`${skeletonClasses} h-64`} />
  }
}

// 프리로딩 매니저
export class PreloadManager {
  private static preloadedComponents = new Set<string>()
  private static preloadQueue = new Map<string, () => Promise<any>>()
  
  static register(name: string, importFn: () => Promise<any>) {
    this.preloadQueue.set(name, importFn)
  }
  
  static async preload(name: string): Promise<boolean> {
    if (this.preloadedComponents.has(name)) {
      return true
    }
    
    const importFn = this.preloadQueue.get(name)
    if (!importFn) {
      console.warn(`No preload function registered for: ${name}`)
      return false
    }
    
    try {
      await importFn()
      this.preloadedComponents.add(name)
      console.log(`✅ Preloaded: ${name}`)
      return true
    } catch (error) {
      console.error(`❌ Failed to preload ${name}:`, error)
      return false
    }
  }
  
  static async preloadBatch(names: string[], concurrent = 2): Promise<boolean[]> {
    const batches = []
    for (let i = 0; i < names.length; i += concurrent) {
      batches.push(names.slice(i, i + concurrent))
    }
    
    const results: boolean[] = []
    for (const batch of batches) {
      const batchResults = await Promise.all(batch.map(name => this.preload(name)))
      results.push(...batchResults)
    }
    
    return results
  }
  
  static getPreloadedComponents(): string[] {
    return Array.from(this.preloadedComponents)
  }
}

// 컴포넌트 등록
PreloadManager.register('MonthView', () => import('@/components/calendar/MonthView'))
PreloadManager.register('WeekView', () => import('@/components/calendar/WeekView'))
PreloadManager.register('DayView', () => import('@/components/calendar/DayView'))
PreloadManager.register('ListView', () => import('@/components/calendar/ListView'))
PreloadManager.register('EventEditor', () => import('@/components/events/EventEditor'))
PreloadManager.register('ProjectManager', () => import('@/components/projects/ProjectManager'))

// 지능적 프리로딩 훅
export const useIntelligentPreload = (currentView: string) => {
  const [preloadStatus, setPreloadStatus] = useState<Record<string, boolean>>({})
  
  useEffect(() => {
    const preloadStrategy = {
      'month': ['WeekView', 'DayView'],
      'week': ['MonthView', 'DayView'],
      'day': ['WeekView', 'MonthView'],
      'list': ['MonthView'],
    }
    
    const componentsToPreload = preloadStrategy[currentView as keyof typeof preloadStrategy] || []
    
    if (componentsToPreload.length > 0) {
      // 사용자가 idle 상태일 때 프리로드
      const preloadTimer = setTimeout(async () => {
        const results = await PreloadManager.preloadBatch(componentsToPreload)
        const status: Record<string, boolean> = {}
        componentsToPreload.forEach((name, index) => {
          status[name] = results[index]
        })
        setPreloadStatus(status)
      }, 1000) // 1초 후 프리로드 시작
      
      return () => clearTimeout(preloadTimer)
    }
  }, [currentView])
  
  return preloadStatus
}
```

### 3. 가상 스크롤링 시스템

**주요 파일**: `src/components/common/VirtualScrolling.tsx`

```typescript
// src/components/common/VirtualScrolling.tsx
import React, { useMemo, useCallback, useRef, useEffect, useState } from 'react'
import { FixedSizeList as List, VariableSizeList, areEqual } from 'react-window'
import { FixedSizeGrid as Grid } from 'react-window'

interface VirtualListProps<T> {
  items: T[]
  height: number
  itemHeight: number | ((index: number) => number)
  renderItem: (item: T, index: number, style: React.CSSProperties) => React.ReactNode
  overscan?: number
  className?: string
  onScroll?: (scrollTop: number) => void
}

// 고정 크기 가상 리스트
export const VirtualList = <T,>({
  items,
  height,
  itemHeight,
  renderItem,
  overscan = 5,
  className,
  onScroll,
}: VirtualListProps<T>) => {
  const listRef = useRef<any>(null)
  
  const ItemRenderer = useCallback(({ index, style }: { index: number, style: React.CSSProperties }) => {
    const item = items[index]
    return renderItem(item, index, style)
  }, [items, renderItem])
  
  const MemoizedItemRenderer = React.memo(ItemRenderer, areEqual)
  
  const handleScroll = useCallback(({ scrollTop }: { scrollTop: number }) => {
    onScroll?.(scrollTop)
  }, [onScroll])
  
  return (
    <div className={className}>
      {typeof itemHeight === 'number' ? (
        <List
          ref={listRef}
          height={height}
          itemCount={items.length}
          itemSize={itemHeight}
          overscanCount={overscan}
          onScroll={handleScroll}
        >
          {MemoizedItemRenderer}
        </List>
      ) : (
        <VariableSizeList
          ref={listRef}
          height={height}
          itemCount={items.length}
          itemSize={itemHeight}
          overscanCount={overscan}
          onScroll={handleScroll}
        >
          {MemoizedItemRenderer}
        </VariableSizeList>
      )}
    </div>
  )
}

// 가변 크기 가상 리스트
export const DynamicVirtualList = <T,>({
  items,
  height,
  estimatedItemHeight = 50,
  renderItem,
  overscan = 5,
  className,
}: {
  items: T[]
  height: number
  estimatedItemHeight?: number
  renderItem: (item: T, index: number, style: React.CSSProperties) => React.ReactNode
  overscan?: number
  className?: string
}) => {
  const listRef = useRef<VariableSizeList>(null)
  const itemSizes = useRef<Map<number, number>>(new Map())
  
  const getItemSize = useCallback((index: number) => {
    return itemSizes.current.get(index) ?? estimatedItemHeight
  }, [estimatedItemHeight])
  
  const ItemRenderer = useCallback(({ index, style }: { index: number, style: React.CSSProperties }) => {
    const item = items[index]
    
    return (
      <div
        style={style}
        ref={(el) => {
          if (el) {
            const height = el.getBoundingClientRect().height
            if (height !== itemSizes.current.get(index)) {
              itemSizes.current.set(index, height)
              listRef.current?.resetAfterIndex(index)
            }
          }
        }}
      >
        {renderItem(item, index, style)}
      </div>
    )
  }, [items, renderItem])
  
  const MemoizedItemRenderer = React.memo(ItemRenderer, areEqual)
  
  return (
    <div className={className}>
      <VariableSizeList
        ref={listRef}
        height={height}
        itemCount={items.length}
        itemSize={getItemSize}
        overscanCount={overscan}
      >
        {MemoizedItemRenderer}
      </VariableSizeList>
    </div>
  )
}

// 캘린더 이벤트 가상 리스트
interface CalendarEvent {
  id: string
  title: string
  date: Date
  duration: number
  projectId: number
}

export const VirtualEventList: React.FC<{
  events: CalendarEvent[]
  height: number
  onEventClick: (event: CalendarEvent) => void
}> = ({ events, height, onEventClick }) => {
  const renderEvent = useCallback((event: CalendarEvent, index: number, style: React.CSSProperties) => (
    <div 
      key={event.id}
      style={style}
      className="flex items-center p-3 border-b border-border hover:bg-accent cursor-pointer transition-colors"
      onClick={() => onEventClick(event)}
    >
      <div className="flex-1 min-w-0">
        <h4 className="font-medium text-foreground truncate">{event.title}</h4>
        <p className="text-sm text-muted-foreground">
          {event.date.toLocaleDateString()} • {event.duration}분
        </p>
      </div>
      <div 
        className="w-3 h-3 rounded-full ml-3"
        style={{ backgroundColor: `var(--project-color-${event.projectId})` }}
      />
    </div>
  ), [onEventClick])
  
  return (
    <VirtualList
      items={events}
      height={height}
      itemHeight={70}
      renderItem={renderEvent}
      className="border border-border rounded-md overflow-hidden"
    />
  )
}

// 무한 스크롤 가상 리스트
export const InfiniteVirtualList = <T,>({
  items,
  height,
  itemHeight,
  renderItem,
  hasNextPage,
  loadNextPage,
  loading,
}: VirtualListProps<T> & {
  hasNextPage: boolean
  loadNextPage: () => Promise<void>
  loading: boolean
}) => {
  const [isLoadingMore, setIsLoadingMore] = useState(false)
  
  const handleScroll = useCallback(async (scrollTop: number, scrollHeight: number, clientHeight: number) => {
    // 스크롤이 90% 지점에 도달하면 다음 페이지 로드
    const scrollPercentage = (scrollTop + clientHeight) / scrollHeight
    
    if (scrollPercentage > 0.9 && hasNextPage && !loading && !isLoadingMore) {
      setIsLoadingMore(true)
      try {
        await loadNextPage()
      } finally {
        setIsLoadingMore(false)
      }
    }
  }, [hasNextPage, loading, isLoadingMore, loadNextPage])
  
  const ItemRenderer = useCallback(({ index, style }: { index: number, style: React.CSSProperties }) => {
    const item = items[index]
    
    // 로딩 아이템 렌더링
    if (index === items.length && (isLoadingMore || loading)) {
      return (
        <div style={style} className="flex items-center justify-center p-4">
          <div className="w-6 h-6 border-2 border-primary border-t-transparent rounded-full animate-spin" />
          <span className="ml-2 text-muted-foreground">로딩 중...</span>
        </div>
      )
    }
    
    return renderItem(item, index, style)
  }, [items, renderItem, isLoadingMore, loading])
  
  const itemCount = items.length + (hasNextPage ? 1 : 0)
  
  return (
    <List
      height={height}
      itemCount={itemCount}
      itemSize={typeof itemHeight === 'number' ? itemHeight : 50}
      onScroll={({ scrollTop, scrollHeight, clientHeight }) => {
        handleScroll(scrollTop, scrollHeight, clientHeight)
      }}
    >
      {ItemRenderer}
    </List>
  )
}
```

### 4. 메모리 최적화 시스템

**주요 파일**: `src/lib/performance/memory-optimization.ts`

```typescript
// src/lib/performance/memory-optimization.ts
import { useRef, useEffect, useCallback } from 'react'

// 메모리 사용량 모니터링
export class MemoryMonitor {
  private static instance: MemoryMonitor
  private intervalId: number | null = null
  private callbacks: ((memoryInfo: MemoryInfo) => void)[] = []
  
  static getInstance(): MemoryMonitor {
    if (!this.instance) {
      this.instance = new MemoryMonitor()
    }
    return this.instance
  }
  
  startMonitoring(interval = 5000) {
    if (this.intervalId) {
      clearInterval(this.intervalId)
    }
    
    this.intervalId = window.setInterval(() => {
      if ('memory' in performance) {
        const memoryInfo = (performance as any).memory as MemoryInfo
        this.callbacks.forEach(callback => callback(memoryInfo))
        
        // 메모리 사용량이 임계치를 초과하면 경고
        const usedMB = memoryInfo.usedJSHeapSize / (1024 * 1024)
        const limitMB = memoryInfo.jsHeapSizeLimit / (1024 * 1024)
        const usagePercentage = (usedMB / limitMB) * 100
        
        if (usagePercentage > 80) {
          console.warn(`메모리 사용량 높음: ${usedMB.toFixed(2)}MB (${usagePercentage.toFixed(1)}%)`)
          this.emitMemoryWarning(memoryInfo)
        }
      }
    }, interval)
  }
  
  stopMonitoring() {
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = null
    }
  }
  
  onMemoryUpdate(callback: (memoryInfo: MemoryInfo) => void) {
    this.callbacks.push(callback)
    
    return () => {
      const index = this.callbacks.indexOf(callback)
      if (index > -1) {
        this.callbacks.splice(index, 1)
      }
    }
  }
  
  private emitMemoryWarning(memoryInfo: MemoryInfo) {
    const event = new CustomEvent('memory-warning', { detail: memoryInfo })
    window.dispatchEvent(event)
  }
  
  getCurrentMemoryInfo(): MemoryInfo | null {
    if ('memory' in performance) {
      return (performance as any).memory as MemoryInfo
    }
    return null
  }
}

// 자동 메모리 정리 훅
export const useMemoryCleanup = () => {
  const cleanupTasks = useRef<(() => void)[]>([])
  
  const addCleanupTask = useCallback((task: () => void) => {
    cleanupTasks.current.push(task)
  }, [])
  
  const runCleanup = useCallback(() => {
    cleanupTasks.current.forEach(task => {
      try {
        task()
      } catch (error) {
        console.error('Cleanup task failed:', error)
      }
    })
    cleanupTasks.current = []
  }, [])
  
  useEffect(() => {
    return runCleanup
  }, [runCleanup])
  
  return { addCleanupTask, runCleanup }
}

// 메모리 리크 감지
export const useMemoryLeakDetector = (componentName: string) => {
  const mountTime = useRef(Date.now())
  const initialMemory = useRef<number>(0)
  
  useEffect(() => {
    if ('memory' in performance) {
      const memoryInfo = (performance as any).memory as MemoryInfo
      initialMemory.current = memoryInfo.usedJSHeapSize
    }
    
    return () => {
      if ('memory' in performance) {
        const memoryInfo = (performance as any).memory as MemoryInfo
        const memoryDiff = memoryInfo.usedJSHeapSize - initialMemory.current
        const lifetimeMs = Date.now() - mountTime.current
        
        // 컴포넌트가 1MB 이상의 메모리를 지속적으로 사용하고 있다면 경고
        if (memoryDiff > 1024 * 1024 && lifetimeMs > 10000) {
          console.warn(
            `Potential memory leak in ${componentName}: +${(memoryDiff / (1024 * 1024)).toFixed(2)}MB over ${lifetimeMs}ms`
          )
        }
      }
    }
  }, [componentName])
}

// 대용량 데이터 청크 처리
export class DataChunkProcessor {
  static processInChunks<T, R>(
    data: T[],
    processor: (chunk: T[]) => R[],
    chunkSize = 1000,
    delay = 0
  ): Promise<R[]> {
    return new Promise((resolve) => {
      const results: R[] = []
      let index = 0
      
      const processChunk = () => {
        const chunk = data.slice(index, index + chunkSize)
        if (chunk.length === 0) {
          resolve(results)
          return
        }
        
        try {
          const chunkResults = processor(chunk)
          results.push(...chunkResults)
        } catch (error) {
          console.error('Chunk processing error:', error)
        }
        
        index += chunkSize
        
        if (delay > 0) {
          setTimeout(processChunk, delay)
        } else {
          // 다음 프레임에서 처리하여 UI 블로킹 방지
          requestAnimationFrame(processChunk)
        }
      }
      
      processChunk()
    })
  }
}

// 메모리 효율적인 이벤트 매니저
export class MemoryEfficientEventManager {
  private listeners = new WeakMap<EventTarget, Map<string, Set<EventListener>>>()
  
  addEventListener(
    target: EventTarget,
    type: string,
    listener: EventListener,
    options?: AddEventListenerOptions
  ) {
    if (!this.listeners.has(target)) {
      this.listeners.set(target, new Map())
    }
    
    const targetListeners = this.listeners.get(target)!
    
    if (!targetListeners.has(type)) {
      targetListeners.set(type, new Set())
    }
    
    targetListeners.get(type)!.add(listener)
    target.addEventListener(type, listener, options)
  }
  
  removeEventListener(target: EventTarget, type: string, listener: EventListener) {
    const targetListeners = this.listeners.get(target)
    if (!targetListeners) return
    
    const typeListeners = targetListeners.get(type)
    if (!typeListeners) return
    
    typeListeners.delete(listener)
    target.removeEventListener(type, listener)
    
    if (typeListeners.size === 0) {
      targetListeners.delete(type)
    }
    
    if (targetListeners.size === 0) {
      this.listeners.delete(target)
    }
  }
  
  removeAllListeners(target: EventTarget) {
    const targetListeners = this.listeners.get(target)
    if (!targetListeners) return
    
    for (const [type, listeners] of targetListeners) {
      for (const listener of listeners) {
        target.removeEventListener(type, listener)
      }
    }
    
    this.listeners.delete(target)
  }
}
```

### 5. 성능 프로파일링 도구

**주요 파일**: `src/components/dev/PerformanceProfiler.tsx`

```typescript
// src/components/dev/PerformanceProfiler.tsx
import React, { useState, useEffect } from 'react'
import { WebVitalsMonitor } from '@/lib/performance/web-vitals'
import { MemoryMonitor } from '@/lib/performance/memory-optimization'

interface PerformanceData {
  webVitals: {
    lcp?: number
    fid?: number
    cls?: number
    fcp?: number
    tti?: number
  }
  memory?: MemoryInfo
  renderTime?: number
  componentCounts?: Record<string, number>
}

export const PerformanceProfiler: React.FC = () => {
  const [performanceData, setPerformanceData] = useState<PerformanceData>({
    webVitals: {},
  })
  const [isVisible, setIsVisible] = useState(false)
  
  useEffect(() => {
    if (process.env.NODE_ENV !== 'development') return
    
    // Web Vitals 모니터링
    WebVitalsMonitor.onMetric((metric, value) => {
      setPerformanceData(prev => ({
        ...prev,
        webVitals: {
          ...prev.webVitals,
          [metric]: value,
        },
      }))
    })
    
    // 메모리 모니터링
    const memoryMonitor = MemoryMonitor.getInstance()
    const unsubscribeMemory = memoryMonitor.onMemoryUpdate((memoryInfo) => {
      setPerformanceData(prev => ({
        ...prev,
        memory: memoryInfo,
      }))
    })
    
    memoryMonitor.startMonitoring()
    
    // 키보드 단축키로 프로파일러 토글
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.ctrlKey && event.shiftKey && event.key === 'P') {
        setIsVisible(prev => !prev)
      }
    }
    
    window.addEventListener('keydown', handleKeyPress)
    
    return () => {
      unsubscribeMemory()
      memoryMonitor.stopMonitoring()
      window.removeEventListener('keydown', handleKeyPress)
    }
  }, [])
  
  if (!isVisible || process.env.NODE_ENV !== 'development') {
    return null
  }
  
  const { webVitals, memory } = performanceData
  const score = WebVitalsMonitor.getScore()
  
  return (
    <div className="fixed bottom-4 right-4 bg-card border border-border rounded-lg shadow-lg p-4 max-w-sm z-50">
      <div className="flex items-center justify-between mb-3">
        <h3 className="font-semibold text-sm">Performance Monitor</h3>
        <div className={`px-2 py-1 rounded text-xs font-bold ${
          score.grade === 'A' ? 'bg-green-100 text-green-800' :
          score.grade === 'B' ? 'bg-blue-100 text-blue-800' :
          score.grade === 'C' ? 'bg-yellow-100 text-yellow-800' :
          'bg-red-100 text-red-800'
        }`}>
          {score.grade} ({score.score})
        </div>
      </div>
      
      {/* Web Vitals */}
      <div className="space-y-2 mb-4">
        <h4 className="text-xs font-medium text-muted-foreground">Core Web Vitals</h4>
        {Object.entries(webVitals).map(([metric, value]) => (
          <div key={metric} className="flex justify-between text-xs">
            <span className="font-mono uppercase">{metric}:</span>
            <span className={`font-mono ${
              metric === 'lcp' && value > 2500 ? 'text-red-600' :
              metric === 'fid' && value > 100 ? 'text-red-600' :
              metric === 'cls' && value > 0.1 ? 'text-red-600' :
              metric === 'fcp' && value > 1800 ? 'text-red-600' :
              metric === 'tti' && value > 3800 ? 'text-red-600' :
              'text-green-600'
            }`}>
              {metric === 'cls' ? value?.toFixed(3) : `${value?.toFixed(0)}ms`}
            </span>
          </div>
        ))}
      </div>
      
      {/* Memory Usage */}
      {memory && (
        <div className="space-y-2 mb-4">
          <h4 className="text-xs font-medium text-muted-foreground">Memory Usage</h4>
          <div className="flex justify-between text-xs">
            <span>Used:</span>
            <span className="font-mono">
              {(memory.usedJSHeapSize / (1024 * 1024)).toFixed(1)}MB
            </span>
          </div>
          <div className="flex justify-between text-xs">
            <span>Total:</span>
            <span className="font-mono">
              {(memory.totalJSHeapSize / (1024 * 1024)).toFixed(1)}MB
            </span>
          </div>
          <div className="w-full bg-muted rounded-full h-2">
            <div
              className="bg-primary rounded-full h-2 transition-all duration-300"
              style={{
                width: `${(memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100}%`
              }}
            />
          </div>
        </div>
      )}
      
      {/* Actions */}
      <div className="flex space-x-2">
        <button
          onClick={() => {
            if ('gc' in window) {
              (window as any).gc()
            } else {
              console.log('Manual GC not available')
            }
          }}
          className="px-2 py-1 bg-muted hover:bg-accent rounded text-xs"
        >
          GC
        </button>
        <button
          onClick={() => {
            const report = WebVitalsMonitor.getMetrics()
            console.table(report)
          }}
          className="px-2 py-1 bg-muted hover:bg-accent rounded text-xs"
        >
          Log
        </button>
        <button
          onClick={() => setIsVisible(false)}
          className="px-2 py-1 bg-muted hover:bg-accent rounded text-xs"
        >
          Hide
        </button>
      </div>
      
      <div className="mt-2 text-xs text-muted-foreground">
        Press Ctrl+Shift+P to toggle
      </div>
    </div>
  )
}

// React DevTools Profiler 통합
export const withProfiler = <P extends object>(
  Component: React.ComponentType<P>,
  id?: string
) => {
  const WrappedComponent = (props: P) => {
    const componentId = id || Component.displayName || Component.name || 'Anonymous'
    
    const handleRender = useCallback(
      (id: string, phase: 'mount' | 'update', actualDuration: number) => {
        if (process.env.NODE_ENV === 'development') {
          console.log(`[Profiler] ${id} (${phase}): ${actualDuration.toFixed(2)}ms`)
        }
        
        // 성능 메트릭 수집
        if (actualDuration > 16) { // 60fps 기준
          console.warn(`[Performance] Slow render: ${id} took ${actualDuration.toFixed(2)}ms`)
        }
      },
      []
    )
    
    return (
      <React.Profiler id={componentId} onRender={handleRender}>
        <Component {...props} />
      </React.Profiler>
    )
  }
  
  WrappedComponent.displayName = `withProfiler(${Component.displayName || Component.name})`
  
  return WrappedComponent
}
```

---

## 🎨 UX 디자인 고려사항

### 성능 체감 최적화
- **스켈레톤 로딩**: 실제 콘텐츠 구조와 유사한 스켈레톤으로 로딩 인식 개선
- **프로그레시브 로딩**: 중요한 콘텐츠부터 점진적 로딩
- **낙관적 업데이트**: 사용자 액션에 즉시 반응하는 UI 업데이트

### 성능 저하 시 대응
- **성능 경고 표시**: 개발 환경에서 성능 문제 실시간 알림
- **자동 최적화**: 메모리 사용량 높을 때 자동 가비지 컬렉션 제안
- **사용자 피드백**: 성능 문제 발생 시 사용자에게 친화적 안내

### 접근성 고려
- **스크린 리더**: 가상 스크롤링에서도 접근성 유지
- **키보드 네비게이션**: 모든 최적화된 컴포넌트에서 키보드 접근성 보장
- **모션 설정 준수**: prefers-reduced-motion에 따른 애니메이션 조절

---

## ⚡ 성능 최적화

### 렌더링 성능
- **React.memo**: 불필요한 리렌더링 방지
- **useMemo/useCallback**: 값비싼 계산 및 함수 메모이제이션
- **코드 스플리팅**: 라우트 및 컴포넌트 단위 지연 로딩

### 메모리 관리
- **가상 스크롤링**: DOM 노드 수 최소화로 메모리 사용량 감소
- **자동 정리**: 컴포넌트 언마운트 시 이벤트 리스너 및 타이머 정리
- **WeakMap 활용**: 가비지 컬렉션 친화적 데이터 구조 사용

### 네트워크 최적화
- **지능적 프리로딩**: 사용자 행동 패턴 기반 컴포넌트 미리 로딩
- **요청 중복 제거**: 동일한 API 요청 캐싱 및 중복 방지
- **배치 처리**: 여러 요청을 배치로 묶어서 네트워크 오버헤드 감소

---

## 🧪 Definition of Done

### Core Web Vitals 달성 요구사항
- [ ] LCP (Largest Contentful Paint) < 2.5초
- [ ] FID (First Input Delay) < 100ms
- [ ] CLS (Cumulative Layout Shift) < 0.1
- [ ] FCP (First Contentful Paint) < 1.8초
- [ ] TTI (Time to Interactive) < 3.8초

### 응답성 성능 요구사항
- [ ] 캘린더 뷰 전환 시간 < 150ms
- [ ] 사용자 인터랙션 응답 시간 < 100ms
- [ ] 모든 애니메이션 60fps 유지
- [ ] 스크롤 성능 최적화 (jank 0개)

### 메모리 효율성 요구사항
- [ ] 1000+ 이벤트 렌더링 시 메모리 사용량 < 50MB 증가
- [ ] 메모리 누수 0건 (24시간 사용 테스트)
- [ ] 가상 스크롤링으로 DOM 노드 수 < 100개 유지
- [ ] 컴포넌트 언마운트 시 완전한 리소스 정리

### 모니터링 및 분석 요구사항
- [ ] 실시간 Web Vitals 모니터링 구현
- [ ] 성능 경고 시스템 (임계치 초과 시 알림)
- [ ] 메모리 사용량 추적 및 누수 감지
- [ ] 개발 환경 성능 프로파일러 도구

### 코드 품질 요구사항
- [ ] 모든 최적화 코드의 TypeScript 타입 안전성
- [ ] Jest 성능 테스트 커버리지 > 80%
- [ ] 성능 회귀 방지를 위한 벤치마크 테스트
- [ ] 코드 스플리팅 및 지연 로딩 에러 핸들링

---

## 📚 관련 문서

- [08-runtime-performance.md](../ui-architecture/08-runtime-performance.md) - 런타임 성능 아키텍처
- [Story 2.18: Build & Bundle Optimization](./2.18.build-bundle-optimization.md) - 빌드 최적화
- [Story 2.5: Performance Optimization](./2.5.performance-optimization.md) - 기존 성능 최적화
- [Story 2.12: Observability & Monitoring](./2.12.observability-monitoring.md) - 모니터링 시스템

---

## 📈 성공 지표

### 성능 지표
- **Core Web Vitals 점수**: 모든 지표 Good 등급 달성 (95th percentile)
- **Lighthouse 성능 점수**: > 90점 유지
- **사용자 체감 로딩 속도**: 평균 초기 로딩 시간 < 3초
- **인터랙션 지연**: 평균 응답 시간 < 50ms

### 사용자 경험 지표
- **이탈률 감소**: 로딩 시간 개선으로 이탈률 20% 감소
- **사용자 만족도**: 성능 관련 사용자 불만 < 5%
- **재방문율**: 빠른 성능으로 재방문율 15% 증가
- **모바일 사용성**: 모바일에서 성능 저하 < 10%

### 기술적 지표
- **메모리 효율성**: 장시간 사용 시 메모리 사용량 증가 < 10MB/hour
- **CPU 사용률**: 평균 CPU 사용률 < 20%
- **배터리 소모**: 모바일 디바이스 배터리 영향도 최소화
- **에러율**: 성능 최적화 관련 에러 < 0.1%

### 개발 생산성 지표
- **성능 디버깅 시간**: 성능 문제 식별 및 해결 시간 50% 단축
- **개발 환경 성능**: 로컬 개발 서버 응답 시간 < 500ms
- **빌드 시간**: 성능 최적화 적용 후에도 빌드 시간 증가 < 20%
- **테스트 실행 시간**: 성능 테스트 포함 전체 테스트 시간 < 5분