# Story 2.12: Observability & Monitoring Implementation

## 📋 문서 정보
- **문서 버전**: 1.0
- **작성일**: 2025-08-28
- **작성자**: Frontend Team
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **상태**: Active
- **관련 아키텍처 문서**: [21-observability-monitoring.md](../ui-architecture/21-observability-monitoring.md)

---

## 🎯 스토리 목표

바로캘린더 애플리케이션의 **실시간 관찰성(Observability) 및 모니터링 시스템**을 구현하여 사용자 경험을 지속적으로 모니터링하고 성능 문제를 사전에 감지할 수 있도록 한다.

### 주요 구현 사항
- **Sentry 기반 에러 추적** 및 성능 모니터링
- **Core Web Vitals** 및 커스텀 메트릭 수집
- **사용자 행동 분석** 및 실시간 추적
- **알림 시스템** 구현으로 임계치 초과 시 자동 대응

---

## 👤 사용자 스토리

### US 2.12.1: 실시간 에러 추적
**As a** 개발팀  
**I want** 애플리케이션에서 발생하는 모든 에러를 실시간으로 추적하고 분석할 수 있기를  
**So that** 사용자가 경험하는 문제를 빠르게 파악하고 해결할 수 있다.

**인수 조건:**
- [ ] Sentry SDK 통합으로 JavaScript 에러 자동 수집
- [ ] GraphQL 에러 및 네트워크 에러 상세 추적
- [ ] 민감한 정보 필터링으로 보안 유지
- [ ] 에러 발생 시 사용자 컨텍스트 정보 포함

### US 2.12.2: 성능 메트릭 모니터링
**As a** 개발팀  
**I want** Core Web Vitals 및 바로캘린더 특화 성능 메트릭을 실시간으로 모니터링하기를  
**So that** 사용자 경험에 영향을 주는 성능 문제를 사전에 감지하고 개선할 수 있다.

**인수 조건:**
- [ ] LCP, FID, CLS, FCP, TTI 자동 측정 및 수집
- [ ] 캘린더 뷰 전환 시간 측정
- [ ] 이벤트 로딩 및 프로젝트 필터링 성능 추적
- [ ] 성능 임계치 초과 시 자동 알림 발송

### US 2.12.3: 사용자 행동 분석
**As a** 제품팀  
**I want** 사용자가 바로캘린더를 어떻게 사용하는지 상세한 행동 패턴을 분석하기를  
**So that** 사용자 경험을 개선하고 제품 발전 방향을 결정할 수 있다.

**인수 조건:**
- [ ] 사용자 액션별 이벤트 추적 (캘린더, 프로젝트, 이벤트 관련)
- [ ] Google Analytics 4 및 내부 분석 서버 연동
- [ ] 세션별 사용자 여정 추적
- [ ] 개인정보 보호를 위한 데이터 익명화

---

## 🔧 기술적 구현 요구사항

### 1. Sentry 에러 추적 시스템

**주요 파일**: `src/lib/monitoring/sentry.ts`

```typescript
// src/lib/monitoring/sentry.ts
import * as Sentry from '@sentry/nextjs'
import { User } from '@/types/user'

export const initializeSentry = () => {
  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    environment: process.env.NODE_ENV,
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
    integrations: [
      new Sentry.BrowserTracing({
        tracePropagationTargets: [
          'localhost', 
          'barocalendar.com',
          /^https:\/\/api\.barocalendar\.com/,
        ],
      }),
    ],
    beforeSend(event, hint) {
      // 개발 환경에서는 콘솔에 로그 출력
      if (process.env.NODE_ENV === 'development') {
        console.error('Sentry Error:', event, hint)
      }
      
      // 민감한 정보 필터링
      if (event.request?.headers) {
        delete event.request.headers['authorization']
        delete event.request.headers['cookie']
      }
      
      // PII 데이터 필터링
      if (event.exception) {
        event.exception.values?.forEach(exception => {
          if (exception.stacktrace?.frames) {
            exception.stacktrace.frames = exception.stacktrace.frames.filter(
              frame => !frame.filename?.includes('node_modules')
            )
          }
        })
      }
      
      return event
    },
  })
}

// GraphQL 에러 상세 추적
export const trackGraphQLError = (error: any, operation: any) => {
  Sentry.captureException(error, {
    tags: {
      type: 'graphql',
      operation: operation.operationName,
      errorType: error.networkError ? 'network' : 'graphql',
    },
    extra: {
      variables: operation.variables,
      query: operation.query.loc?.source.body,
      networkError: error.networkError,
      graphQLErrors: error.graphQLErrors,
    },
    contexts: {
      apollo: {
        operationName: operation.operationName,
        operationType: operation.query.definitions[0]?.operation,
      },
    },
  })
}

// 사용자 컨텍스트 설정
export const setUserContext = (user: User) => {
  Sentry.setUser({
    id: user.id,
    email: user.email,
    username: user.name,
  })
  
  Sentry.setContext('user_preferences', {
    timezone: user.timezone,
    defaultView: user.defaultCalendarView,
    theme: user.theme,
  })
}

// 커스텀 에러 추적
export const trackCustomError = (
  errorName: string, 
  errorData: any, 
  level: 'error' | 'warning' | 'info' = 'error'
) => {
  Sentry.captureMessage(errorName, level)
  
  Sentry.addBreadcrumb({
    category: 'custom-error',
    message: errorName,
    data: errorData,
    level: level === 'error' ? 'error' : level === 'warning' ? 'warning' : 'info',
  })
}
```

### 2. 성능 메트릭 모니터링 시스템

**주요 파일**: `src/lib/monitoring/performance.ts`

```typescript
// src/lib/monitoring/performance.ts
import * as Sentry from '@sentry/nextjs'

interface PerformanceMetric {
  name: string
  value: number
  timestamp: number
  url: string
  userAgent: string
}

export class PerformanceMonitor {
  private static metrics: Map<string, PerformanceMetric[]> = new Map()
  private static initialized = false
  
  static initialize() {
    if (this.initialized) return
    this.initialized = true
    
    // Core Web Vitals 모니터링
    this.observeLCP()
    this.observeFID()
    this.observeCLS()
    this.observeFCP()
    this.observeTTI()
    
    // 바로캘린더 특화 메트릭
    this.observeCalendarMetrics()
    
    // 정기적으로 메트릭 전송
    setInterval(() => {
      this.sendBatchMetrics()
    }, 30000) // 30초마다
  }
  
  private static observeLCP() {
    new PerformanceObserver((list) => {
      list.getEntries().forEach((entry: any) => {
        this.recordMetric('lcp', entry.value)
      })
    }).observe({ type: 'largest-contentful-paint', buffered: true })
  }
  
  private static observeFID() {
    new PerformanceObserver((list) => {
      list.getEntries().forEach((entry: any) => {
        this.recordMetric('fid', entry.processingStart - entry.startTime)
      })
    }).observe({ type: 'first-input', buffered: true })
  }
  
  private static observeCLS() {
    let clsValue = 0
    let clsEntries: any[] = []
    
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!(entry as any).hadRecentInput) {
          const firstSessionEntry = clsEntries[0]
          const lastSessionEntry = clsEntries[clsEntries.length - 1]
          
          if (!firstSessionEntry || 
              entry.startTime - lastSessionEntry.startTime > 1000 ||
              entry.startTime - firstSessionEntry.startTime > 5000) {
            clsEntries = [(entry as any)]
            clsValue = (entry as any).value
          } else {
            clsEntries.push(entry as any)
            clsValue += (entry as any).value
          }
        }
      }
      
      this.recordMetric('cls', clsValue)
    }).observe({ type: 'layout-shift', buffered: true })
  }
  
  private static observeCalendarMetrics() {
    // 캘린더 뷰 전환 성능 측정
    this.measureViewTransition()
    
    // 이벤트 로딩 성능 측정
    this.measureEventLoading()
    
    // 프로젝트 필터링 성능 측정
    this.measureProjectFiltering()
  }
  
  static startTiming(name: string): () => void {
    const startTime = performance.now()
    
    return () => {
      const duration = performance.now() - startTime
      this.recordMetric(name, duration)
    }
  }
  
  private static measureViewTransition() {
    // Zustand store 구독으로 뷰 전환 감지
    let transitionStart: number | null = null
    
    const unsubscribe = useCalendarStore.subscribe(
      (state) => state.currentView,
      () => {
        if (transitionStart) {
          const duration = performance.now() - transitionStart
          this.recordMetric('view-transition', duration)
          transitionStart = null
        }
      }
    )
    
    // 뷰 전환 시작 시점 기록
    const originalDispatch = useCalendarStore.getState().setCurrentView
    useCalendarStore.setState({
      setCurrentView: (view: CalendarView) => {
        transitionStart = performance.now()
        originalDispatch(view)
      }
    })
  }
  
  static recordMetric(name: string, value: number) {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
    }
    
    if (!this.metrics.has(name)) {
      this.metrics.set(name, [])
    }
    
    this.metrics.get(name)!.push(metric)
    
    // 임계치 체크 및 알림
    this.checkThreshold(name, value)
    
    // Sentry로 실시간 메트릭 전송
    this.sendMetricToSentry(name, value)
  }
  
  private static checkThreshold(name: string, value: number) {
    const thresholds: Record<string, number> = {
      'lcp': 2500,
      'fid': 100,
      'cls': 0.1,
      'fcp': 1800,
      'tti': 3800,
      'view-transition': 150,
      'event-loading': 1000,
      'project-filtering': 500,
    }
    
    const threshold = thresholds[name]
    if (threshold && value > threshold) {
      this.emitPerformanceWarning(name, value, threshold)
    }
  }
  
  private static emitPerformanceWarning(
    metric: string, 
    value: number, 
    threshold: number
  ) {
    // Slack 알림 전송
    this.sendSlackAlert(metric, value, threshold)
    
    // Sentry에 성능 이슈 리포트
    Sentry.captureMessage(
      `Performance threshold exceeded: ${metric}`,
      {
        level: 'warning',
        tags: { type: 'performance' },
        extra: { metric, value, threshold },
      }
    )
  }
  
  private static async sendSlackAlert(
    metric: string, 
    value: number, 
    threshold: number
  ) {
    try {
      await fetch('/api/monitoring/alerts/slack', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          channel: '#performance-alerts',
          text: `🚨 바로캘린더 성능 임계치 초과`,
          attachments: [{
            color: 'danger',
            fields: [
              { title: 'Metric', value: metric, short: true },
              { title: 'Value', value: `${value.toFixed(2)}ms`, short: true },
              { title: 'Threshold', value: `${threshold}ms`, short: true },
              { title: 'URL', value: window.location.href, short: false },
            ],
            ts: Math.floor(Date.now() / 1000),
          }],
        }),
      })
    } catch (error) {
      console.error('Failed to send Slack alert:', error)
    }
  }
  
  private static sendMetricToSentry(name: string, value: number) {
    Sentry.addBreadcrumb({
      category: 'performance',
      message: `${name}: ${value}ms`,
      data: { metric: name, value },
      level: 'info',
    })
  }
  
  private static sendBatchMetrics() {
    const allMetrics = Array.from(this.metrics.entries()).reduce(
      (acc, [name, metrics]) => {
        acc[name] = metrics.splice(0) // 배열 비우면서 가져오기
        return acc
      },
      {} as Record<string, PerformanceMetric[]>
    )
    
    // 내부 분석 서버로 배치 전송
    this.sendToAnalyticsServer(allMetrics)
  }
}
```

### 3. 사용자 행동 분석 시스템

**주요 파일**: `src/lib/monitoring/analytics.ts`

```typescript
// src/lib/monitoring/analytics.ts
import * as Sentry from '@sentry/nextjs'
import { useCalendarStore } from '@/stores/useCalendarStore'
import { useProjectStore } from '@/stores/useProjectStore'

interface AnalyticsEvent {
  category: string
  action: string
  label?: string
  value?: number
  timestamp: number
  sessionId: string
  userId?: string
  url: string
  referrer: string
}

export class UserAnalytics {
  private static sessionId: string = this.generateSessionId()
  private static eventQueue: AnalyticsEvent[] = []
  
  static initialize() {
    // Google Analytics 4 초기화
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('config', process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID, {
        page_title: 'Baro Calendar',
        page_location: window.location.href,
      })
    }
    
    // 이벤트 큐 정기 전송
    setInterval(() => {
      this.flushEventQueue()
    }, 10000) // 10초마다
  }
  
  static trackEvent(
    category: string, 
    action: string, 
    label?: string, 
    value?: number
  ) {
    const event: AnalyticsEvent = {
      category,
      action,
      label,
      value,
      timestamp: Date.now(),
      sessionId: this.sessionId,
      userId: this.getCurrentUserId(),
      url: window.location.href,
      referrer: document.referrer,
    }
    
    // Google Analytics 4
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', action, {
        event_category: category,
        event_label: label,
        value: value,
        custom_parameter_1: this.sessionId,
      })
    }
    
    // Sentry Breadcrumb
    Sentry.addBreadcrumb({
      category: 'user-analytics',
      message: `${category}: ${action}`,
      data: { label, value, sessionId: this.sessionId },
      level: 'info',
    })
    
    // 내부 분석을 위한 큐에 추가
    this.eventQueue.push(event)
  }
  
  // 캘린더 특화 액션 추적
  static trackCalendarAction(action: string, data?: Record<string, any>) {
    const calendarState = useCalendarStore.getState()
    const projectState = useProjectStore.getState()
    
    const context = {
      currentView: calendarState.currentView,
      currentDate: calendarState.currentDate?.toISOString(),
      selectedProjects: projectState.selectedProjects.length,
      totalEvents: calendarState.events.length,
      ...data,
    }
    
    this.trackEvent('calendar', action, JSON.stringify(context))
    
    // 상세한 캘린더 컨텍스트 정보
    Sentry.addBreadcrumb({
      category: 'calendar-action',
      message: action,
      data: context,
      level: 'info',
    })
    
    // 캘린더 특화 메트릭
    this.trackCalendarMetrics(action, context)
  }
  
  // 프로젝트 관련 액션 추적
  static trackProjectAction(
    action: string, 
    projectId?: string, 
    projectData?: Record<string, any>
  ) {
    this.trackEvent('project', action, projectId)
    
    if (projectId) {
      const context = {
        projectId,
        ...projectData,
      }
      
      Sentry.addBreadcrumb({
        category: 'project-action',
        message: action,
        data: context,
        level: 'info',
      })
    }
  }
  
  // 사용자 여정 추적
  static trackUserJourney(step: string, data?: Record<string, any>) {
    this.trackEvent('user-journey', step, undefined, undefined)
    
    Sentry.addBreadcrumb({
      category: 'user-journey',
      message: step,
      data: {
        step,
        sessionDuration: this.getSessionDuration(),
        pageViews: this.getPageViewCount(),
        ...data,
      },
      level: 'info',
    })
  }
  
  private static trackCalendarMetrics(action: string, context: any) {
    // 캘린더 사용 패턴 분석을 위한 메트릭
    const metrics = {
      viewSwitches: this.getMetricCount('view-switch'),
      eventCreations: this.getMetricCount('event-create'),
      projectFilters: this.getMetricCount('project-filter'),
      dateNavigations: this.getMetricCount('date-navigation'),
    }
    
    // 내부 분석 서버로 메트릭 전송
    this.sendToAnalyticsServer('calendar-metrics', {
      action,
      context,
      metrics,
      timestamp: Date.now(),
    })
  }
  
  private static async flushEventQueue() {
    if (this.eventQueue.length === 0) return
    
    const events = this.eventQueue.splice(0) // 큐 비우기
    
    try {
      await fetch('/api/analytics/events/batch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          events,
          timestamp: Date.now(),
        }),
      })
    } catch (error) {
      console.error('Failed to send analytics events:', error)
      
      // 실패한 이벤트를 다시 큐에 추가 (최대 재시도 제한)
      if (events.length < 1000) {
        this.eventQueue.unshift(...events)
      }
    }
  }
  
  private static generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
  
  private static getCurrentUserId(): string | undefined {
    // 실제 사용자 인증 시스템과 연동
    const user = useAuthStore?.getState?.()?.user
    return user?.id
  }
  
  private static getSessionDuration(): number {
    const sessionStart = parseInt(this.sessionId.split('_')[1])
    return Date.now() - sessionStart
  }
}
```

---

## 🎨 UX 디자인 고려사항

### 성능 모니터링 대시보드
- **개발자 도구 패널**: 개발 환경에서 실시간 성능 메트릭 표시
- **성능 경고 토스트**: 사용자에게 영향을 주지 않는 선에서 성능 이슈 알림
- **오프라인 상태 처리**: 네트워크 연결 복원 시 누적된 메트릭 일괄 전송

### 에러 리포팅 UX
- **사용자 친화적 에러 메시지**: 기술적 에러를 사용자가 이해할 수 있는 언어로 변환
- **에러 복구 가이드**: 사용자가 자체적으로 문제를 해결할 수 있는 가이드 제공
- **피드백 수집**: 에러 발생 시 사용자 피드백 수집 옵션 제공

---

## ⚡ 성능 최적화

### 모니터링 오버헤드 최소화
- **배치 전송**: 개별 이벤트 대신 배치로 분석 데이터 전송
- **샘플링 전략**: 프로덕션에서는 적절한 샘플링 비율로 성능 영향 최소화
- **지연 로딩**: 모니터링 스크립트의 지연 로딩으로 초기 로딩 성능 개선

### 메모리 관리
- **메트릭 큐 크기 제한**: 메모리 사용량 제한을 위한 큐 크기 관리
- **자동 정리**: 오래된 메트릭 데이터 자동 정리
- **WeakMap 활용**: 가비지 컬렉션 최적화를 위한 WeakMap 사용

---

## 🧪 Definition of Done

### 기능적 요구사항
- [ ] Sentry SDK 통합 및 에러 자동 수집 구현
- [ ] Core Web Vitals (LCP, FID, CLS, FCP, TTI) 자동 측정
- [ ] 캘린더 특화 성능 메트릭 (뷰 전환, 이벤트 로딩, 필터링) 수집
- [ ] 사용자 행동 분석 시스템 (Google Analytics 4 + 내부 서버)
- [ ] 성능 임계치 초과 시 Slack 알림 발송
- [ ] GraphQL 에러 상세 추적 및 컨텍스트 정보 포함

### 기술적 요구사항
- [ ] TypeScript 타입 안전성 100% 보장
- [ ] 모니터링 시스템 성능 오버헤드 < 5ms
- [ ] 민감한 정보 필터링 로직 적용
- [ ] 에러 발생 시 사용자 컨텍스트 정보 자동 첨부
- [ ] 오프라인 상태에서의 메트릭 큐잉 및 배치 전송

### 품질 요구사항
- [ ] Jest 단위 테스트 커버리지 > 80%
- [ ] Playwright E2E 테스트로 모니터링 플로우 검증
- [ ] 성능 벤치마크 테스트 통과
- [ ] 개인정보 보호 규정 준수 확인
- [ ] 프로덕션 환경 모니터링 대시보드 구축

### 사용자 경험 요구사항
- [ ] 모니터링으로 인한 사용자 경험 영향도 < 1%
- [ ] 에러 발생 시 사용자 친화적 메시지 표시
- [ ] 개발 환경에서의 실시간 성능 메트릭 시각화
- [ ] 접근성 표준 (WCAG 2.1 AA) 준수

---

## 📚 관련 문서

- [21-observability-monitoring.md](../ui-architecture/21-observability-monitoring.md) - 모니터링 아키텍처
- [Story 2.8: Error Handling & Recovery](./2.8.error-handling-recovery.md) - 에러 처리 시스템
- [Story 2.9: CI/CD Pipeline Setup](./2.9.cicd-pipeline-setup.md) - 배포 및 모니터링 통합
- [Story 2.10: Security Best Practices](./2.10.security-best-practices.md) - 보안 모니터링

---

## 📈 성공 지표

### 기술적 지표
- **에러 감지율**: 99% 이상의 JavaScript 에러 자동 감지
- **성능 메트릭 수집율**: Core Web Vitals 100% 수집
- **알림 응답시간**: 임계치 초과 후 3분 이내 알림 발송
- **데이터 정확도**: 95% 이상의 분석 데이터 정확도

### 비즈니스 지표
- **문제 해결 시간**: 평균 MTTR (Mean Time To Resolution) 50% 단축
- **사용자 만족도**: 모니터링 개선 후 사용자 만족도 20% 향상
- **성능 개선**: Core Web Vitals 점수 15% 향상
- **개발 생산성**: 버그 재현 시간 70% 단축