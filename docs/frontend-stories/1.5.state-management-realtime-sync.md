# Story 1.5: 상태 관리 및 실시간 동기화 시스템

## 📋 문서 정보
- **스토리 버전**: 2.0
- **작성일**: 2025-08-27
- **작성자**: Bob (Scrum Master Agent)
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **Epic**: 프론트엔드 핵심 기능 구현
- **상태**: Ready for Development

---

## 🎯 **스토리 목표**

**완전한 상태 관리 및 실시간 동기화 시스템**
- Apollo Client + Zustand 통합 하이브리드 상태 관리
- WebSocket 기반 실시간 협업 시스템
- 낙관적 업데이트 및 충돌 해결
- 오프라인 지원 및 자동 동기화
- 성능 최적화 및 메모리 관리

---

## 👤 **사용자 스토리**

**팀 협업자로서, 나는:**
1. 다른 팀원의 일정 변경사항을 실시간으로 확인하고 싶다
2. 오프라인에서도 일정을 수정하고 온라인 시 자동 동기화되길 바란다
3. 동시 편집 시 충돌을 자동으로 해결하거나 선택할 수 있기를 바란다
4. 빠른 응답성을 위해 즉시 UI가 업데이트되길 바란다
5. 네트워크 연결이 불안정해도 안정적으로 사용하고 싶다

---

## 🏗️ **기술적 구현 요구사항**

### **1. Apollo Client + Zustand 하이브리드 아키텍처**

**Apollo Client 설정 및 캐시 전략**
```typescript
// src/lib/apollo/client.ts
import { ApolloClient, InMemoryCache, createHttpLink, split } from '@apollo/client'
import { getMainDefinition } from '@apollo/client/utilities'
import { GraphQLWsLink } from '@apollo/client/link/subscriptions'
import { createClient } from 'graphql-ws'
import { setContext } from '@apollo/client/link/context'

// HTTP Link 설정
const httpLink = createHttpLink({
  uri: process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT,
  credentials: 'include'
})

// WebSocket Link 설정
const wsLink = new GraphQLWsLink(
  createClient({
    url: process.env.NEXT_PUBLIC_GRAPHQL_WS_ENDPOINT!,
    connectionParams: () => ({
      authorization: `Bearer ${getAuthToken()}`,
    }),
    on: {
      connected: () => console.log('WebSocket connected'),
      error: (error) => console.error('WebSocket error:', error),
    },
  })
)

// 인증 링크
const authLink = setContext((_, { headers }) => {
  const token = getAuthToken()
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : "",
    }
  }
})

// 쿼리는 HTTP, 구독은 WebSocket 사용
const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query)
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    )
  },
  wsLink,
  authLink.concat(httpLink)
)

// InMemoryCache 설정
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        // 프로젝트 캐시 병합 정책
        projects: {
          merge(existing = [], incoming) {
            return incoming
          }
        },
        // 스케줄 캐시 병합 정책
        schedules: {
          keyArgs: ['dateRange', 'projectIds'],
          merge(existing = [], incoming, { args, readField }) {
            const merged = new Map()
            
            // 기존 데이터 추가
            existing.forEach((schedule: any) => {
              const id = readField('id', schedule)
              if (id) merged.set(id, schedule)
            })
            
            // 새 데이터로 업데이트/추가
            incoming.forEach((schedule: any) => {
              const id = readField('id', schedule)
              if (id) merged.set(id, schedule)
            })
            
            return Array.from(merged.values())
          }
        }
      }
    },
    Schedule: {
      fields: {
        // 낙관적 업데이트를 위한 버전 관리
        version: {
          merge(existing, incoming) {
            return Math.max(existing || 0, incoming || 0)
          }
        }
      }
    }
  }
})

export const apolloClient = new ApolloClient({
  link: splitLink,
  cache,
  defaultOptions: {
    watchQuery: {
      errorPolicy: 'all',
      fetchPolicy: 'cache-and-network'
    },
    query: {
      errorPolicy: 'all',
      fetchPolicy: 'cache-first'
    }
  }
})
```

### **2. Zustand 상태 관리 아키텍처**

**도메인 분리된 Store 설계**
```typescript
// src/stores/index.ts
// 각 도메인별로 분리된 스토어들을 결합

import { create } from 'zustand'
import { subscribeWithSelector, devtools, persist } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'

// UI 상태 관리 (Apollo와 분리)
interface UIState {
  // 레이아웃 상태
  sidebarCollapsed: boolean
  currentView: 'month' | 'week' | 'day' | 'agenda'
  selectedDate: Date
  
  // 모달 및 다이얼로그 상태
  modals: {
    createSchedule: { open: boolean; data?: any }
    editSchedule: { open: boolean; scheduleId?: string }
    projectSettings: { open: boolean; projectId?: string }
    conflictResolution: { open: boolean; conflicts?: ConflictData[] }
  }
  
  // 필터 상태
  filters: {
    selectedProjectIds: string[]
    showCompletedSchedules: boolean
    dateRange: { start: Date; end: Date }
  }
  
  // 로딩 상태
  loading: {
    schedules: boolean
    projects: boolean
    sync: boolean
  }
  
  // Actions
  toggleSidebar: () => void
  setCurrentView: (view: ViewType) => void
  setSelectedDate: (date: Date) => void
  openModal: (modal: keyof UIState['modals'], data?: any) => void
  closeModal: (modal: keyof UIState['modals']) => void
  setFilter: (key: keyof UIState['filters'], value: any) => void
  setLoading: (key: keyof UIState['loading'], loading: boolean) => void
}

export const useUIStore = create<UIState>()(
  devtools(
    subscribeWithSelector(
      persist(
        immer((set) => ({
          sidebarCollapsed: false,
          currentView: 'week',
          selectedDate: new Date(),
          modals: {
            createSchedule: { open: false },
            editSchedule: { open: false },
            projectSettings: { open: false },
            conflictResolution: { open: false },
          },
          filters: {
            selectedProjectIds: [],
            showCompletedSchedules: true,
            dateRange: {
              start: startOfWeek(new Date()),
              end: endOfWeek(new Date())
            }
          },
          loading: {
            schedules: false,
            projects: false,
            sync: false
          },
          
          toggleSidebar: () => set(state => {
            state.sidebarCollapsed = !state.sidebarCollapsed
          }),
          
          setCurrentView: (view) => set(state => {
            state.currentView = view
            // 뷰 변경 시 날짜 범위 자동 조정
            const date = state.selectedDate
            switch (view) {
              case 'month':
                state.filters.dateRange = {
                  start: startOfMonth(date),
                  end: endOfMonth(date)
                }
                break
              case 'week':
                state.filters.dateRange = {
                  start: startOfWeek(date),
                  end: endOfWeek(date)
                }
                break
              case 'day':
                state.filters.dateRange = {
                  start: startOfDay(date),
                  end: endOfDay(date)
                }
                break
            }
          }),
          
          openModal: (modal, data) => set(state => {
            state.modals[modal] = { open: true, ...data }
          }),
          
          closeModal: (modal) => set(state => {
            state.modals[modal] = { open: false }
          }),
          
          setFilter: (key, value) => set(state => {
            state.filters[key] = value
          }),
          
          setLoading: (key, loading) => set(state => {
            state.loading[key] = loading
          })
        })),
        {
          name: 'baro-calendar-ui-state',
          partialize: (state) => ({
            sidebarCollapsed: state.sidebarCollapsed,
            currentView: state.currentView,
            filters: state.filters
          })
        }
      )
    ),
    { name: 'UI Store' }
  )
)

// 실시간 동기화 상태 관리
interface SyncState {
  // 연결 상태
  isConnected: boolean
  connectionQuality: 'excellent' | 'good' | 'poor' | 'offline'
  lastSync: Date | null
  
  // 오프라인 큐
  offlineQueue: OfflineAction[]
  syncInProgress: boolean
  
  // 충돌 관리
  conflicts: Map<string, ConflictData>
  
  // 활성 사용자 (같은 캘린더를 보고 있는 사용자들)
  activeUsers: ActiveUser[]
  
  // Actions
  setConnectionStatus: (connected: boolean, quality?: ConnectionQuality) => void
  addToOfflineQueue: (action: OfflineAction) => void
  processOfflineQueue: () => Promise<void>
  addConflict: (entityId: string, conflict: ConflictData) => void
  resolveConflict: (entityId: string, resolution: ConflictResolution) => void
  updateActiveUsers: (users: ActiveUser[]) => void
}

export const useSyncStore = create<SyncState>()(
  devtools(
    subscribeWithSelector((set, get) => ({
      isConnected: true,
      connectionQuality: 'excellent',
      lastSync: null,
      offlineQueue: [],
      syncInProgress: false,
      conflicts: new Map(),
      activeUsers: [],
      
      setConnectionStatus: (connected, quality = 'excellent') => set({
        isConnected: connected,
        connectionQuality: quality
      }),
      
      addToOfflineQueue: (action) => set(state => ({
        offlineQueue: [...state.offlineQueue, {
          ...action,
          timestamp: new Date(),
          id: generateId()
        }]
      })),
      
      processOfflineQueue: async () => {
        const { offlineQueue } = get()
        if (offlineQueue.length === 0) return
        
        set({ syncInProgress: true })
        
        try {
          // 오프라인 액션들을 순서대로 처리
          for (const action of offlineQueue) {
            await processOfflineAction(action)
          }
          
          set({ 
            offlineQueue: [],
            lastSync: new Date(),
            syncInProgress: false
          })
          
          showToast('success', `${offlineQueue.length}개의 변경사항이 동기화되었습니다`)
        } catch (error) {
          set({ syncInProgress: false })
          showToast('error', '동기화 중 오류가 발생했습니다')
          console.error('Offline sync error:', error)
        }
      },
      
      addConflict: (entityId, conflict) => set(state => ({
        conflicts: new Map(state.conflicts).set(entityId, conflict)
      })),
      
      resolveConflict: (entityId, resolution) => set(state => {
        const newConflicts = new Map(state.conflicts)
        newConflicts.delete(entityId)
        return { conflicts: newConflicts }
      }),
      
      updateActiveUsers: (users) => set({ activeUsers: users })
    })),
    { name: 'Sync Store' }
  )
)
```

### **3. WebSocket 실시간 동기화 시스템**

**WebSocket 연결 관리 및 메시지 처리**
```typescript
// src/lib/websocket/manager.ts
export class WebSocketManager {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private reconnectTimeout: NodeJS.Timeout | null = null
  private messageQueue: WebSocketMessage[] = []
  private subscribers = new Map<string, Set<MessageHandler>>()
  private heartbeatInterval: NodeJS.Timeout | null = null
  
  constructor(private url: string) {
    this.connect()
  }
  
  private connect() {
    try {
      this.ws = new WebSocket(this.url)
      
      this.ws.onopen = this.handleOpen.bind(this)
      this.ws.onmessage = this.handleMessage.bind(this)
      this.ws.onclose = this.handleClose.bind(this)
      this.ws.onerror = this.handleError.bind(this)
    } catch (error) {
      console.error('WebSocket connection error:', error)
      this.handleReconnect()
    }
  }
  
  private handleOpen() {
    console.log('WebSocket connected')
    this.reconnectAttempts = 0
    useSyncStore.getState().setConnectionStatus(true, 'excellent')
    
    // 인증
    this.send({
      type: 'AUTH',
      payload: { token: getAuthToken() }
    })
    
    // 하트비트 시작
    this.startHeartbeat()
    
    // 대기 중인 메시지 전송
    this.flushMessageQueue()
  }
  
  private handleMessage(event: MessageEvent) {
    try {
      const message: WebSocketMessage = JSON.parse(event.data)
      
      switch (message.type) {
        case 'SCHEDULE_UPDATED':
          this.notifySubscribers('schedule', message)
          this.handleScheduleUpdate(message.payload)
          break
          
        case 'PROJECT_UPDATED':
          this.notifySubscribers('project', message)
          this.handleProjectUpdate(message.payload)
          break
          
        case 'USER_PRESENCE':
          this.handleUserPresence(message.payload)
          break
          
        case 'CONFLICT_DETECTED':
          this.handleConflictDetected(message.payload)
          break
          
        case 'PONG':
          // 하트비트 응답
          break
          
        default:
          console.warn('Unknown WebSocket message type:', message.type)
      }
    } catch (error) {
      console.error('Error parsing WebSocket message:', error)
    }
  }
  
  private handleClose() {
    console.log('WebSocket disconnected')
    useSyncStore.getState().setConnectionStatus(false, 'offline')
    this.stopHeartbeat()
    this.handleReconnect()
  }
  
  private handleError(error: Event) {
    console.error('WebSocket error:', error)
    useSyncStore.getState().setConnectionStatus(false, 'poor')
  }
  
  private handleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached')
      return
    }
    
    this.reconnectAttempts++
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000) // 지수 백오프
    
    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`)
    
    this.reconnectTimeout = setTimeout(() => {
      this.connect()
    }, delay)
  }
  
  private startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      this.send({ type: 'PING' })
    }, 30000) // 30초마다 핑
  }
  
  private stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval)
      this.heartbeatInterval = null
    }
  }
  
  send(message: WebSocketMessage) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message))
    } else {
      // 연결이 끊어진 경우 큐에 추가
      this.messageQueue.push(message)
    }
  }
  
  private flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift()!
      this.send(message)
    }
  }
  
  subscribe(channel: string, handler: MessageHandler): () => void {
    if (!this.subscribers.has(channel)) {
      this.subscribers.set(channel, new Set())
    }
    
    this.subscribers.get(channel)!.add(handler)
    
    // 구독 해제 함수 반환
    return () => {
      this.subscribers.get(channel)?.delete(handler)
    }
  }
  
  private notifySubscribers(channel: string, message: WebSocketMessage) {
    const handlers = this.subscribers.get(channel)
    if (handlers) {
      handlers.forEach(handler => handler(message))
    }
  }
  
  private handleScheduleUpdate(payload: any) {
    // Apollo 캐시 업데이트
    const { type, schedule } = payload
    
    switch (type) {
      case 'CREATED':
      case 'UPDATED':
        apolloClient.cache.writeFragment({
          id: `Schedule:${schedule.id}`,
          fragment: SCHEDULE_FRAGMENT,
          data: schedule
        })
        break
        
      case 'DELETED':
        apolloClient.cache.evict({ id: `Schedule:${schedule.id}` })
        apolloClient.cache.gc()
        break
    }
    
    // 캐시 쿼리 다시 실행
    apolloClient.refetchQueries({ include: ['GetSchedules'] })
  }
  
  private handleConflictDetected(payload: ConflictData) {
    const { addConflict } = useSyncStore.getState()
    addConflict(payload.entityId, payload)
    
    // 충돌 해결 모달 표시
    const { openModal } = useUIStore.getState()
    openModal('conflictResolution', { conflicts: [payload] })
  }
  
  disconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout)
    }
    this.stopHeartbeat()
    this.ws?.close()
  }
}

// 전역 WebSocket 매니저 인스턴스
export const wsManager = new WebSocketManager(
  process.env.NEXT_PUBLIC_WS_ENDPOINT || 'ws://localhost:4000/graphql'
)
```

### **4. 낙관적 업데이트 및 충돌 해결**

**낙관적 업데이트 시스템**
```typescript
// src/hooks/useOptimisticSchedule.ts
export const useOptimisticSchedule = () => {
  const [updateSchedule] = useUpdateScheduleMutation()
  const { addToOfflineQueue, isConnected } = useSyncStore()
  
  const optimisticUpdate = useCallback(async (
    scheduleId: string,
    updates: Partial<Schedule>,
    optimisticData?: Partial<Schedule>
  ) => {
    // 1. 즉시 UI 업데이트 (낙관적)
    apolloClient.cache.writeFragment({
      id: `Schedule:${scheduleId}`,
      fragment: SCHEDULE_FRAGMENT,
      data: {
        id: scheduleId,
        ...optimisticData,
        version: (optimisticData?.version || 0) + 1,
        __typename: 'Schedule'
      }
    })
    
    // 2. 서버 요청
    if (isConnected) {
      try {
        const result = await updateSchedule({
          variables: { 
            id: scheduleId, 
            input: updates,
            version: optimisticData?.version || 0
          },
          optimisticResponse: {
            updateSchedule: {
              __typename: 'Schedule',
              id: scheduleId,
              ...optimisticData,
              version: (optimisticData?.version || 0) + 1
            }
          },
          update: (cache, { data }) => {
            if (data?.updateSchedule) {
              cache.writeFragment({
                id: `Schedule:${scheduleId}`,
                fragment: SCHEDULE_FRAGMENT,
                data: data.updateSchedule
              })
            }
          },
          errorPolicy: 'all'
        })
        
        // 서버 응답으로 최종 업데이트
        if (result.data?.updateSchedule) {
          apolloClient.cache.writeFragment({
            id: `Schedule:${scheduleId}`,
            fragment: SCHEDULE_FRAGMENT,
            data: result.data.updateSchedule
          })
        }
        
      } catch (error) {
        // 충돌 또는 에러 발생 시 처리
        if (error.graphQLErrors?.some(e => e.extensions?.code === 'CONFLICT')) {
          // 충돌 해결 로직
          handleVersionConflict(scheduleId, error)
        } else {
          // 일반 에러 - 원래 데이터로 되돌리기
          rollbackOptimisticUpdate(scheduleId)
          showToast('error', '업데이트 중 오류가 발생했습니다')
        }
      }
    } else {
      // 오프라인 - 큐에 추가
      addToOfflineQueue({
        type: 'UPDATE_SCHEDULE',
        entityId: scheduleId,
        data: updates,
        optimisticData
      })
    }
  }, [updateSchedule, addToOfflineQueue, isConnected])
  
  const rollbackOptimisticUpdate = useCallback((scheduleId: string) => {
    // 서버에서 최신 데이터 다시 가져와서 캐시 업데이트
    apolloClient.refetchQueries({
      include: [{ query: GET_SCHEDULE, variables: { id: scheduleId } }]
    })
  }, [])
  
  const handleVersionConflict = useCallback(async (
    scheduleId: string, 
    error: ApolloError
  ) => {
    const conflictInfo = error.graphQLErrors[0]?.extensions?.conflictInfo
    
    // 서버의 최신 버전 가져오기
    const { data } = await apolloClient.query({
      query: GET_SCHEDULE,
      variables: { id: scheduleId },
      fetchPolicy: 'network-only'
    })
    
    const serverSchedule = data.schedule
    const cachedSchedule = apolloClient.cache.readFragment({
      id: `Schedule:${scheduleId}`,
      fragment: SCHEDULE_FRAGMENT
    })
    
    // 충돌 해결 모달 표시
    const { openModal } = useUIStore.getState()
    const { addConflict } = useSyncStore.getState()
    
    const conflict: ConflictData = {
      entityId: scheduleId,
      entityType: 'Schedule',
      localVersion: cachedSchedule,
      serverVersion: serverSchedule,
      conflictType: 'version',
      timestamp: new Date().toISOString()
    }
    
    addConflict(scheduleId, conflict)
    openModal('conflictResolution', { conflicts: [conflict] })
  }, [])
  
  return {
    optimisticUpdate,
    rollbackOptimisticUpdate,
    handleVersionConflict
  }
}
```

### **5. 충돌 해결 UI 컴포넌트**

**충돌 해결 다이얼로그**
```typescript
// src/components/sync/ConflictResolutionModal.tsx
const ConflictResolutionModal = () => {
  const { modals, closeModal } = useUIStore()
  const { conflicts, resolveConflict } = useSyncStore()
  const { optimisticUpdate } = useOptimisticSchedule()
  
  const isOpen = modals.conflictResolution.open
  const conflictList = modals.conflictResolution.conflicts || []
  
  const [selectedResolutions, setSelectedResolutions] = useState<Map<string, ConflictResolution>>(new Map())
  
  const handleResolveConflict = async (entityId: string, resolution: ConflictResolution) => {
    const conflict = conflicts.get(entityId)
    if (!conflict) return
    
    switch (resolution.type) {
      case 'use_local':
        // 로컬 버전 사용
        await optimisticUpdate(
          entityId,
          conflict.localVersion,
          conflict.localVersion
        )
        break
        
      case 'use_server':
        // 서버 버전 사용
        apolloClient.cache.writeFragment({
          id: `Schedule:${entityId}`,
          fragment: SCHEDULE_FRAGMENT,
          data: conflict.serverVersion
        })
        break
        
      case 'merge':
        // 수동 병합
        const mergedData = resolution.mergedData
        await optimisticUpdate(entityId, mergedData, mergedData)
        break
    }
    
    resolveConflict(entityId, resolution)
  }
  
  const handleResolveAll = async () => {
    for (const [entityId, resolution] of selectedResolutions) {
      await handleResolveConflict(entityId, resolution)
    }
    closeModal('conflictResolution')
  }
  
  return (
    <Dialog open={isOpen} onOpenChange={() => closeModal('conflictResolution')}>
      <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>충돌 해결</DialogTitle>
          <DialogDescription>
            동시에 편집된 항목들이 있습니다. 어떤 버전을 사용할지 선택해주세요.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-6">
          {conflictList.map((conflict) => (
            <div key={conflict.entityId} className="border rounded-lg p-4 space-y-4">
              <div className="flex items-center gap-2">
                <AlertTriangle className="w-5 h-5 text-destructive" />
                <h3 className="font-semibold">
                  {conflict.entityType}: {conflict.localVersion.title || conflict.entityId}
                </h3>
              </div>
              
              <div className="grid grid-cols-2 gap-4">
                {/* 로컬 버전 */}
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <User className="w-4 h-4" />
                    <span className="font-medium text-blue-600">내 버전</span>
                  </div>
                  <div className="bg-blue-50 border border-blue-200 rounded p-3">
                    <ScheduleConflictPreview schedule={conflict.localVersion} />
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full"
                    onClick={() => setSelectedResolutions(prev => 
                      new Map(prev).set(conflict.entityId, { type: 'use_local' })
                    )}
                  >
                    이 버전 사용
                  </Button>
                </div>
                
                {/* 서버 버전 */}
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <Server className="w-4 h-4" />
                    <span className="font-medium text-green-600">서버 버전</span>
                  </div>
                  <div className="bg-green-50 border border-green-200 rounded p-3">
                    <ScheduleConflictPreview schedule={conflict.serverVersion} />
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full"
                    onClick={() => setSelectedResolutions(prev => 
                      new Map(prev).set(conflict.entityId, { type: 'use_server' })
                    )}
                  >
                    이 버전 사용
                  </Button>
                </div>
              </div>
              
              {/* 수동 병합 옵션 */}
              <Collapsible>
                <CollapsibleTrigger className="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground">
                  <Settings className="w-4 h-4" />
                  수동으로 병합하기
                  <ChevronRight className="w-4 h-4 transition-transform data-[state=open]:rotate-90" />
                </CollapsibleTrigger>
                <CollapsibleContent className="mt-2">
                  <ConflictMergeEditor
                    conflict={conflict}
                    onMerged={(mergedData) => 
                      setSelectedResolutions(prev => 
                        new Map(prev).set(conflict.entityId, { 
                          type: 'merge', 
                          mergedData 
                        })
                      )
                    }
                  />
                </CollapsibleContent>
              </Collapsible>
            </div>
          ))}
        </div>
        
        <DialogFooter>
          <Button variant="outline" onClick={() => closeModal('conflictResolution')}>
            나중에
          </Button>
          <Button 
            onClick={handleResolveAll}
            disabled={selectedResolutions.size === 0}
          >
            {selectedResolutions.size}개 충돌 해결
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}

// 충돌 미리보기 컴포넌트
const ScheduleConflictPreview = ({ schedule }: { schedule: Schedule }) => {
  const projectColor = PROJECT_COLORS[schedule.project?.color || 'blue']
  
  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        <div 
          className="w-3 h-3 rounded-full"
          style={{ backgroundColor: projectColor.primary }}
        />
        <span className="font-medium text-sm">{schedule.title}</span>
      </div>
      <div className="text-xs text-muted-foreground space-y-1">
        <div>시간: {formatTimeRange(schedule.startDateTime, schedule.endDateTime)}</div>
        {schedule.description && <div>설명: {schedule.description}</div>}
        {schedule.location && <div>장소: {schedule.location}</div>}
        <div>수정: {format(parseISO(schedule.updatedAt), 'MM/dd HH:mm')}</div>
      </div>
    </div>
  )
}
```

---

## 🎨 **사용자 경험 (UX) 설계**

### **1. 실시간 협업 표시**

**활성 사용자 및 실시간 변경사항 표시**
```typescript
// src/components/sync/RealtimeIndicator.tsx
const RealtimeIndicator = () => {
  const { isConnected, connectionQuality, activeUsers, syncInProgress } = useSyncStore()
  const [recentChanges, setRecentChanges] = useState<RecentChange[]>([])
  
  return (
    <div className="flex items-center gap-2 text-sm">
      {/* 연결 상태 표시 */}
      <div className="flex items-center gap-1">
        <div className={cn(
          "w-2 h-2 rounded-full",
          isConnected ? "bg-green-500" : "bg-red-500",
          connectionQuality === 'poor' && "bg-yellow-500"
        )} />
        <span className="text-xs text-muted-foreground">
          {isConnected ? '실시간 동기화' : '오프라인'}
        </span>
      </div>
      
      {/* 동기화 진행 표시 */}
      {syncInProgress && (
        <div className="flex items-center gap-1">
          <Loader2 className="w-3 h-3 animate-spin" />
          <span className="text-xs text-muted-foreground">동기화 중...</span>
        </div>
      )}
      
      {/* 활성 사용자 표시 */}
      {activeUsers.length > 0 && (
        <div className="flex items-center gap-1">
          <Users className="w-3 h-3" />
          <span className="text-xs text-muted-foreground">
            {activeUsers.length}명 온라인
          </span>
        </div>
      )}
      
      {/* 최근 변경사항 알림 */}
      <Popover>
        <PopoverTrigger asChild>
          <Button variant="ghost" size="sm" className="h-6 px-2">
            <Bell className="w-3 h-3" />
            {recentChanges.length > 0 && (
              <Badge variant="destructive" className="w-1 h-1 p-0 ml-1" />
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-80">
          <div className="space-y-2">
            <h4 className="font-medium text-sm">최근 변경사항</h4>
            {recentChanges.length === 0 ? (
              <p className="text-xs text-muted-foreground">변경사항이 없습니다</p>
            ) : (
              <div className="space-y-1 max-h-60 overflow-y-auto">
                {recentChanges.map(change => (
                  <div key={change.id} className="text-xs p-2 bg-muted rounded">
                    <div className="font-medium">{change.title}</div>
                    <div className="text-muted-foreground">
                      {change.userName} • {formatDistanceToNow(parseISO(change.timestamp), { addSuffix: true })}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </PopoverContent>
      </Popover>
    </div>
  )
}
```

### **2. 오프라인 지원 UI**

**오프라인 상태 표시 및 큐 관리**
```typescript
// src/components/sync/OfflineQueueManager.tsx
const OfflineQueueManager = () => {
  const { offlineQueue, syncInProgress, isConnected, processOfflineQueue } = useSyncStore()
  const [showQueue, setShowQueue] = useState(false)
  
  // 온라인 복귀 시 자동 동기화
  useEffect(() => {
    if (isConnected && offlineQueue.length > 0 && !syncInProgress) {
      const timer = setTimeout(() => {
        processOfflineQueue()
      }, 1000) // 1초 후 자동 동기화
      
      return () => clearTimeout(timer)
    }
  }, [isConnected, offlineQueue.length, syncInProgress])
  
  if (offlineQueue.length === 0) return null
  
  return (
    <div className="fixed bottom-4 right-4 z-50">
      <Card className="bg-orange-50 border-orange-200">
        <CardContent className="p-4">
          <div className="flex items-center gap-2 mb-2">
            <WifiOff className="w-4 h-4 text-orange-600" />
            <span className="font-medium text-sm text-orange-800">
              오프라인 변경사항 {offlineQueue.length}개
            </span>
          </div>
          
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowQueue(!showQueue)}
            >
              {showQueue ? '숨기기' : '보기'}
            </Button>
            
            <Button
              size="sm"
              onClick={processOfflineQueue}
              disabled={!isConnected || syncInProgress}
            >
              {syncInProgress ? (
                <>
                  <Loader2 className="w-3 h-3 animate-spin mr-1" />
                  동기화 중
                </>
              ) : (
                '지금 동기화'
              )}
            </Button>
          </div>
          
          {showQueue && (
            <div className="mt-3 space-y-1 max-h-40 overflow-y-auto">
              {offlineQueue.map(action => (
                <div key={action.id} className="text-xs p-2 bg-white rounded border">
                  <div className="font-medium">
                    {action.type === 'CREATE_SCHEDULE' && '일정 생성'}
                    {action.type === 'UPDATE_SCHEDULE' && '일정 수정'}
                    {action.type === 'DELETE_SCHEDULE' && '일정 삭제'}
                  </div>
                  <div className="text-muted-foreground">
                    {format(action.timestamp, 'MM/dd HH:mm')}
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
```

---

## 📊 **성능 최적화**

### **메모리 관리 및 캐시 최적화**
```typescript
// src/lib/performance/cacheOptimization.ts
export class CacheOptimizer {
  private static cacheCleanupInterval: NodeJS.Timeout | null = null
  
  static initialize() {
    // 5분마다 캐시 정리
    this.cacheCleanupInterval = setInterval(() => {
      this.cleanupExpiredCache()
      this.optimizeMemoryUsage()
    }, 5 * 60 * 1000)
  }
  
  private static cleanupExpiredCache() {
    const cache = apolloClient.cache as InMemoryCache
    
    // 오래된 쿼리 결과 제거
    const expiredQueries = cache.extract().ROOT_QUERY
    Object.keys(expiredQueries).forEach(key => {
      if (key.startsWith('schedules') && this.isCacheExpired(key)) {
        cache.evict({ fieldName: key })
      }
    })
    
    // 가비지 컬렉션
    cache.gc()
  }
  
  private static optimizeMemoryUsage() {
    const { schedules } = useScheduleStore.getState()
    const currentDateRange = useUIStore.getState().filters.dateRange
    
    // 현재 뷰 범위 밖의 스케줄 데이터 정리
    const expiredSchedules: string[] = []
    schedules.forEach((schedule, id) => {
      const scheduleDate = parseISO(schedule.startDateTime)
      if (
        isBefore(scheduleDate, subMonths(currentDateRange.start, 1)) ||
        isAfter(scheduleDate, addMonths(currentDateRange.end, 1))
      ) {
        expiredSchedules.push(id)
      }
    })
    
    // 만료된 스케줄 캐시에서 제거
    expiredSchedules.forEach(id => {
      apolloClient.cache.evict({ id: `Schedule:${id}` })
    })
  }
  
  private static isCacheExpired(cacheKey: string): boolean {
    // 캐시 키에서 타임스탬프 추출하여 만료 여부 확인
    // 구현은 실제 캐시 키 구조에 따라 달라짐
    return false // 구현 필요
  }
  
  static destroy() {
    if (this.cacheCleanupInterval) {
      clearInterval(this.cacheCleanupInterval)
    }
  }
}

// 성능 메트릭 수집
export const trackStatePerformance = () => {
  // Zustand 상태 변경 추적
  useUIStore.subscribe(
    (state) => state.filters,
    (filters, prevFilters) => {
      performance.mark('filter-change-start')
      // 필터 변경 완료 후
      requestIdleCallback(() => {
        performance.mark('filter-change-end')
        performance.measure('filter-change', 'filter-change-start', 'filter-change-end')
        
        const measure = performance.getEntriesByName('filter-change')[0]
        PerformanceMonitor.recordMetric('filter-change-duration', measure.duration)
      })
    }
  )
  
  // Apollo 쿼리 성능 추적
  const link = ApolloLink.from([
    new ApolloLink((operation, forward) => {
      const startTime = Date.now()
      
      return forward(operation).map((result) => {
        const duration = Date.now() - startTime
        PerformanceMonitor.recordMetric(`graphql-${operation.operationName}`, duration)
        
        return result
      })
    })
  ])
}
```

---

## ✅ **Definition of Done**

### **기능 요구사항**
- [ ] Apollo Client + Zustand 하이브리드 상태 관리 시스템
- [ ] WebSocket 기반 실시간 양방향 동기화
- [ ] 낙관적 업데이트 및 자동 충돌 해결
- [ ] 오프라인 지원 및 자동 동기화 큐
- [ ] 활성 사용자 표시 및 실시간 협업 지원

### **기술 요구사항**
- [ ] Apollo InMemoryCache 정규화 및 캐시 정책 구현
- [ ] Zustand devtools 및 persist 미들웨어 적용
- [ ] WebSocket 재연결 및 하트비트 시스템
- [ ] 버전 기반 충돌 감지 및 해결
- [ ] GraphQL 구독을 통한 실시간 업데이트

### **성능 요구사항**
- [ ] 상태 변경 응답시간 50ms 이하
- [ ] WebSocket 메시지 처리 10ms 이하
- [ ] 캐시 메모리 사용량 50MB 이하
- [ ] 오프라인 큐 처리 시간 2초 이하

### **접근성 요구사항**
- [ ] 실시간 변경사항 스크린 리더 알림
- [ ] 키보드로 충돌 해결 다이얼로그 조작 가능
- [ ] 연결 상태 시각적/청각적 피드백
- [ ] 고대비 모드에서 상태 표시 명확성

### **보안 요구사항**
- [ ] WebSocket 인증 토큰 검증
- [ ] 민감 정보 캐시 암호화
- [ ] 충돌 해결 권한 검증
- [ ] 실시간 데이터 무결성 검증

### **테스트 요구사항**
- [ ] Jest를 통한 상태 관리 로직 단위 테스트
- [ ] WebSocket 연결 및 재연결 시나리오 테스트
- [ ] 충돌 해결 플로우 E2E 테스트
- [ ] 오프라인/온라인 전환 테스트

---

## 📚 **관련 문서 참조**

- [04. 상태 관리](../ui-architecture/04-state-management.md)
- [15. 실시간 WebSocket 동기화](../ui-architecture/15-realtime-websocket-sync.md)
- [19. 서버 상태 관리 원칙](../ui-architecture/19-server-state-management.md)
- [20. 표준 에러 포맷 및 핸들링](../ui-architecture/20-error-handling.md)
- [21. Observability 및 모니터링](../ui-architecture/21-observability-monitoring.md)

---

**이 스토리는 바로캘린더의 핵심 상태 관리 및 실시간 협업 기능을 완전하게 구현하기 위한 종합적인 기술 가이드입니다. Apollo Client와 Zustand의 최적 조합으로 확장 가능하고 성능 최적화된 상태 관리 시스템을 구축합니다.**