# Story 2.14: Design System Foundations Implementation

## 📋 문서 정보
- **문서 버전**: 1.0
- **작성일**: 2025-08-28
- **작성자**: Frontend Team
- **프로젝트명**: 바로캘린더 (Baro Calendar)
- **상태**: Active
- **관련 아키텍처 문서**: [05-design-system-foundations.md](../ui-architecture/05-design-system-foundations.md)

---

## 🎯 스토리 목표

바로캘린더 애플리케이션의 **일관성 있는 디자인 시스템 기초**를 구축하여 모든 UI 컴포넌트가 체계적이고 확장 가능한 디자인 토큰을 기반으로 구현될 수 있도록 한다.

### 주요 구현 사항
- **Design Tokens 시스템** 구축으로 색상, 타이포그래피, 간격 표준화
- **8가지 프로젝트 색상** 시스템과 시맨틱 매핑
- **체계적인 타이포그래피** 및 간격 시스템
- **Material Design 기반** 그림자 및 엘레베이션 시스템

---

## 👤 사용자 스토리

### US 2.14.1: 일관된 디자인 토큰 시스템
**As a** 개발팀원  
**I want** CSS Variables 기반의 체계적인 디자인 토큰을 사용하기를  
**So that** 모든 컴포넌트에서 일관된 디자인을 유지하고 테마 변경을 쉽게 할 수 있다.

**인수 조건:**
- [ ] CSS Variables로 색상, 타이포그래피, 간격 토큰 정의
- [ ] 라이트/다크 테마 자동 전환 지원
- [ ] TypeScript 타입 안전성을 위한 토큰 타입 정의
- [ ] 실시간 디자인 토큰 변경 및 적용

### US 2.14.2: 프로젝트 색상 시스템
**As a** 사용자  
**I want** 8가지 프로젝트별 고유 색상을 통해 프로젝트를 구분하기를  
**So that** 시각적으로 프로젝트를 빠르게 식별하고 캘린더에서 구분할 수 있다.

**인수 조건:**
- [ ] 8가지 프로젝트 색상 (Blue, Green, Purple, Orange, Red, Teal, Pink, Indigo)
- [ ] 각 색상별 50-900 스케일 지원
- [ ] 접근성을 고려한 충분한 대비율 확보
- [ ] 시맨틱 색상과 프로젝트 색상 간 매핑

### US 2.14.3: 확장 가능한 타이포그래피 시스템
**As a** 디자이너  
**I want** 체계적인 타이포그래피 시스템을 통해 텍스트 스타일을 표준화하기를  
**So that** 사용자 인터페이스에서 정보 위계가 명확하고 가독성이 좋은 텍스트를 제공할 수 있다.

**인수 조건:**
- [ ] 9단계 폰트 크기 시스템 (xs ~ 9xl)
- [ ] 헤딩, 본문, 캡션 등 시맨틱 타이포그래피 컴포넌트
- [ ] Inter 폰트 기반 웹폰트 최적화
- [ ] 반응형 타이포그래피 지원

---

## 🔧 기술적 구현 요구사항

### 1. 디자인 토큰 시스템 구현

**주요 파일**: `src/styles/design-tokens.css`

```css
/* src/styles/design-tokens.css */
:root {
  /* 프로젝트 색상 시스템 - 8가지 기본 색상 */
  --project-blue-50: #EFF6FF;
  --project-blue-100: #DBEAFE;
  --project-blue-200: #BFDBFE;
  --project-blue-300: #93C5FD;
  --project-blue-400: #60A5FA;
  --project-blue-500: #3B82F6;
  --project-blue-600: #2563EB;
  --project-blue-700: #1D4ED8;
  --project-blue-800: #1E40AF;
  --project-blue-900: #1E3A8A;
  
  --project-green-50: #ECFDF5;
  --project-green-100: #D1FAE5;
  --project-green-200: #A7F3D0;
  --project-green-300: #6EE7B7;
  --project-green-400: #34D399;
  --project-green-500: #10B981;
  --project-green-600: #059669;
  --project-green-700: #047857;
  --project-green-800: #065F46;
  --project-green-900: #064E3B;
  
  --project-purple-50: #F5F3FF;
  --project-purple-100: #EDE9FE;
  --project-purple-200: #DDD6FE;
  --project-purple-300: #C4B5FD;
  --project-purple-400: #A78BFA;
  --project-purple-500: #8B5CF6;
  --project-purple-600: #7C3AED;
  --project-purple-700: #6D28D9;
  --project-purple-800: #5B21B6;
  --project-purple-900: #4C1D95;
  
  --project-orange-50: #FFFBEB;
  --project-orange-100: #FEF3C7;
  --project-orange-200: #FDE68A;
  --project-orange-300: #FCD34D;
  --project-orange-400: #FBBF24;
  --project-orange-500: #F59E0B;
  --project-orange-600: #D97706;
  --project-orange-700: #B45309;
  --project-orange-800: #92400E;
  --project-orange-900: #78350F;
  
  --project-red-50: #FEF2F2;
  --project-red-100: #FEE2E2;
  --project-red-200: #FECACA;
  --project-red-300: #FCA5A5;
  --project-red-400: #F87171;
  --project-red-500: #EF4444;
  --project-red-600: #DC2626;
  --project-red-700: #B91C1C;
  --project-red-800: #991B1B;
  --project-red-900: #7F1D1D;
  
  --project-teal-50: #F0FDFA;
  --project-teal-100: #CCFBF1;
  --project-teal-200: #99F6E4;
  --project-teal-300: #5EEAD4;
  --project-teal-400: #2DD4BF;
  --project-teal-500: #14B8A6;
  --project-teal-600: #0D9488;
  --project-teal-700: #0F766E;
  --project-teal-800: #115E59;
  --project-teal-900: #134E4A;
  
  --project-pink-50: #FDF2F8;
  --project-pink-100: #FCE7F3;
  --project-pink-200: #FBCFE8;
  --project-pink-300: #F9A8D4;
  --project-pink-400: #F472B6;
  --project-pink-500: #EC4899;
  --project-pink-600: #DB2777;
  --project-pink-700: #BE185D;
  --project-pink-800: #9D174D;
  --project-pink-900: #831843;
  
  --project-indigo-50: #EEF2FF;
  --project-indigo-100: #E0E7FF;
  --project-indigo-200: #C7D2FE;
  --project-indigo-300: #A5B4FC;
  --project-indigo-400: #818CF8;
  --project-indigo-500: #6366F1;
  --project-indigo-600: #4F46E5;
  --project-indigo-700: #4338CA;
  --project-indigo-800: #3730A3;
  --project-indigo-900: #312E81;
  
  /* 시맨틱 색상 매핑 */
  --primary: var(--project-blue-500);
  --primary-50: var(--project-blue-50);
  --primary-100: var(--project-blue-100);
  --primary-500: var(--project-blue-500);
  --primary-600: var(--project-blue-600);
  --primary-700: var(--project-blue-700);
  --primary-foreground: #ffffff;
  
  --secondary: #f8fafc;
  --secondary-foreground: #0f172a;
  --accent: #f1f5f9;
  --accent-foreground: #0f172a;
  
  --success: var(--project-green-500);
  --success-foreground: #ffffff;
  --warning: var(--project-orange-500);
  --warning-foreground: #ffffff;
  --danger: var(--project-red-500);
  --danger-foreground: #ffffff;
  --info: var(--project-blue-500);
  --info-foreground: #ffffff;
  
  --muted: #f8fafc;
  --muted-foreground: #64748b;
  --border: #e2e8f0;
  --input: #e2e8f0;
  --ring: var(--primary);
  --background: #ffffff;
  --foreground: #0f172a;
  --card: #ffffff;
  --card-foreground: #0f172a;
  --popover: #ffffff;
  --popover-foreground: #0f172a;
  
  /* 타이포그래피 토큰 */
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  --font-mono: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
  --font-heading: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  
  /* 폰트 크기 토큰 */
  --text-xs: 0.75rem;     /* 12px */
  --text-sm: 0.875rem;    /* 14px */
  --text-base: 1rem;      /* 16px */
  --text-lg: 1.125rem;    /* 18px */
  --text-xl: 1.25rem;     /* 20px */
  --text-2xl: 1.5rem;     /* 24px */
  --text-3xl: 1.875rem;   /* 30px */
  --text-4xl: 2.25rem;    /* 36px */
  --text-5xl: 3rem;       /* 48px */
  --text-6xl: 3.75rem;    /* 60px */
  --text-7xl: 4.5rem;     /* 72px */
  --text-8xl: 6rem;       /* 96px */
  --text-9xl: 8rem;       /* 128px */
  
  /* 행간 토큰 */
  --leading-none: 1;
  --leading-tight: 1.25;
  --leading-snug: 1.375;
  --leading-normal: 1.5;
  --leading-relaxed: 1.625;
  --leading-loose: 2;
  
  /* 간격 시스템 토큰 */
  --spacing-px: 1px;
  --spacing-0: 0px;
  --spacing-0-5: 0.125rem;  /* 2px */
  --spacing-1: 0.25rem;     /* 4px */
  --spacing-1-5: 0.375rem;  /* 6px */
  --spacing-2: 0.5rem;      /* 8px */
  --spacing-2-5: 0.625rem;  /* 10px */
  --spacing-3: 0.75rem;     /* 12px */
  --spacing-3-5: 0.875rem;  /* 14px */
  --spacing-4: 1rem;        /* 16px */
  --spacing-5: 1.25rem;     /* 20px */
  --spacing-6: 1.5rem;      /* 24px */
  --spacing-7: 1.75rem;     /* 28px */
  --spacing-8: 2rem;        /* 32px */
  --spacing-9: 2.25rem;     /* 36px */
  --spacing-10: 2.5rem;     /* 40px */
  --spacing-12: 3rem;       /* 48px */
  --spacing-14: 3.5rem;     /* 56px */
  --spacing-16: 4rem;       /* 64px */
  --spacing-20: 5rem;       /* 80px */
  --spacing-24: 6rem;       /* 96px */
  --spacing-32: 8rem;       /* 128px */
  
  /* 시맨틱 간격 */
  --spacing-xs: var(--spacing-1);
  --spacing-sm: var(--spacing-2);
  --spacing-md: var(--spacing-4);
  --spacing-lg: var(--spacing-6);
  --spacing-xl: var(--spacing-8);
  --spacing-2xl: var(--spacing-12);
  --spacing-3xl: var(--spacing-16);
  --spacing-4xl: var(--spacing-20);
  --spacing-5xl: var(--spacing-24);
  
  /* 그림자 시스템 토큰 */
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-default: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
  
  /* 전환 효과 토큰 */
  --transition-fast: 150ms ease-in-out;
  --transition-normal: 300ms ease-in-out;
  --transition-slow: 500ms ease-in-out;
  
  /* 반응형 브레이크포인트 */
  --breakpoint-sm: 640px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 1024px;
  --breakpoint-xl: 1280px;
  --breakpoint-2xl: 1536px;
  
  /* 레이아웃 토큰 */
  --container-padding-mobile: var(--spacing-md);
  --container-padding-tablet: var(--spacing-lg);
  --container-padding-desktop: var(--spacing-xl);
  
  --section-spacing-small: var(--spacing-2xl);
  --section-spacing-medium: var(--spacing-3xl);
  --section-spacing-large: var(--spacing-4xl);
}

/* 다크 테마 */
[data-theme="dark"] {
  --background: #0f172a;
  --foreground: #f8fafc;
  --card: #1e293b;
  --card-foreground: #f8fafc;
  --popover: #1e293b;
  --popover-foreground: #f8fafc;
  --primary: var(--project-blue-500);
  --primary-foreground: #ffffff;
  --secondary: #1e293b;
  --secondary-foreground: #f8fafc;
  --muted: #1e293b;
  --muted-foreground: #64748b;
  --accent: #1e293b;
  --accent-foreground: #f8fafc;
  --border: #334155;
  --input: #334155;
  --ring: var(--project-blue-500);
}

/* 다크모드 자동 감지 */
@media (prefers-color-scheme: dark) {
  :root:not([data-theme]) {
    --background: #0f172a;
    --foreground: #f8fafc;
    --card: #1e293b;
    --card-foreground: #f8fafc;
    --popover: #1e293b;
    --popover-foreground: #f8fafc;
    --secondary: #1e293b;
    --secondary-foreground: #f8fafc;
    --muted: #1e293b;
    --muted-foreground: #64748b;
    --accent: #1e293b;
    --accent-foreground: #f8fafc;
    --border: #334155;
    --input: #334155;
  }
}
```

### 2. TypeScript 타입 정의 시스템

**주요 파일**: `src/lib/design-tokens/types.ts`

```typescript
// src/lib/design-tokens/types.ts

// 프로젝트 색상 타입
export const PROJECT_COLORS = [
  'blue',
  'green', 
  'purple',
  'orange',
  'red',
  'teal',
  'pink',
  'indigo',
] as const

export type ProjectColor = typeof PROJECT_COLORS[number]

// 색상 스케일 타입
export const COLOR_SCALES = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900] as const
export type ColorScale = typeof COLOR_SCALES[number]

// 시맨틱 색상 타입
export const SEMANTIC_COLORS = [
  'primary',
  'secondary', 
  'accent',
  'success',
  'warning',
  'danger',
  'info',
  'muted',
  'background',
  'foreground',
  'border',
  'card',
  'popover',
] as const

export type SemanticColor = typeof SEMANTIC_COLORS[number]

// 폰트 크기 타입
export const FONT_SIZES = [
  'xs',
  'sm', 
  'base',
  'lg',
  'xl',
  '2xl',
  '3xl',
  '4xl',
  '5xl',
  '6xl',
  '7xl',
  '8xl',
  '9xl',
] as const

export type FontSize = typeof FONT_SIZES[number]

// 폰트 굵기 타입
export const FONT_WEIGHTS = [
  'thin',
  'extralight',
  'light',
  'normal',
  'medium',
  'semibold',
  'bold',
  'extrabold',
  'black',
] as const

export type FontWeight = typeof FONT_WEIGHTS[number]

// 간격 타입
export const SPACINGS = [
  'px',
  '0',
  '0.5',
  '1',
  '1.5',
  '2',
  '2.5',
  '3',
  '3.5',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  '10',
  '12',
  '14',
  '16',
  '20',
  '24',
  '32',
  'xs',
  'sm',
  'md',
  'lg',
  'xl',
  '2xl',
  '3xl',
  '4xl',
  '5xl',
] as const

export type Spacing = typeof SPACINGS[number]

// 그림자 타입
export const SHADOWS = [
  'none',
  'sm',
  'default',
  'md',
  'lg',
  'xl',
  '2xl',
  'inner',
] as const

export type Shadow = typeof SHADOWS[number]

// 엘레베이션 레벨
export const ELEVATIONS = [0, 1, 2, 3, 4, 5, 6] as const
export type Elevation = typeof ELEVATIONS[number]

// 타이포그래피 변형
export const TYPOGRAPHY_VARIANTS = [
  'h1',
  'h2',
  'h3', 
  'h4',
  'h5',
  'h6',
  'body1',
  'body2',
  'caption',
  'overline',
] as const

export type TypographyVariant = typeof TYPOGRAPHY_VARIANTS[number]

// 디자인 토큰 인터페이스
export interface DesignTokens {
  colors: {
    project: Record<ProjectColor, Record<ColorScale, string>>
    semantic: Record<SemanticColor, string>
  }
  typography: {
    fontSizes: Record<FontSize, [string, { lineHeight: string }]>
    fontWeights: Record<FontWeight, string>
    fontFamilies: {
      sans: string[]
      mono: string[]
      heading: string[]
    }
  }
  spacing: Record<Spacing, string>
  shadows: Record<Shadow, string>
  elevations: Record<Elevation, string>
}

// 테마 타입
export type Theme = 'light' | 'dark' | 'auto'

// 컬러 모드 컨텍스트
export interface ColorModeContext {
  theme: Theme
  setTheme: (theme: Theme) => void
  resolvedTheme: 'light' | 'dark'
  systemTheme: 'light' | 'dark'
}
```

### 3. 디자인 토큰 유틸리티 함수

**주요 파일**: `src/lib/design-tokens/utils.ts`

```typescript
// src/lib/design-tokens/utils.ts
import { 
  ProjectColor, 
  ColorScale, 
  SemanticColor, 
  FontSize, 
  Spacing,
  Shadow,
  Elevation 
} from './types'

// CSS 변수 접근 유틸리티
export const getCSSVariable = (name: string): string => {
  if (typeof window === 'undefined') {
    return `var(--${name})`
  }
  
  const value = getComputedStyle(document.documentElement)
    .getPropertyValue(`--${name}`)
    .trim()
    
  return value || `var(--${name})`
}

// 프로젝트 색상 가져오기
export const getProjectColor = (
  color: ProjectColor, 
  scale: ColorScale = 500
): string => {
  return getCSSVariable(`project-${color}-${scale}`)
}

// 시맨틱 색상 가져오기  
export const getSemanticColor = (color: SemanticColor): string => {
  return getCSSVariable(color)
}

// 간격 값 가져오기
export const getSpacing = (spacing: Spacing): string => {
  return getCSSVariable(`spacing-${spacing}`)
}

// 그림자 값 가져오기
export const getShadow = (shadow: Shadow): string => {
  return getCSSVariable(`shadow-${shadow === 'default' ? 'default' : shadow}`)
}

// 엘레베이션 가져오기
export const getElevation = (level: Elevation): string => {
  const shadowMap: Record<Elevation, Shadow> = {
    0: 'none',
    1: 'sm',
    2: 'default', 
    3: 'md',
    4: 'lg',
    5: 'xl',
    6: '2xl',
  }
  
  return getShadow(shadowMap[level])
}

// 폰트 크기 가져오기
export const getFontSize = (size: FontSize): string => {
  return getCSSVariable(`text-${size}`)
}

// 반응형 간격 생성
export const createResponsiveSpacing = (
  mobile: Spacing,
  tablet?: Spacing,
  desktop?: Spacing
): string => {
  let styles = getSpacing(mobile)
  
  if (tablet) {
    styles += ` md:${getSpacing(tablet)}`
  }
  
  if (desktop) {
    styles += ` lg:${getSpacing(desktop)}`
  }
  
  return styles
}

// 색상 대비 계산
export const getContrastColor = (backgroundColor: string): string => {
  // 간단한 명도 기반 대비 색상 결정
  const hex = backgroundColor.replace('#', '')
  const r = parseInt(hex.substr(0, 2), 16)
  const g = parseInt(hex.substr(2, 2), 16)  
  const b = parseInt(hex.substr(4, 2), 16)
  
  // 명도 계산 (0-255)
  const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000
  
  return brightness > 155 ? '#000000' : '#ffffff'
}

// 색상 투명도 적용
export const withOpacity = (color: string, opacity: number): string => {
  if (color.startsWith('var(')) {
    return `hsl(from ${color} h s l / ${opacity})`
  }
  
  // HEX to HSL 변환 후 투명도 적용
  return `${color}${Math.round(opacity * 255).toString(16).padStart(2, '0')}`
}

// 동적 색상 스케일 생성
export const generateColorScale = (baseColor: string) => {
  const scales: Record<ColorScale, string> = {
    50: lighten(baseColor, 0.95),
    100: lighten(baseColor, 0.9),
    200: lighten(baseColor, 0.8),
    300: lighten(baseColor, 0.6),
    400: lighten(baseColor, 0.3),
    500: baseColor,
    600: darken(baseColor, 0.2),
    700: darken(baseColor, 0.4),
    800: darken(baseColor, 0.6),
    900: darken(baseColor, 0.8),
  }
  
  return scales
}

// 색상 밝게 하기
const lighten = (color: string, amount: number): string => {
  const hsl = hexToHsl(color)
  return hslToHex({
    ...hsl,
    l: Math.min(100, hsl.l + (amount * 100))
  })
}

// 색상 어둡게 하기  
const darken = (color: string, amount: number): string => {
  const hsl = hexToHsl(color)
  return hslToHex({
    ...hsl,
    l: Math.max(0, hsl.l - (amount * 100))
  })
}

// HEX to HSL 변환
const hexToHsl = (hex: string): { h: number; s: number; l: number } => {
  const r = parseInt(hex.slice(1, 3), 16) / 255
  const g = parseInt(hex.slice(3, 5), 16) / 255
  const b = parseInt(hex.slice(5, 7), 16) / 255
  
  const max = Math.max(r, g, b)
  const min = Math.min(r, g, b)
  let h = 0, s = 0, l = (max + min) / 2
  
  if (max === min) {
    h = s = 0 // achromatic
  } else {
    const d = max - min
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min)
    
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break
      case g: h = (b - r) / d + 2; break
      case b: h = (r - g) / d + 4; break
    }
    
    h /= 6
  }
  
  return { h: h * 360, s: s * 100, l: l * 100 }
}

// HSL to HEX 변환
const hslToHex = ({ h, s, l }: { h: number; s: number; l: number }): string => {
  h /= 360
  s /= 100
  l /= 100
  
  const hue2rgb = (p: number, q: number, t: number) => {
    if (t < 0) t += 1
    if (t > 1) t -= 1
    if (t < 1/6) return p + (q - p) * 6 * t
    if (t < 1/2) return q
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6
    return p
  }
  
  let r, g, b
  
  if (s === 0) {
    r = g = b = l // achromatic
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s
    const p = 2 * l - q
    r = hue2rgb(p, q, h + 1/3)
    g = hue2rgb(p, q, h)
    b = hue2rgb(p, q, h - 1/3)
  }
  
  const toHex = (c: number) => {
    const hex = Math.round(c * 255).toString(16)
    return hex.length === 1 ? '0' + hex : hex
  }
  
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

// 프로젝트 색상 매핑
export const PROJECT_COLOR_MAP: Record<number, ProjectColor> = {
  1: 'blue',
  2: 'green',
  3: 'purple', 
  4: 'orange',
  5: 'red',
  6: 'teal',
  7: 'pink',
  8: 'indigo',
} as const

// 프로젝트 ID로 색상 가져오기
export const getProjectColorById = (projectId: number): ProjectColor => {
  return PROJECT_COLOR_MAP[projectId] || 'blue'
}

// CSS 클래스 이름 생성
export const createColorClasses = (
  color: ProjectColor,
  type: 'bg' | 'text' | 'border' = 'bg',
  scale: ColorScale = 500
): string => {
  return `${type}-project-${color}-${scale}`
}
```

### 4. 타이포그래피 컴포넌트 구현

**주요 파일**: `src/components/ui/Typography.tsx`

```typescript
// src/components/ui/Typography.tsx
import React from 'react'
import { cn } from '@/lib/utils'
import { TypographyVariant } from '@/lib/design-tokens/types'

interface TypographyProps {
  variant: TypographyVariant
  children: React.ReactNode
  className?: string
  as?: React.ElementType
  color?: 'default' | 'muted' | 'primary' | 'success' | 'warning' | 'danger'
}

const typographyVariants: Record<TypographyVariant, string> = {
  h1: 'text-4xl font-bold leading-tight tracking-tight text-foreground',
  h2: 'text-3xl font-semibold leading-tight tracking-tight text-foreground',
  h3: 'text-2xl font-semibold leading-snug text-foreground',
  h4: 'text-xl font-medium leading-snug text-foreground',
  h5: 'text-lg font-medium leading-normal text-foreground', 
  h6: 'text-base font-medium leading-normal text-foreground',
  body1: 'text-base leading-relaxed text-foreground',
  body2: 'text-sm leading-relaxed text-foreground',
  caption: 'text-xs leading-normal text-muted-foreground',
  overline: 'text-xs font-medium uppercase tracking-wider text-muted-foreground',
} as const

const colorVariants = {
  default: 'text-foreground',
  muted: 'text-muted-foreground',
  primary: 'text-primary',
  success: 'text-success',
  warning: 'text-warning', 
  danger: 'text-danger',
} as const

export const Typography: React.FC<TypographyProps> = ({
  variant,
  children,
  className,
  as,
  color = 'default',
}) => {
  const Component = as || getDefaultElement(variant)
  
  const variantClasses = typographyVariants[variant]
  const colorClasses = color !== 'default' ? colorVariants[color] : ''
  
  return (
    <Component 
      className={cn(
        variantClasses,
        colorClasses,
        className
      )}
    >
      {children}
    </Component>
  )
}

const getDefaultElement = (variant: TypographyVariant): React.ElementType => {
  switch (variant) {
    case 'h1': return 'h1'
    case 'h2': return 'h2'
    case 'h3': return 'h3'
    case 'h4': return 'h4' 
    case 'h5': return 'h5'
    case 'h6': return 'h6'
    case 'overline': return 'span'
    case 'caption': return 'span'
    default: return 'p'
  }
}

// 미리 정의된 타이포그래피 컴포넌트들
export const H1: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="h1" {...props} />
)

export const H2: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="h2" {...props} />
)

export const H3: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="h3" {...props} />
)

export const H4: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="h4" {...props} />
)

export const H5: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="h5" {...props} />
)

export const H6: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="h6" {...props} />
)

export const Body1: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="body1" {...props} />
)

export const Body2: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="body2" {...props} />
)

export const Caption: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="caption" {...props} />
)

export const Overline: React.FC<Omit<TypographyProps, 'variant'>> = (props) => (
  <Typography variant="overline" {...props} />
)
```

---

## 🎨 UX 디자인 고려사항

### 시각적 일관성
- **8가지 프로젝트 색상**: 프로젝트별 시각적 구분 및 브랜드 일관성
- **접근성 고려**: WCAG 2.1 AA 기준 색상 대비율 4.5:1 이상 확보
- **다크모드 지원**: 자동 시스템 테마 감지 및 수동 전환 기능

### 타이포그래피 위계
- **명확한 정보 구조**: H1~H6 헤딩을 통한 계층적 정보 표현
- **가독성 최적화**: Inter 폰트 및 적절한 행간으로 읽기 편의성 향상
- **반응형 타이포그래피**: 화면 크기별 최적화된 폰트 크기

### 스케일 가능한 간격
- **4px 기반 간격 시스템**: 일관된 리듬감과 정렬
- **시맨틱 간격**: xs, sm, md, lg 등 의미 기반 간격 토큰
- **컴포넌트별 최적화**: 각 UI 요소별 적절한 여백과 패딩

---

## ⚡ 성능 최적화

### CSS 변수 최적화
- **브라우저 캐싱**: CSS 변수의 효율적인 브라우저 캐싱 활용
- **계산 최소화**: 런타임 색상 계산 대신 미리 정의된 토큰 사용
- **트리 쉐이킹**: 사용하지 않는 디자인 토큰 자동 제거

### 웹폰트 최적화
- **폰트 프리로딩**: 중요 폰트의 미리 로딩으로 FOUT 방지
- **폰트 서브셋**: 한글과 영문만 포함한 경량화된 폰트 파일
- **폰트 디스플레이 최적화**: font-display: swap으로 로딩 성능 개선

---

## 🧪 Definition of Done

### 디자인 토큰 구현 요구사항
- [ ] CSS Variables로 모든 디자인 토큰 정의 완료
- [ ] TypeScript 타입 정의로 타입 안전성 확보
- [ ] 8가지 프로젝트 색상 시스템 (각 50-900 스케일) 구현
- [ ] 라이트/다크 테마 자동 전환 및 수동 설정 지원

### 타이포그래피 시스템 요구사항
- [ ] 9단계 폰트 크기 시스템 (xs ~ 9xl) 구현
- [ ] Typography 컴포넌트 및 미리 정의된 컴포넌트들 (H1~H6, Body1/2 등)
- [ ] Inter 웹폰트 최적화 (프리로딩, 서브셋, font-display)
- [ ] 접근성을 고려한 충분한 색상 대비율 확보

### 간격 및 레이아웃 요구사항
- [ ] 4px 기반 간격 시스템 완전 구현
- [ ] 시맨틱 간격 토큰 (xs, sm, md, lg, xl 등) 정의
- [ ] 반응형 간격 유틸리티 함수 구현
- [ ] 레이아웃 특화 간격 토큰 (컨테이너, 섹션, 컴포넌트)

### 유틸리티 및 도구 요구사항
- [ ] 디자인 토큰 접근 유틸리티 함수들 구현
- [ ] 동적 색상 생성 및 조작 함수
- [ ] 프로젝트 ID 기반 색상 매핑 시스템
- [ ] CSS 클래스 자동 생성 유틸리티

### 품질 보증 요구사항
- [ ] Jest 단위 테스트 커버리지 > 90%
- [ ] Storybook으로 모든 디자인 토큰 시각적 문서화
- [ ] 색상 접근성 테스트 통과 (대비율 4.5:1 이상)
- [ ] 크로스 브라우저 호환성 검증 (Chrome, Firefox, Safari, Edge)

---

## 📚 관련 문서

- [05-design-system-foundations.md](../ui-architecture/05-design-system-foundations.md) - 디자인 시스템 기초 아키텍처
- [Story 2.15: Component Styling Patterns](./2.15.component-styling-patterns.md) - 컴포넌트 스타일링
- [Story 2.16: Theme & Responsive Design](./2.16.theme-responsive-design.md) - 테마 및 반응형
- [Story 1.8: Design System Theme Implementation](./1.8.design-system-theme-implementation.md) - 기존 테마 구현

---

## 📈 성공 지표

### 개발 효율성 지표
- **디자인 토큰 활용률**: 하드코딩된 스타일 값 < 5%
- **타입 안전성**: TypeScript 컴파일 에러 0개
- **컴포넌트 재사용률**: 기본 Typography 컴포넌트 사용률 > 80%
- **개발 속도**: 새 컴포넌트 스타일링 시간 50% 단축

### 사용자 경험 지표  
- **시각적 일관성**: 디자인 시스템 준수율 > 95%
- **접근성 점수**: Lighthouse 접근성 점수 > 95
- **로딩 성능**: 폰트 로딩으로 인한 CLS < 0.1
- **테마 전환**: 다크/라이트 모드 전환 지연시간 < 100ms