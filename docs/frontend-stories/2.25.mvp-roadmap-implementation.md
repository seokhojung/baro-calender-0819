# Story 2.25: MVP 로드맵 구현 및 관리 시스템

## Status
Draft

## Story
**As a** 개발팀,
**I want** 단계별 MVP 개발 로드맵과 진행률 추적 시스템을 통해,
**so that** 5단계 Phase 기반으로 체계적인 개발 진행과 실시간 성과 모니터링을 할 수 있다.

## Story Points
**8**

## Prerequisites
- [ ] Story 2.20 (프로젝트 설정 가이드) 완료
- [ ] Story 2.12 (관찰가능성 모니터링) 완료
- [ ] Story 2.21 (CI 파이프라인 성능) 완료

## Acceptance Criteria
1. **5단계 Phase 관리**: 기본 캘린더→이벤트→프로젝트→고급기능→배포 단계별 관리해야 한다
2. **진행률 시각화**: 각 Phase별 진행률과 완료도를 실시간 대시보드로 제공해야 한다
3. **마일스톤 추적**: 주차별 목표와 달성도를 자동으로 추적하고 알림해야 한다
4. **기술 검증**: 각 Phase 완료 시 기술적 검증 기준 자동 체크해야 한다
5. **의존성 관리**: Phase 간 의존성과 블로킹 이슈를 시각적으로 표시해야 한다
6. **성과 측정**: Core Web Vitals, 번들 크기 등 핵심 메트릭 추적해야 한다
7. **팀 협업 지원**: 개발자별 작업 할당과 진행 상황 공유해야 한다
8. **자동 보고**: 주간/월간 진행 보고서 자동 생성 및 배포해야 한다

## Tasks / Subtasks

- [ ] **1단계: MVP Phase 데이터 모델링** (AC: 1, 5)
  - [ ] RoadmapPhase.tsx 타입 정의
    ```tsx
    interface RoadmapPhase {
      id: string
      name: string
      description: string
      duration: number // weeks
      startDate?: Date
      endDate?: Date
      status: 'NOT_STARTED' | 'IN_PROGRESS' | 'COMPLETED' | 'BLOCKED'
      progress: number // 0-100
      prerequisites: string[]
      
      // 세부 작업 목록
      tasks: PhaseTask[]
      
      // 기술적 요구사항
      technicalRequirements: TechnicalRequirement[]
      
      // 검증 기준
      validationCriteria: ValidationCriterion[]
      
      // 메트릭 목표
      performanceTargets: PerformanceTarget[]
    }
    
    interface PhaseTask {
      id: string
      title: string
      description: string
      week: number
      estimatedHours: number
      actualHours?: number
      assignee?: string
      status: TaskStatus
      blockers: string[]
      dependencies: string[]
      completedAt?: Date
    }
    
    interface TechnicalRequirement {
      id: string
      category: 'FRAMEWORK' | 'LIBRARY' | 'TOOL' | 'INFRASTRUCTURE'
      name: string
      version?: string
      mandatory: boolean
      implemented: boolean
      notes?: string
    }
    
    interface ValidationCriterion {
      id: string
      description: string
      type: 'FUNCTIONAL' | 'PERFORMANCE' | 'SECURITY' | 'ACCESSIBILITY'
      automated: boolean
      passed: boolean
      testCommand?: string
      expectedResult: string
      actualResult?: string
    }
    ```
  - [ ] 5단계 MVP Phase 데이터 정의
    ```tsx
    export const MVP_PHASES: RoadmapPhase[] = [
      {
        id: 'phase-1',
        name: 'Phase 1: 기본 캘린더',
        description: '기본적인 캘린더 뷰와 네비게이션',
        duration: 2,
        tasks: [
          {
            id: 'task-1-1',
            title: 'Next.js 프로젝트 설정',
            week: 1,
            estimatedHours: 8,
            status: 'NOT_STARTED'
          },
          {
            id: 'task-1-2', 
            title: 'ShadCN UI 컴포넌트 설치',
            week: 1,
            estimatedHours: 4,
            status: 'NOT_STARTED'
          }
        ],
        technicalRequirements: [
          {
            id: 'req-1-1',
            category: 'FRAMEWORK',
            name: 'Next.js',
            version: '^14.0.0',
            mandatory: true,
            implemented: false
          }
        ],
        validationCriteria: [
          {
            id: 'val-1-1',
            description: '캘린더가 올바르게 렌더링되는가?',
            type: 'FUNCTIONAL',
            automated: true,
            passed: false,
            testCommand: 'npm run test:calendar-render'
          }
        ]
      }
      // ... 나머지 4개 Phase
    ]
    ```
  - [ ] Phase 의존성 그래프 구현
  - [ ] 블로킹 이슈 추적 시스템

- [ ] **2단계: 진행률 대시보드 구현** (AC: 2, 6)
  - [ ] RoadmapDashboard.tsx 구현
    ```tsx
    const RoadmapDashboard: React.FC = () => {
      const { phases, updatePhaseProgress, getOverallProgress } = useRoadmapStore()
      const overallProgress = getOverallProgress()
      
      return (
        <div className="p-6 space-y-6">
          {/* 전체 진행률 */}
          <Card className="p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-2xl font-bold">MVP 개발 진행률</h2>
              <Badge variant={overallProgress >= 80 ? 'success' : 'secondary'}>
                {overallProgress.toFixed(1)}% 완료
              </Badge>
            </div>
            
            <Progress value={overallProgress} className="h-3 mb-4" />
            
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="text-center">
                <div className="text-2xl font-bold text-green-600">
                  {phases.filter(p => p.status === 'COMPLETED').length}
                </div>
                <div className="text-sm text-muted-foreground">완료된 Phase</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600">
                  {phases.filter(p => p.status === 'IN_PROGRESS').length}
                </div>
                <div className="text-sm text-muted-foreground">진행 중</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-red-600">
                  {phases.filter(p => p.status === 'BLOCKED').length}
                </div>
                <div className="text-sm text-muted-foreground">블로킹됨</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-gray-600">
                  {phases.reduce((sum, p) => sum + p.tasks.length, 0)}
                </div>
                <div className="text-sm text-muted-foreground">총 작업 수</div>
              </div>
            </div>
          </Card>
          
          {/* Phase별 상세 진행률 */}
          <div className="grid gap-4">
            {phases.map(phase => (
              <PhaseProgressCard 
                key={phase.id} 
                phase={phase}
                onUpdateProgress={updatePhaseProgress}
              />
            ))}
          </div>
          
          {/* 성능 메트릭 */}
          <PerformanceMetricsCard />
          
          {/* 팀 작업 현황 */}
          <TeamWorkloadCard />
        </div>
      )
    }
    ```
  - [ ] PhaseProgressCard 상세 구현
  - [ ] 실시간 진행률 업데이트 시스템
  - [ ] 차트 및 시각화 컴포넌트

- [ ] **3단계: 마일스톤 추적 시스템** (AC: 3)
  - [ ] MilestoneTracker.tsx 구현
    ```tsx
    interface Milestone {
      id: string
      phaseId: string
      week: number
      title: string
      description: string
      targetDate: Date
      actualDate?: Date
      status: 'UPCOMING' | 'DUE' | 'COMPLETED' | 'OVERDUE'
      criticalPath: boolean
      dependencies: string[]
      deliverables: Deliverable[]
    }
    
    interface Deliverable {
      id: string
      name: string
      type: 'CODE' | 'DOCUMENTATION' | 'TEST' | 'DEPLOYMENT'
      completed: boolean
      url?: string
      reviewRequired: boolean
    }
    
    const MilestoneTracker: React.FC = () => {
      const { milestones, checkMilestoneStatus, sendMilestoneAlert } = useMilestoneStore()
      const upcomingMilestones = milestones.filter(m => 
        m.status === 'UPCOMING' && 
        isWithinDays(m.targetDate, 7)
      )
      
      useEffect(() => {
        // 마일스톤 상태 자동 체크
        const interval = setInterval(() => {
          milestones.forEach(milestone => {
            const newStatus = checkMilestoneStatus(milestone)
            if (newStatus !== milestone.status) {
              updateMilestoneStatus(milestone.id, newStatus)
              
              if (newStatus === 'OVERDUE') {
                sendMilestoneAlert(milestone, 'OVERDUE')
              } else if (newStatus === 'DUE') {
                sendMilestoneAlert(milestone, 'DUE_SOON')
              }
            }
          })
        }, 60000) // 1분마다 체크
        
        return () => clearInterval(interval)
      }, [milestones])
      
      return (
        <Card className="p-6">
          <div className="flex items-center justify-between mb-6">
            <h3 className="text-lg font-semibold">마일스톤 추적</h3>
            <Button onClick={() => generateMilestoneReport()}>
              보고서 생성
            </Button>
          </div>
          
          {/* 임박한 마일스톤 알림 */}
          {upcomingMilestones.length > 0 && (
            <Alert className="mb-4">
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>다가오는 마일스톤</AlertTitle>
              <AlertDescription>
                {upcomingMilestones.length}개의 마일스톤이 일주일 내에 예정되어 있습니다.
              </AlertDescription>
            </Alert>
          )}
          
          {/* 마일스톤 타임라인 */}
          <div className="space-y-4">
            {milestones.map(milestone => (
              <MilestoneCard 
                key={milestone.id}
                milestone={milestone}
                onStatusUpdate={updateMilestoneStatus}
              />
            ))}
          </div>
        </Card>
      )
    }
    ```
  - [ ] 마일스톤 알림 시스템 (이메일, 슬랙)
  - [ ] 크리티컬 패스 식별 알고리즘
  - [ ] 마일스톤 지연 위험 예측

- [ ] **4단계: 기술 검증 자동화** (AC: 4)
  - [ ] TechnicalValidation.tsx 구현
    ```tsx
    export class TechnicalValidator {
      static async validatePhase(phaseId: string): Promise<ValidationResult> {
        const phase = await getRoadmapPhase(phaseId)
        const results: ValidationResult = {
          phaseId,
          overallScore: 0,
          criteria: [],
          recommendations: []
        }
        
        // 각 검증 기준 실행
        for (const criterion of phase.validationCriteria) {
          const result = await this.runValidation(criterion)
          results.criteria.push(result)
        }
        
        // 전체 점수 계산
        results.overallScore = results.criteria
          .reduce((sum, c) => sum + (c.passed ? 1 : 0), 0) / 
          results.criteria.length * 100
        
        // 개선 권장사항 생성
        results.recommendations = await this.generateRecommendations(results)
        
        return results
      }
      
      private static async runValidation(criterion: ValidationCriterion): Promise<CriterionResult> {
        switch (criterion.type) {
          case 'FUNCTIONAL':
            return await this.runFunctionalTest(criterion)
          case 'PERFORMANCE':
            return await this.runPerformanceTest(criterion)
          case 'SECURITY':
            return await this.runSecurityTest(criterion)
          case 'ACCESSIBILITY':
            return await this.runA11yTest(criterion)
          default:
            return { id: criterion.id, passed: false, error: 'Unknown test type' }
        }
      }
      
      private static async runPerformanceTest(criterion: ValidationCriterion): Promise<CriterionResult> {
        try {
          // Lighthouse CI를 사용한 성능 테스트
          const result = await execAsync('npm run lighthouse:ci')
          
          // Core Web Vitals 파싱
          const metrics = this.parseWebVitals(result.stdout)
          
          const passed = metrics.lcp <= 2500 && // LCP < 2.5s
                        metrics.fid <= 100 &&   // FID < 100ms
                        metrics.cls <= 0.1      // CLS < 0.1
          
          return {
            id: criterion.id,
            passed,
            score: passed ? 100 : 0,
            details: {
              lcp: metrics.lcp,
              fid: metrics.fid,
              cls: metrics.cls
            }
          }
        } catch (error) {
          return {
            id: criterion.id,
            passed: false,
            error: error.message
          }
        }
      }
    }
    
    const TechnicalValidationPanel: React.FC<Props> = ({ phaseId }) => {
      const [validationResult, setValidationResult] = useState<ValidationResult>()
      const [isValidating, setIsValidating] = useState(false)
      
      const runValidation = async () => {
        setIsValidating(true)
        try {
          const result = await TechnicalValidator.validatePhase(phaseId)
          setValidationResult(result)
        } catch (error) {
          toast.error('검증 실행 중 오류가 발생했습니다.')
        } finally {
          setIsValidating(false)
        }
      }
      
      return (
        <Card className="p-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-semibold">기술 검증</h3>
            <Button onClick={runValidation} disabled={isValidating}>
              {isValidating ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  검증 중...
                </>
              ) : (
                '검증 실행'
              )}
            </Button>
          </div>
          
          {validationResult && (
            <div className="space-y-4">
              <div className="flex items-center gap-2">
                <Progress value={validationResult.overallScore} className="flex-1" />
                <span className="text-sm font-medium">
                  {validationResult.overallScore.toFixed(0)}%
                </span>
              </div>
              
              {/* 검증 기준별 결과 */}
              <div className="space-y-2">
                {validationResult.criteria.map(criterion => (
                  <div key={criterion.id} className="flex items-center justify-between p-2 bg-muted rounded">
                    <span className="text-sm">{criterion.description}</span>
                    {criterion.passed ? (
                      <CheckCircle className="h-4 w-4 text-green-500" />
                    ) : (
                      <XCircle className="h-4 w-4 text-red-500" />
                    )}
                  </div>
                ))}
              </div>
              
              {/* 권장사항 */}
              {validationResult.recommendations.length > 0 && (
                <div>
                  <h4 className="text-sm font-medium mb-2">개선 권장사항</h4>
                  <ul className="text-sm space-y-1">
                    {validationResult.recommendations.map((rec, index) => (
                      <li key={index} className="flex items-start gap-2">
                        <ArrowRight className="h-3 w-3 mt-1 text-muted-foreground" />
                        {rec}
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </Card>
      )
    }
    ```
  - [ ] CI/CD 파이프라인 통합
  - [ ] 자동 테스트 결과 수집
  - [ ] 검증 실패 시 알림 시스템

- [ ] **5단계: 성과 측정 시스템** (AC: 6)
  - [ ] PerformanceMetrics.tsx 구현
    ```tsx
    interface PerformanceMetrics {
      timestamp: Date
      phase: string
      
      // Core Web Vitals
      lcp: number // Largest Contentful Paint
      fid: number // First Input Delay  
      cls: number // Cumulative Layout Shift
      
      // Bundle Metrics
      bundleSize: number
      chunkCount: number
      unusedBytes: number
      
      // Runtime Metrics
      memoryUsage: number
      renderTime: number
      interactionLatency: number
      
      // Business Metrics
      taskCompletionRate: number
      featureAdoptionRate: number
      userSatisfactionScore: number
    }
    
    const PerformanceTracker: React.FC = () => {
      const [metrics, setMetrics] = useState<PerformanceMetrics[]>([])
      const [selectedTimeRange, setSelectedTimeRange] = useState('7d')
      
      // 실시간 메트릭 수집
      useEffect(() => {
        const collectMetrics = async () => {
          try {
            // Core Web Vitals 수집
            const webVitals = await measureWebVitals()
            
            // Bundle 분석
            const bundleStats = await analyzeBundleSize()
            
            // 런타임 성능 측정
            const runtimeStats = await measureRuntimePerformance()
            
            const newMetrics: PerformanceMetrics = {
              timestamp: new Date(),
              phase: getCurrentPhase(),
              ...webVitals,
              ...bundleStats,
              ...runtimeStats,
              taskCompletionRate: calculateTaskCompletionRate(),
              featureAdoptionRate: calculateFeatureAdoption(),
              userSatisfactionScore: getUserSatisfactionScore()
            }
            
            setMetrics(prev => [...prev, newMetrics].slice(-100)) // 최근 100개 유지
            
            // 목표치 대비 경고
            if (newMetrics.lcp > 2500) {
              toast.warning('LCP가 목표치(2.5s)를 초과했습니다.')
            }
            
          } catch (error) {
            console.error('메트릭 수집 실패:', error)
          }
        }
        
        // 10분마다 수집
        const interval = setInterval(collectMetrics, 600000)
        collectMetrics() // 초기 실행
        
        return () => clearInterval(interval)
      }, [])
      
      const filteredMetrics = filterMetricsByTimeRange(metrics, selectedTimeRange)
      
      return (
        <Card className="p-6">
          <div className="flex items-center justify-between mb-6">
            <h3 className="text-lg font-semibold">성능 메트릭</h3>
            <Select value={selectedTimeRange} onValueChange={setSelectedTimeRange}>
              <SelectTrigger className="w-32">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="1d">1일</SelectItem>
                <SelectItem value="7d">7일</SelectItem>
                <SelectItem value="30d">30일</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Core Web Vitals 차트 */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <MetricCard
              title="LCP (목표: <2.5s)"
              value={getLatestMetric('lcp')}
              trend={calculateTrend(filteredMetrics, 'lcp')}
              format="duration"
              threshold={2500}
            />
            <MetricCard
              title="FID (목표: <100ms)"
              value={getLatestMetric('fid')}
              trend={calculateTrend(filteredMetrics, 'fid')}
              format="duration"
              threshold={100}
            />
            <MetricCard
              title="CLS (목표: <0.1)"
              value={getLatestMetric('cls')}
              trend={calculateTrend(filteredMetrics, 'cls')}
              format="decimal"
              threshold={0.1}
            />
          </div>
          
          {/* 번들 크기 추이 */}
          <div className="mb-6">
            <h4 className="text-sm font-medium mb-3">번들 크기 추이</h4>
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={filteredMetrics}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="timestamp" />
                <YAxis />
                <Tooltip />
                <Line type="monotone" dataKey="bundleSize" stroke="#8884d8" />
              </LineChart>
            </ResponsiveContainer>
          </div>
          
          {/* 작업 완료율 */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <h4 className="text-sm font-medium mb-3">작업 완료율</h4>
              <div className="text-2xl font-bold mb-2">
                {getLatestMetric('taskCompletionRate').toFixed(1)}%
              </div>
              <Progress value={getLatestMetric('taskCompletionRate')} />
            </div>
            <div>
              <h4 className="text-sm font-medium mb-3">사용자 만족도</h4>
              <div className="text-2xl font-bold mb-2">
                {getLatestMetric('userSatisfactionScore').toFixed(1)}/10
              </div>
              <Progress value={getLatestMetric('userSatisfactionScore') * 10} />
            </div>
          </div>
        </Card>
      )
    }
    ```
  - [ ] 메트릭 수집 자동화
  - [ ] 목표치 대비 알림 시스템
  - [ ] 성능 회귀 감지

- [ ] **6단계: 팀 협업 및 보고 시스템** (AC: 7, 8)
  - [ ] TeamCollaboration.tsx + ReportGeneration.tsx 구현
    ```tsx
    const TeamWorkloadDashboard: React.FC = () => {
      const { teamMembers, getWorkload, getProductivity } = useTeamStore()
      
      return (
        <Card className="p-6">
          <h3 className="text-lg font-semibold mb-4">팀 작업 현황</h3>
          
          <div className="grid gap-4">
            {teamMembers.map(member => (
              <div key={member.id} className="border rounded-lg p-4">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center gap-3">
                    <Avatar className="h-8 w-8">
                      <AvatarImage src={member.avatar} />
                      <AvatarFallback>{member.name.charAt(0)}</AvatarFallback>
                    </Avatar>
                    <div>
                      <h4 className="font-medium">{member.name}</h4>
                      <p className="text-sm text-muted-foreground">{member.role}</p>
                    </div>
                  </div>
                  <Badge variant={getWorkloadStatus(member.id)}>
                    {getWorkload(member.id).toFixed(0)}% 사용률
                  </Badge>
                </div>
                
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>진행 중인 작업</span>
                    <span>{member.activeTasks.length}개</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>완료한 작업</span>
                    <span>{member.completedTasks.length}개</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>생산성 지수</span>
                    <span>{getProductivity(member.id).toFixed(1)}/10</span>
                  </div>
                </div>
                
                <Progress value={getWorkload(member.id)} className="mt-3" />
              </div>
            ))}
          </div>
        </Card>
      )
    }
    
    export class ReportGenerator {
      static async generateWeeklyReport(): Promise<WeeklyReport> {
        const phases = await getRoadmapPhases()
        const metrics = await getWeeklyMetrics()
        const teamStats = await getTeamStats()
        
        return {
          reportDate: new Date(),
          period: getWeekPeriod(),
          
          summary: {
            overallProgress: calculateOverallProgress(phases),
            completedTasks: teamStats.completedTasks,
            blockedTasks: teamStats.blockedTasks,
            nextWeekTargets: getNextWeekTargets(phases)
          },
          
          phaseProgress: phases.map(phase => ({
            phaseName: phase.name,
            progress: phase.progress,
            tasksCompleted: phase.tasks.filter(t => t.status === 'COMPLETED').length,
            blockers: phase.tasks.filter(t => t.blockers.length > 0),
            nextMilestone: getNextMilestone(phase.id)
          })),
          
          performance: {
            coreWebVitals: metrics.webVitals,
            bundleSize: metrics.bundleSize,
            testCoverage: metrics.testCoverage
          },
          
          risks: identifyRisks(phases, metrics),
          recommendations: generateRecommendations(phases, metrics)
        }
      }
      
      static async sendReport(report: WeeklyReport, recipients: string[]): Promise<void> {
        // 이메일 템플릿 생성
        const emailTemplate = this.generateEmailTemplate(report)
        
        // Slack 메시지 생성
        const slackMessage = this.generateSlackMessage(report)
        
        // 병렬 전송
        await Promise.all([
          sendEmail(recipients, '주간 MVP 진행 보고서', emailTemplate),
          sendSlackMessage(process.env.SLACK_CHANNEL, slackMessage)
        ])
      }
    }
    ```
  - [ ] 주간/월간 보고서 자동 생성
  - [ ] 이메일/슬랙 알림 시스템
  - [ ] 팀 생산성 분석

## Dev Notes

### MVP Phase 정의
**[Source: docs/ui-architecture/17-mvp-roadmap.md]**
- **Phase 1**: 기본 캘린더 (2주) - Next.js 설정, 기본 뷰
- **Phase 2**: 이벤트 관리 (3주) - CRUD, 드래그앤드롭
- **Phase 3**: 프로젝트 관리 (2주) - 분류, 색상 시스템  
- **Phase 4**: 고급 기능 (3주) - 반복 이벤트, 알림, 공유
- **Phase 5**: 최적화/배포 (2주) - 성능, 모니터링

### 성능 목표치
**[Source: docs/ui-architecture/08-runtime-performance.md]**
- **LCP**: < 2.5초
- **FID**: < 100ms
- **CLS**: < 0.1
- **번들 크기**: < 500KB (gzipped)
- **테스트 커버리지**: > 80%

### 자동화 도구 스택
- **CI/CD**: GitHub Actions
- **성능 측정**: Lighthouse CI
- **번들 분석**: webpack-bundle-analyzer
- **알림**: Slack API, SendGrid
- **보고서**: Chart.js, React-PDF

---

*이 스토리는 체계적인 MVP 개발을 위한 완전한 로드맵 관리 시스템을 제공합니다. 실시간 추적과 자동화된 검증으로 프로젝트 성공을 보장합니다.*