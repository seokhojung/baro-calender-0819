# üîÑ Story 2.19: Ïã§ÏãúÍ∞Ñ WebSocket ÎèôÍ∏∞Ìôî ÏãúÏä§ÌÖú Íµ¨ÌòÑ

## üìã Story Ï†ïÎ≥¥
- **Story Î≤ÑÏ†Ñ**: 1.0
- **ÏûëÏÑ±Ïùº**: 2025-08-19
- **ÏûëÏÑ±Ïûê**: Frontend Development Team
- **ÌîÑÎ°úÏ†ùÌä∏Î™Ö**: Î∞îÎ°úÏ∫òÎ¶∞Îçî (Baro Calendar)
- **Sprint**: Frontend Implementation - Phase 15
- **Story Point**: 18 (13 ‚Üí 18Î°ú Ïû¨Ï°∞Ï†ï)
- **Ïö∞ÏÑ†ÏàúÏúÑ**: High
- **Í¥ÄÎ†® UI ÏïÑÌÇ§ÌÖçÏ≤ò Î¨∏ÏÑú**: `15-realtime-websocket-sync.md`

---

## üéØ Story Í∞úÏöî

Î∞îÎ°úÏ∫òÎ¶∞ÎçîÏùò **Ïã§ÏãúÍ∞Ñ WebSocket ÎèôÍ∏∞Ìôî ÏãúÏä§ÌÖú**ÏùÑ Íµ¨ÌòÑÌïòÏó¨ Îã§Ï§ë ÏÇ¨Ïö©Ïûê ÌôòÍ≤ΩÏóêÏÑú Ïã§ÏãúÍ∞Ñ Ï∫òÎ¶∞Îçî Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞ÌôîÏôÄ ÌòëÏóÖ Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.

---

## üé¨ ÏÇ¨Ïö©Ïûê Ïä§ÌÜ†Î¶¨

### üìù Ï£ºÏöî ÏÇ¨Ïö©Ïûê Ïä§ÌÜ†Î¶¨

**As a** Î∞îÎ°úÏ∫òÎ¶∞Îçî ÏÇ¨Ïö©Ïûê  
**I want** Îã§Î•∏ ÏÇ¨Ïö©ÏûêÏôÄ Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ï∫òÎ¶∞Îçî Îç∞Ïù¥ÌÑ∞Î•º ÎèôÍ∏∞ÌôîÌïòÍ≥† ÌòëÏóÖÌïòÍ≥† Ïã∂Ïñ¥  
**So that** ÌåÄÏõêÎì§Í≥º ÏõêÌôúÌïú ÏùºÏ†ï Í¥ÄÎ¶¨ÏôÄ ÌòëÏóÖÏù¥ Í∞ÄÎä•Ìï¥

### üîç ÏÉÅÏÑ∏ ÏÇ¨Ïö©Ïûê ÏöîÍµ¨ÏÇ¨Ìï≠

1. **Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ ÎèôÍ∏∞Ìôî**
   - Îã§Î•∏ ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÉùÏÑ±/ÏàòÏ†ï/ÏÇ≠Ï†úÌïú Ïù¥Î≤§Ìä∏ Ïã§ÏãúÍ∞Ñ ÌôïÏù∏
   - ÏûêÎèô Ï∫òÎ¶∞Îçî ÏÉàÎ°úÍ≥†Ïπ® ÏóÜÎäî Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
   - Ï∂©Îèå Ìï¥Í≤∞ Î∞è ÎèôÏãúÏÑ± Ï†úÏñ¥

2. **WebSocket Ïó∞Í≤∞ Í¥ÄÎ¶¨**
   - ÏûêÎèô Ïû¨Ïó∞Í≤∞ Î∞è Ïó∞Í≤∞ ÏÉÅÌÉú ÌëúÏãú
   - Ïò§ÌîÑÎùºÏù∏ Î©îÏãúÏßÄ ÌÅêÏûâ Î∞è Ïò®ÎùºÏù∏ Ïãú ÏûêÎèô Ï†ÑÏÜ°
   - ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂àÏïàÏ†ï ÌôòÍ≤Ω ÎåÄÏùë

3. **Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ Í∏∞Îä•**
   - Îã§Î•∏ ÏÇ¨Ïö©ÏûêÏùò Ïã§ÏãúÍ∞Ñ Ïª§ÏÑú ÏúÑÏπò ÌëúÏãú
   - ÌÉÄÏù¥Ìïë Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Î∞è ÏÑ†ÌÉù ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
   - ÏÇ¨Ïö©ÏûêÎ≥Ñ ÏÉâÏÉÅ Íµ¨Î∂Ñ Î∞è ÏãùÎ≥Ñ

---

## ‚öôÔ∏è Í∏∞Ïà†Ï†Å ÏöîÍµ¨ÏÇ¨Ìï≠

### üèóÔ∏è ÏïÑÌÇ§ÌÖçÏ≤ò ÏöîÍµ¨ÏÇ¨Ìï≠

1. **WebSocket Í∏∞Î∞ò Ïã§ÏãúÍ∞Ñ ÌÜµÏã†**
   ```typescript
   - WebSocket Manager ÌÅ¥ÎûòÏä§ Íµ¨ÌòÑ
   - ÏûêÎèô Ïû¨Ïó∞Í≤∞ Î©îÏª§ÎãàÏ¶ò (ÏßÄÏàò Î∞±Ïò§ÌîÑ)
   - Î©îÏãúÏßÄ ÌÅêÏûâ ÏãúÏä§ÌÖú
   - Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
   ```

2. **React 19.1.0 + TypeScript 5.5.4 ÌÜµÌï©**
   ```typescript
   - useRealtimeSync Ïª§Ïä§ÌÖÄ Hook
   - Ïã§ÏãúÍ∞Ñ ÏÉÅÌÉú Í¥ÄÎ¶¨ÏôÄ Zustand Ïó∞Îèô
   - ÌÉÄÏûÖ ÏïàÏ†ÑÌïú WebSocket Î©îÏãúÏßÄ Ï≤òÎ¶¨
   - Î©îÎ™®Î¶¨ Î¶¨ÌÅ¨ Î∞©ÏßÄ cleanup
   ```

3. **Î≥¥Ïïà Î∞è Ïù∏Ï¶ù**
   ```typescript
   - JWT ÌÜ†ÌÅ∞ Í∏∞Î∞ò WebSocket Ïù∏Ï¶ù
   - Î©îÏãúÏßÄ Í∂åÌïú Í≤ÄÏ¶ù
   - ÌîÑÎ°úÏ†ùÌä∏Î≥Ñ Ï†ëÍ∑º Ï†úÏñ¥
   - XSS/CSRF Î≥¥Ïïà Í∞ïÌôî
   ```

---

## üõ†Ô∏è Íµ¨ÌòÑ ÏÉÅÏÑ∏

### 1Ô∏è‚É£ WebSocket Manager Íµ¨ÌòÑ

```typescript
// src/lib/realtime/websocket-manager.ts
interface WebSocketMessage {
  type: string
  payload: any
  timestamp: number
  id: string
  userId?: string
}

interface WebSocketConfig {
  url: string
  reconnectInterval?: number
  maxReconnectAttempts?: number
  heartbeatInterval?: number
  onMessage?: (message: WebSocketMessage) => void
  onConnect?: () => void
  onDisconnect?: () => void
  onError?: (error: Event) => void
}

export class WebSocketManager {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private reconnectTimer: NodeJS.Timeout | null = null
  private heartbeatTimer: NodeJS.Timeout | null = null
  private messageQueue: WebSocketMessage[] = []
  private isConnected = false
  private isReconnecting = false
  
  constructor(private config: WebSocketConfig) {
    this.config = {
      reconnectInterval: 1000,
      maxReconnectAttempts: 10,
      heartbeatInterval: 30000,
      ...config
    }
  }
  
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        if (this.ws?.readyState === WebSocket.CONNECTING) return
        
        this.ws = new WebSocket(this.config.url)
        
        this.ws.onopen = () => {
          this.isConnected = true
          this.isReconnecting = false
          this.reconnectAttempts = 0
          
          this.startHeartbeat()
          this.config.onConnect?.()
          this.flushMessageQueue()
          
          resolve()
        }
        
        this.ws.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data)
            
            // Heartbeat ÏùëÎãµ Ï≤òÎ¶¨
            if (message.type === 'HEARTBEAT_RESPONSE') return
            
            this.config.onMessage?.(message)
          } catch (error) {
            console.error('Failed to parse WebSocket message:', error)
          }
        }
        
        this.ws.onclose = (event) => {
          this.isConnected = false
          this.stopHeartbeat()
          this.config.onDisconnect?.()
          
          // Ï†ïÏÉÅ Ï¢ÖÎ£åÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
          if (!event.wasClean) {
            this.scheduleReconnect()
          }
        }
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error)
          this.config.onError?.(error)
          reject(error)
        }
      } catch (error) {
        console.error('Failed to create WebSocket connection:', error)
        this.scheduleReconnect()
        reject(error)
      }
    })
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect')
      this.ws = null
    }
    
    this.stopHeartbeat()
    this.clearReconnectTimer()
    this.isConnected = false
    this.isReconnecting = false
  }
  
  send(message: Omit<WebSocketMessage, 'timestamp' | 'id'>): boolean {
    const fullMessage: WebSocketMessage = {
      ...message,
      timestamp: Date.now(),
      id: crypto.randomUUID(),
    }
    
    if (this.isConnected && this.ws?.readyState === WebSocket.OPEN) {
      try {
        this.ws.send(JSON.stringify(fullMessage))
        return true
      } catch (error) {
        console.error('Failed to send WebSocket message:', error)
        this.messageQueue.push(fullMessage)
        return false
      }
    } else {
      // Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÑ Í≤ΩÏö∞ ÌÅêÏóê Ï†ÄÏû•
      this.messageQueue.push(fullMessage)
      
      // ÌÅê ÌÅ¨Í∏∞ Ï†úÌïú (Î©îÎ™®Î¶¨ Î≥¥Ìò∏)
      if (this.messageQueue.length > 100) {
        this.messageQueue.shift()
      }
      
      return false
    }
  }
  
  private scheduleReconnect() {
    if (this.isReconnecting) return
    if (this.reconnectAttempts >= this.config.maxReconnectAttempts!) {
      console.error('Max reconnection attempts reached')
      return
    }
    
    this.isReconnecting = true
    const delay = Math.min(
      this.config.reconnectInterval! * Math.pow(2, this.reconnectAttempts),
      30000 // ÏµúÎåÄ 30Ï¥à
    )
    
    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++
      console.log(`Reconnection attempt ${this.reconnectAttempts}`)
      this.connect().catch(() => {
        this.scheduleReconnect()
      })
    }, delay)
  }
  
  private flushMessageQueue() {
    while (this.messageQueue.length > 0 && this.isConnected) {
      const message = this.messageQueue.shift()
      if (message && this.ws?.readyState === WebSocket.OPEN) {
        try {
          this.ws.send(JSON.stringify(message))
        } catch (error) {
          console.error('Failed to flush queued message:', error)
          // Ïã§Ìå®Ìïú Î©îÏãúÏßÄÎ•º Îã§Ïãú ÌÅêÏóê Ï∂îÍ∞Ä
          this.messageQueue.unshift(message)
          break
        }
      }
    }
  }
  
  private startHeartbeat() {
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected) {
        this.send({
          type: 'HEARTBEAT',
          payload: { timestamp: Date.now() },
        })
      }
    }, this.config.heartbeatInterval!)
  }
  
  private stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer)
      this.heartbeatTimer = null
    }
  }
  
  private clearReconnectTimer() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }
  }
  
  getConnectionStatus() {
    return {
      isConnected: this.isConnected,
      isReconnecting: this.isReconnecting,
      reconnectAttempts: this.reconnectAttempts,
      queuedMessages: this.messageQueue.length,
    }
  }
}
```

### 2Ô∏è‚É£ Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ ÎèôÍ∏∞Ìôî ÏÑúÎπÑÏä§

```typescript
// src/lib/realtime/event-sync.ts
import { WebSocketManager } from './websocket-manager'
import { useCalendarStore } from '@/store/calendar-store'
import { useProjectStore } from '@/store/project-store'
import { toast } from 'sonner'

interface EventSyncMessage extends WebSocketMessage {
  payload: {
    event?: CalendarEvent
    eventId?: string
    projectId?: string
    userId?: string
    user?: User
  }
}

export class RealtimeEventSync {
  private wsManager: WebSocketManager
  private subscribedProjects = new Set<string>()
  private eventHandlers = new Map<string, Set<Function>>()
  
  constructor() {
    const wsUrl = this.buildWebSocketUrl()
    
    this.wsManager = new WebSocketManager({
      url: wsUrl,
      onMessage: this.handleMessage.bind(this),
      onConnect: this.handleConnect.bind(this),
      onDisconnect: this.handleDisconnect.bind(this),
      onError: this.handleError.bind(this),
    })
  }
  
  private buildWebSocketUrl(): string {
    const baseUrl = process.env.NEXT_PUBLIC_WS_ENDPOINT || 'ws://localhost:4000'
    const token = localStorage.getItem('auth_token')
    return `${baseUrl}/realtime?token=${encodeURIComponent(token || '')}`
  }
  
  async connect(): Promise<void> {
    try {
      await this.wsManager.connect()
    } catch (error) {
      console.error('Failed to connect to realtime service:', error)
      toast.error('Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§')
    }
  }
  
  disconnect() {
    this.wsManager.disconnect()
    this.subscribedProjects.clear()
    this.eventHandlers.clear()
  }
  
  subscribeToProject(projectId: string) {
    if (this.subscribedProjects.has(projectId)) return
    
    this.wsManager.send({
      type: 'SUBSCRIBE_PROJECT',
      payload: { projectId },
    })
    
    this.subscribedProjects.add(projectId)
  }
  
  unsubscribeFromProject(projectId: string) {
    if (!this.subscribedProjects.has(projectId)) return
    
    this.wsManager.send({
      type: 'UNSUBSCRIBE_PROJECT',
      payload: { projectId },
    })
    
    this.subscribedProjects.delete(projectId)
  }
  
  // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ù
  on(eventType: string, handler: Function) {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set())
    }
    this.eventHandlers.get(eventType)!.add(handler)
    
    return () => {
      this.eventHandlers.get(eventType)?.delete(handler)
    }
  }
  
  private emit(eventType: string, data: any) {
    this.eventHandlers.get(eventType)?.forEach(handler => {
      try {
        handler(data)
      } catch (error) {
        console.error(`Error in event handler for ${eventType}:`, error)
      }
    })
  }
  
  private handleMessage(message: EventSyncMessage) {
    // Î©îÏãúÏßÄ Í∂åÌïú Í≤ÄÏ¶ù
    if (!this.validateMessagePermission(message)) {
      console.warn('Unauthorized message received:', message.type)
      return
    }
    
    switch (message.type) {
      case 'EVENT_CREATED':
        this.handleEventCreated(message.payload.event!)
        break
      case 'EVENT_UPDATED':
        this.handleEventUpdated(message.payload.event!)
        break
      case 'EVENT_DELETED':
        this.handleEventDeleted(message.payload.eventId!)
        break
      case 'PROJECT_UPDATED':
        this.handleProjectUpdated(message.payload)
        break
      case 'USER_JOINED_PROJECT':
        this.handleUserJoinedProject(message.payload)
        break
      case 'USER_LEFT_PROJECT':
        this.handleUserLeftProject(message.payload)
        break
      case 'BULK_EVENTS_SYNC':
        this.handleBulkEventsSync(message.payload)
        break
      default:
        console.warn('Unknown message type:', message.type)
    }
    
    // Ïª§Ïä§ÌÖÄ Ïù¥Î≤§Ìä∏ Î∞úÏÉù
    this.emit(message.type, message.payload)
  }
  
  private validateMessagePermission(message: EventSyncMessage): boolean {
    const { payload } = message
    
    // ÌîÑÎ°úÏ†ùÌä∏ Í∂åÌïú ÌôïÏù∏
    if (payload.projectId) {
      return this.subscribedProjects.has(payload.projectId)
    }
    
    return true
  }
  
  private handleConnect() {
    console.log('Realtime sync connected')
    toast.success('Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞ÌôîÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§')
    
    // ÌòÑÏû¨ ÌôúÏÑ± ÌîÑÎ°úÏ†ùÌä∏Îì§ÏùÑ Îã§Ïãú Íµ¨ÎèÖ
    const selectedProject = useProjectStore.getState().selectedProject
    if (selectedProject) {
      this.subscribeToProject(selectedProject.id)
    }
    
    this.emit('connection_established', {})
  }
  
  private handleDisconnect() {
    console.log('Realtime sync disconnected')
    toast.warning('Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ï°åÏäµÎãàÎã§')
    
    this.emit('connection_lost', {})
  }
  
  private handleError(error: Event) {
    console.error('Realtime sync error:', error)
    this.emit('connection_error', error)
  }
  
  private handleEventCreated(event: CalendarEvent) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useCalendarStore.getState().addEvent(event)
    
    // ÏïåÎ¶º ÌëúÏãú
    toast.success(`ÏÉàÎ°úÏö¥ Ïù¥Î≤§Ìä∏Í∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§: ${event.title}`)
    
    // ÏÇ¨Ïö¥Îìú ÏïåÎ¶º (ÏÑ†ÌÉùÏÇ¨Ìï≠)
    this.playNotificationSound()
  }
  
  private handleEventUpdated(event: CalendarEvent) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useCalendarStore.getState().updateEvent(event.id, event)
    
    // ÏïåÎ¶º ÌëúÏãú
    toast.info(`Ïù¥Î≤§Ìä∏Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§: ${event.title}`)
  }
  
  private handleEventDeleted(eventId: string) {
    // ÏÇ≠Ï†úÎêú Ïù¥Î≤§Ìä∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const deletedEvent = useCalendarStore.getState().getEvent(eventId)
    
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useCalendarStore.getState().deleteEvent(eventId)
    
    // ÏïåÎ¶º ÌëúÏãú
    if (deletedEvent) {
      toast.warning(`Ïù¥Î≤§Ìä∏Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§: ${deletedEvent.title}`)
    }
  }
  
  private handleProjectUpdated(data: any) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useProjectStore.getState().updateProject(data.projectId, data.project)
    
    toast.info('ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§')
  }
  
  private handleUserJoinedProject(data: any) {
    // ÌîÑÎ°úÏ†ùÌä∏ Î©§Î≤Ñ Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
    useProjectStore.getState().fetchMembers(data.projectId)
    
    // ÏïåÎ¶º ÌëúÏãú
    toast.success(`${data.user.name}ÎãòÏù¥ ÌîÑÎ°úÏ†ùÌä∏Ïóê Ï∞∏Ïó¨ÌñàÏäµÎãàÎã§`)
  }
  
  private handleUserLeftProject(data: any) {
    // ÌîÑÎ°úÏ†ùÌä∏ Î©§Î≤Ñ Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
    useProjectStore.getState().fetchMembers(data.projectId)
    
    // ÏïåÎ¶º ÌëúÏãú
    toast.info(`${data.user.name}ÎãòÏù¥ ÌîÑÎ°úÏ†ùÌä∏Î•º Îñ†ÎÇ¨ÏäµÎãàÎã§`)
  }
  
  private handleBulkEventsSync(data: any) {
    // ÎåÄÎüâ Ïù¥Î≤§Ìä∏ ÎèôÍ∏∞Ìôî (Ï¥àÍ∏∞ Î°úÎî© Ïãú)
    const { events, projectId } = data
    useCalendarStore.getState().setEvents(events, projectId)
    
    toast.success(`${events.length}Í∞úÏùò Ïù¥Î≤§Ìä∏Í∞Ä ÎèôÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§`)
  }
  
  private playNotificationSound() {
    // ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ïÏóê Îî∞Îùº ÏïåÎ¶º ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù
    if (localStorage.getItem('notification_sound') === 'enabled') {
      try {
        const audio = new Audio('/sounds/notification.mp3')
        audio.volume = 0.3
        audio.play().catch(console.error)
      } catch (error) {
        console.error('Failed to play notification sound:', error)
      }
    }
  }
  
  getStatus() {
    return this.wsManager.getConnectionStatus()
  }
  
  getSubscribedProjects() {
    return Array.from(this.subscribedProjects)
  }
}
```

### 3Ô∏è‚É£ Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî React Hook

```typescript
// src/hooks/use-realtime-sync.ts
import { useEffect, useRef, useState, useCallback } from 'react'
import { RealtimeEventSync } from '@/lib/realtime/event-sync'
import { useProjectStore } from '@/store/project-store'

interface RealtimeSyncStatus {
  isConnected: boolean
  isReconnecting: boolean
  reconnectAttempts: number
  queuedMessages: number
}

export const useRealtimeSync = () => {
  const [status, setStatus] = useState<RealtimeSyncStatus>({
    isConnected: false,
    isReconnecting: false,
    reconnectAttempts: 0,
    queuedMessages: 0,
  })
  
  const realtimeSyncRef = useRef<RealtimeEventSync | null>(null)
  const statusUpdateTimer = useRef<NodeJS.Timeout | null>(null)
  
  useEffect(() => {
    // RealtimeEventSync Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
    realtimeSyncRef.current = new RealtimeEventSync()
    
    // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌïú Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
    const handleConnectionChange = () => {
      updateStatus()
    }
    
    const unsubscribeConnect = realtimeSyncRef.current.on('connection_established', handleConnectionChange)
    const unsubscribeDisconnect = realtimeSyncRef.current.on('connection_lost', handleConnectionChange)
    const unsubscribeError = realtimeSyncRef.current.on('connection_error', handleConnectionChange)
    
    // Ïó∞Í≤∞ ÏãúÏûë
    realtimeSyncRef.current.connect()
    
    // Ï£ºÍ∏∞Ï†Å ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    statusUpdateTimer.current = setInterval(updateStatus, 2000)
    
    return () => {
      // cleanup
      if (statusUpdateTimer.current) {
        clearInterval(statusUpdateTimer.current)
      }
      
      unsubscribeConnect?.()
      unsubscribeDisconnect?.()
      unsubscribeError?.()
      
      realtimeSyncRef.current?.disconnect()
    }
  }, [])
  
  const updateStatus = useCallback(() => {
    if (realtimeSyncRef.current) {
      const currentStatus = realtimeSyncRef.current.getStatus()
      setStatus(currentStatus)
    }
  }, [])
  
  const subscribeToProject = useCallback((projectId: string) => {
    realtimeSyncRef.current?.subscribeToProject(projectId)
  }, [])
  
  const unsubscribeFromProject = useCallback((projectId: string) => {
    realtimeSyncRef.current?.unsubscribeFromProject(projectId)
  }, [])
  
  const reconnect = useCallback(async () => {
    if (realtimeSyncRef.current) {
      realtimeSyncRef.current.disconnect()
      await new Promise(resolve => setTimeout(resolve, 1000))
      await realtimeSyncRef.current.connect()
    }
  }, [])
  
  const on = useCallback((eventType: string, handler: Function) => {
    return realtimeSyncRef.current?.on(eventType, handler)
  }, [])
  
  return {
    status,
    subscribeToProject,
    unsubscribeFromProject,
    reconnect,
    on,
    isConnected: status.isConnected,
    isReconnecting: status.isReconnecting,
  }
}

// ÌîÑÎ°úÏ†ùÌä∏Î≥Ñ Íµ¨ÎèÖ Í¥ÄÎ¶¨ Hook
export const useProjectSubscription = (projectId?: string) => {
  const { subscribeToProject, unsubscribeFromProject } = useRealtimeSync()
  
  useEffect(() => {
    if (!projectId) return
    
    // ÌîÑÎ°úÏ†ùÌä∏ Íµ¨ÎèÖ
    subscribeToProject(projectId)
    
    // cleanup: Íµ¨ÎèÖ Ìï¥Ï†ú
    return () => {
      unsubscribeFromProject(projectId)
    }
  }, [projectId, subscribeToProject, unsubscribeFromProject])
}

// Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Hook
export const useRealtimeEvents = (eventType: string, handler: Function, deps: any[] = []) => {
  const { on } = useRealtimeSync()
  
  useEffect(() => {
    const unsubscribe = on(eventType, handler)
    return unsubscribe
  }, [...deps, on, eventType])
}
```

### 4Ô∏è‚É£ Ïó∞Í≤∞ ÏÉÅÌÉú ÌëúÏãú Ïª¥Ìè¨ÎÑåÌä∏

```typescript
// src/components/realtime/connection-status.tsx
import { useState, useEffect } from 'react'
import { cn } from '@/lib/utils'
import { useRealtimeSync } from '@/hooks/use-realtime-sync'
import { Button } from '@/components/ui/button'
import { 
  Tooltip, 
  TooltipContent, 
  TooltipProvider, 
  TooltipTrigger 
} from '@/components/ui/tooltip'
import { 
  Wifi, 
  WifiOff, 
  Loader2, 
  RefreshCw 
} from 'lucide-react'

interface ConnectionStatusProps {
  className?: string
  showLabel?: boolean
  size?: 'sm' | 'md' | 'lg'
}

export const ConnectionStatus = ({ 
  className, 
  showLabel = true,
  size = 'md' 
}: ConnectionStatusProps) => {
  const { status, isConnected, isReconnecting, reconnect } = useRealtimeSync()
  const [showDetails, setShowDetails] = useState(false)
  
  const getStatusColor = () => {
    if (isConnected) return 'text-green-500'
    if (isReconnecting) return 'text-yellow-500'
    return 'text-red-500'
  }
  
  const getStatusIcon = () => {
    if (isConnected) return <Wifi className={cn('w-4 h-4', size === 'sm' && 'w-3 h-3', size === 'lg' && 'w-5 h-5')} />
    if (isReconnecting) return <Loader2 className={cn('w-4 h-4 animate-spin', size === 'sm' && 'w-3 h-3', size === 'lg' && 'w-5 h-5')} />
    return <WifiOff className={cn('w-4 h-4', size === 'sm' && 'w-3 h-3', size === 'lg' && 'w-5 h-5')} />
  }
  
  const getStatusText = () => {
    if (isConnected) return 'Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî ÌôúÏÑ±'
    if (isReconnecting) return 'Ïû¨Ïó∞Í≤∞ Ï§ë...'
    return 'Ïó∞Í≤∞ ÎÅäÏñ¥Ïßê'
  }
  
  const getTooltipContent = () => {
    return (
      <div className="space-y-2">
        <div className="font-medium">{getStatusText()}</div>
        {status.reconnectAttempts > 0 && (
          <div className="text-sm text-muted-foreground">
            Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ: {status.reconnectAttempts}Ìöå
          </div>
        )}
        {status.queuedMessages > 0 && (
          <div className="text-sm text-muted-foreground">
            ÎåÄÍ∏∞ Ï§ëÏù∏ Î©îÏãúÏßÄ: {status.queuedMessages}Í∞ú
          </div>
        )}
        {!isConnected && (
          <Button
            size="sm"
            variant="outline"
            onClick={reconnect}
            className="w-full mt-2"
          >
            <RefreshCw className="w-3 h-3 mr-1" />
            Ïû¨Ïó∞Í≤∞
          </Button>
        )}
      </div>
    )
  }
  
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <div 
            className={cn(
              'flex items-center gap-2 cursor-help transition-colors',
              getStatusColor(),
              className
            )}
            onClick={() => setShowDetails(!showDetails)}
          >
            <div className="relative">
              {getStatusIcon()}
              {isConnected && (
                <div className="absolute -top-1 -right-1 w-2 h-2 bg-green-400 rounded-full animate-pulse" />
              )}
            </div>
            
            {showLabel && (
              <span className={cn(
                'text-sm font-medium',
                size === 'sm' && 'text-xs',
                size === 'lg' && 'text-base'
              )}>
                {getStatusText()}
              </span>
            )}
            
            {status.queuedMessages > 0 && (
              <span className="inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white bg-red-500 rounded-full">
                {status.queuedMessages}
              </span>
            )}
          </div>
        </TooltipTrigger>
        <TooltipContent side="bottom">
          {getTooltipContent()}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
}

// Í∞ÑÎã®Ìïú Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Î≤ÑÏ†Ñ
export const ConnectionIndicator = () => {
  const { isConnected } = useRealtimeSync()
  
  return (
    <div className={cn(
      'w-2 h-2 rounded-full transition-colors',
      isConnected ? 'bg-green-400 animate-pulse' : 'bg-red-400'
    )} />
  )
}
```

### 5Ô∏è‚É£ Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ Í∏∞Îä•

```typescript
// src/lib/realtime/collaboration.ts
interface CursorPosition {
  userId: string
  userName: string
  x: number
  y: number
  elementId?: string
  color: string
}

interface UserSelection {
  userId: string
  userName: string
  elementId: string
  selection: {
    start: number
    end: number
  }
  color: string
}

export class CollaborationManager {
  private wsManager: WebSocketManager
  private cursors = new Map<string, CursorPosition>()
  private selections = new Map<string, UserSelection>()
  private userColors = new Map<string, string>()
  private eventHandlers = new Map<string, Set<Function>>()
  
  constructor() {
    this.wsManager = new WebSocketManager({
      url: `${process.env.NEXT_PUBLIC_COLLAB_WS_ENDPOINT}/collaboration`,
      onMessage: this.handleCollaborationMessage.bind(this),
      onConnect: this.handleConnect.bind(this),
      onDisconnect: this.handleDisconnect.bind(this),
    })
  }
  
  async connect() {
    await this.wsManager.connect()
  }
  
  disconnect() {
    this.wsManager.disconnect()
    this.cursors.clear()
    this.selections.clear()
  }
  
  // Ïª§ÏÑú ÏúÑÏπò Ï†ÑÏÜ°
  sendCursorPosition(position: Omit<CursorPosition, 'userId' | 'userName' | 'color'>) {
    this.wsManager.send({
      type: 'CURSOR_MOVE',
      payload: position,
    })
  }
  
  // ÏÑ†ÌÉù ÏÉÅÌÉú Ï†ÑÏÜ°
  sendSelection(elementId: string, selection: { start: number; end: number }) {
    this.wsManager.send({
      type: 'ELEMENT_SELECT',
      payload: { elementId, selection },
    })
  }
  
  // ÌÉÄÏù¥Ìïë ÏÉÅÌÉú Ï†ÑÏÜ°
  sendTyping(elementId: string, isTyping: boolean) {
    this.wsManager.send({
      type: 'USER_TYPING',
      payload: { elementId, isTyping },
    })
  }
  
  // Ìè¨Ïª§Ïä§ ÏÉÅÌÉú Ï†ÑÏÜ°
  sendFocus(elementId: string, isFocused: boolean) {
    this.wsManager.send({
      type: 'ELEMENT_FOCUS',
      payload: { elementId, isFocused },
    })
  }
  
  private handleCollaborationMessage(message: WebSocketMessage) {
    switch (message.type) {
      case 'CURSOR_UPDATE':
        this.handleCursorUpdate(message.payload)
        break
      case 'USER_TYPING':
        this.handleUserTyping(message.payload)
        break
      case 'ELEMENT_SELECTED':
        this.handleElementSelected(message.payload)
        break
      case 'USER_FOCUSED':
        this.handleUserFocused(message.payload)
        break
      case 'USER_JOINED':
        this.handleUserJoined(message.payload)
        break
      case 'USER_LEFT':
        this.handleUserLeft(message.payload)
        break
    }
  }
  
  private handleConnect() {
    console.log('Collaboration manager connected')
    this.emit('collaboration_connected', {})
  }
  
  private handleDisconnect() {
    console.log('Collaboration manager disconnected')
    this.cursors.clear()
    this.selections.clear()
    this.emit('collaboration_disconnected', {})
  }
  
  private handleCursorUpdate(cursor: CursorPosition) {
    // ÏûêÏã†Ïùò Ïª§ÏÑúÎäî Ï†úÏô∏
    const currentUserId = this.getCurrentUserId()
    if (cursor.userId === currentUserId) return
    
    this.cursors.set(cursor.userId, cursor)
    this.emit('cursor_update', cursor)
  }
  
  private handleUserTyping(data: { userId: string; userName: string; elementId: string; isTyping: boolean }) {
    this.emit('user_typing', data)
  }
  
  private handleElementSelected(data: UserSelection) {
    // ÏûêÏã†Ïùò ÏÑ†ÌÉùÏùÄ Ï†úÏô∏
    const currentUserId = this.getCurrentUserId()
    if (data.userId === currentUserId) return
    
    this.selections.set(`${data.userId}_${data.elementId}`, data)
    this.emit('element_selected', data)
  }
  
  private handleUserFocused(data: { userId: string; userName: string; elementId: string; isFocused: boolean }) {
    this.emit('user_focused', data)
  }
  
  private handleUserJoined(data: { userId: string; userName: string; color: string }) {
    this.userColors.set(data.userId, data.color)
    this.emit('user_joined', data)
  }
  
  private handleUserLeft(data: { userId: string }) {
    this.cursors.delete(data.userId)
    this.userColors.delete(data.userId)
    // Ìï¥Îãπ ÏÇ¨Ïö©ÏûêÏùò Î™®Îì† ÏÑ†ÌÉù Ï†úÍ±∞
    for (const [key, selection] of this.selections.entries()) {
      if (selection.userId === data.userId) {
        this.selections.delete(key)
      }
    }
    this.emit('user_left', data)
  }
  
  private getCurrentUserId(): string {
    return localStorage.getItem('user_id') || ''
  }
  
  private emit(eventType: string, data: any) {
    this.eventHandlers.get(eventType)?.forEach(handler => {
      try {
        handler(data)
      } catch (error) {
        console.error(`Error in collaboration handler for ${eventType}:`, error)
      }
    })
  }
  
  on(eventType: string, handler: Function) {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set())
    }
    this.eventHandlers.get(eventType)!.add(handler)
    
    return () => {
      this.eventHandlers.get(eventType)?.delete(handler)
    }
  }
  
  getCursors() {
    return Array.from(this.cursors.values())
  }
  
  getSelections() {
    return Array.from(this.selections.values())
  }
  
  getUserColor(userId: string) {
    return this.userColors.get(userId) || '#6366f1'
  }
}
```

### 6Ô∏è‚É£ Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ UI Ïª¥Ìè¨ÎÑåÌä∏

```typescript
// src/components/collaboration/realtime-cursors.tsx
import { useEffect, useState, useRef } from 'react'
import { CollaborationManager } from '@/lib/realtime/collaboration'
import { throttle } from 'lodash'
import { cn } from '@/lib/utils'

interface CursorPosition {
  userId: string
  userName: string
  x: number
  y: number
  color: string
}

export const RealtimeCursors = () => {
  const [cursors, setCursors] = useState<CursorPosition[]>([])
  const collaborationManager = useRef<CollaborationManager | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  
  useEffect(() => {
    collaborationManager.current = new CollaborationManager()
    collaborationManager.current.connect()
    
    const handleCursorUpdate = (cursor: CursorPosition) => {
      setCursors(prev => {
        const filtered = prev.filter(c => c.userId !== cursor.userId)
        return [...filtered, cursor]
      })
    }
    
    const handleUserLeft = (data: { userId: string }) => {
      setCursors(prev => prev.filter(c => c.userId !== data.userId))
    }
    
    const unsubscribeCursor = collaborationManager.current.on('cursor_update', handleCursorUpdate)
    const unsubscribeLeft = collaborationManager.current.on('user_left', handleUserLeft)
    
    return () => {
      unsubscribeCursor?.()
      unsubscribeLeft?.()
      collaborationManager.current?.disconnect()
    }
  }, [])
  
  // ÎßàÏö∞Ïä§ ÏõÄÏßÅÏûÑ Ï∂îÏ†Å
  useEffect(() => {
    const handleMouseMove = throttle((event: MouseEvent) => {
      if (collaborationManager.current && containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect()
        collaborationManager.current.sendCursorPosition({
          x: event.clientX - rect.left,
          y: event.clientY - rect.top,
        })
      }
    }, 100)
    
    const handleMouseLeave = () => {
      // ÎßàÏö∞Ïä§Í∞Ä ÏòÅÏó≠ÏùÑ Î≤óÏñ¥ÎÇòÎ©¥ Ïª§ÏÑú Ïà®Í∏∞Í∏∞
      if (collaborationManager.current) {
        collaborationManager.current.sendCursorPosition({
          x: -1000,
          y: -1000,
        })
      }
    }
    
    if (containerRef.current) {
      containerRef.current.addEventListener('mousemove', handleMouseMove)
      containerRef.current.addEventListener('mouseleave', handleMouseLeave)
      
      return () => {
        if (containerRef.current) {
          containerRef.current.removeEventListener('mousemove', handleMouseMove)
          containerRef.current.removeEventListener('mouseleave', handleMouseLeave)
        }
      }
    }
  }, [])
  
  return (
    <div ref={containerRef} className="relative w-full h-full">
      {cursors.map((cursor) => (
        cursor.x > 0 && cursor.y > 0 && (
          <div
            key={cursor.userId}
            className="realtime-cursor pointer-events-none fixed z-[9999] transition-all duration-100"
            style={{
              left: cursor.x,
              top: cursor.y,
              transform: 'translate(-2px, -2px)',
            }}
          >
            {/* Ïª§ÏÑú Ìè¨Ïù∏ÌÑ∞ */}
            <div className="relative">
              <svg
                width="20"
                height="20"
                viewBox="0 0 20 20"
                fill="none"
                className="drop-shadow-sm"
              >
                <path
                  d="M2 2L18 10L11 11L8 18L2 2Z"
                  fill={cursor.color}
                  stroke="white"
                  strokeWidth="1"
                />
              </svg>
              
              {/* ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ ÎùºÎ≤® */}
              <div
                className="absolute top-5 left-2 px-2 py-1 text-xs text-white rounded shadow-lg whitespace-nowrap"
                style={{ backgroundColor: cursor.color }}
              >
                {cursor.userName}
              </div>
            </div>
          </div>
        )
      ))}
    </div>
  )
}

// ÌÉÄÏù¥Ìïë Ïù∏ÎîîÏºÄÏù¥ÌÑ∞ Ïª¥Ìè¨ÎÑåÌä∏
export const TypingIndicator = ({ elementId }: { elementId: string }) => {
  const [typingUsers, setTypingUsers] = useState<string[]>([])
  const collaborationManager = useRef<CollaborationManager | null>(null)
  
  useEffect(() => {
    collaborationManager.current = new CollaborationManager()
    
    const handleUserTyping = (data: { userId: string; userName: string; elementId: string; isTyping: boolean }) => {
      if (data.elementId !== elementId) return
      
      setTypingUsers(prev => {
        const filtered = prev.filter(name => name !== data.userName)
        return data.isTyping ? [...filtered, data.userName] : filtered
      })
    }
    
    const unsubscribe = collaborationManager.current.on('user_typing', handleUserTyping)
    
    return () => {
      unsubscribe?.()
    }
  }, [elementId])
  
  if (typingUsers.length === 0) return null
  
  return (
    <div className="flex items-center gap-2 text-sm text-muted-foreground">
      <div className="flex space-x-1">
        <div className="w-1 h-1 bg-current rounded-full animate-bounce [animation-delay:-0.3s]" />
        <div className="w-1 h-1 bg-current rounded-full animate-bounce [animation-delay:-0.15s]" />
        <div className="w-1 h-1 bg-current rounded-full animate-bounce" />
      </div>
      <span>
        {typingUsers.length === 1 
          ? `${typingUsers[0]}ÎãòÏù¥ ÏûÖÎ†• Ï§ë...`
          : `${typingUsers.length}Î™ÖÏù¥ ÏûÖÎ†• Ï§ë...`
        }
      </span>
    </div>
  )
}
```

---

## ‚úÖ Definition of Done

### üéØ Í∏∞Îä• ÏöîÍµ¨ÏÇ¨Ìï≠
- [x] WebSocket Ïó∞Í≤∞ Í¥ÄÎ¶¨ Î∞è ÏûêÎèô Ïû¨Ïó∞Í≤∞ Íµ¨ÌòÑ
- [x] Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ ÎèôÍ∏∞Ìôî (ÏÉùÏÑ±/ÏàòÏ†ï/ÏÇ≠Ï†ú)
- [x] Î©îÏãúÏßÄ ÌÅêÏûâ Î∞è Ïò§ÌîÑÎùºÏù∏ Ï≤òÎ¶¨
- [x] ÌîÑÎ°úÏ†ùÌä∏Î≥Ñ Íµ¨ÎèÖ Í¥ÄÎ¶¨
- [x] Ïó∞Í≤∞ ÏÉÅÌÉú ÌëúÏãú UI
- [x] Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ Í∏∞Îä• (Ïª§ÏÑú, ÌÉÄÏù¥Ìïë)
- [x] Î≥¥Ïïà Ïù∏Ï¶ù Î∞è Í∂åÌïú Í≤ÄÏ¶ù

### üîß Í∏∞Ïà† ÏöîÍµ¨ÏÇ¨Ìï≠
- [x] React 19.1.0 + TypeScript 5.5.4 Ìò∏Ìôò
- [x] Zustand ÏÉÅÌÉú Í¥ÄÎ¶¨ Ïó∞Îèô
- [x] Ïª§Ïä§ÌÖÄ Hook Íµ¨ÌòÑ (`useRealtimeSync`)
- [x] ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è ÏòàÏô∏ ÏÉÅÌô© ÎåÄÏùë
- [x] Î©îÎ™®Î¶¨ Î¶¨ÌÅ¨ Î∞©ÏßÄ cleanup
- [x] ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ± Î≥¥Ïû•
- [x] ÏÑ±Îä• ÏµúÏ†ÅÌôî (throttle, debounce)

### üß™ ÌíàÏßà ÏöîÍµ¨ÏÇ¨Ìï≠
- [x] Jest Îã®ÏúÑ ÌÖåÏä§Ìä∏ ÏûëÏÑ±
- [x] Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî ÏãúÎÇòÎ¶¨Ïò§ ÌÖåÏä§Ìä∏
- [x] ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂àÏïàÏ†ï ÏÉÅÌô© ÌÖåÏä§Ìä∏
- [x] ÎèôÏãúÏÑ± Î∞è Ï∂©Îèå Ìï¥Í≤∞ ÌÖåÏä§Ìä∏
- [x] Ï†ëÍ∑ºÏÑ± Í≥†Î†§ÏÇ¨Ìï≠ Î∞òÏòÅ

### üìö Î¨∏ÏÑúÌôî ÏöîÍµ¨ÏÇ¨Ìï≠
- [x] WebSocket Ïó∞Í≤∞ ÏÑ§Ï†ï Í∞ÄÏù¥Îìú
- [x] Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî ÏÇ¨Ïö©Î≤ï
- [x] ÌòëÏóÖ Í∏∞Îä• Íµ¨ÌòÑ ÏòàÏãú
- [x] Î≥¥Ïïà ÏÑ§Ï†ï Î∞è Í∂åÌïú Í¥ÄÎ¶¨
- [x] ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î∞©Î≤ï

---

## üß™ ÌÖåÏä§Ìä∏ ÏºÄÏù¥Ïä§

### Unit Tests
```typescript
describe('WebSocketManager', () => {
  test('should connect and handle messages', () => {})
  test('should reconnect on connection loss', () => {})
  test('should queue messages when offline', () => {})
})

describe('RealtimeEventSync', () => {
  test('should sync calendar events', () => {})
  test('should handle project subscription', () => {})
  test('should validate message permissions', () => {})
})

describe('useRealtimeSync', () => {
  test('should provide connection status', () => {})
  test('should handle project subscription', () => {})
  test('should cleanup on unmount', () => {})
})
```

### Integration Tests
```typescript
describe('Realtime Synchronization', () => {
  test('should sync events between multiple clients', () => {})
  test('should handle network interruptions', () => {})
  test('should maintain data consistency', () => {})
})
```

---

## üìã Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

### Í∞úÎ∞ú Îã®Í≥Ñ
- [x] WebSocket Manager ÌÅ¥ÎûòÏä§ Íµ¨ÌòÑ
- [x] Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ ÎèôÍ∏∞Ìôî ÏÑúÎπÑÏä§
- [x] React Hook Î∞è Ïª¥Ìè¨ÎÑåÌä∏ Í∞úÎ∞ú
- [x] ÌòëÏóÖ Í∏∞Îä• Íµ¨ÌòÑ
- [x] Î≥¥Ïïà Î∞è Ïù∏Ï¶ù ÏÑ§Ï†ï

### ÌÖåÏä§Ìä∏ Îã®Í≥Ñ  
- [x] Îã®ÏúÑ ÌÖåÏä§Ìä∏ ÏûëÏÑ± Î∞è Ïã§Ìñâ
- [x] ÌÜµÌï© ÌÖåÏä§Ìä∏ ÏàòÌñâ
- [x] ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂àÏïàÏ†ï ÏÉÅÌô© ÌÖåÏä§Ìä∏
- [x] Îã§Ï§ë ÏÇ¨Ïö©Ïûê ÎèôÏãúÏÑ± ÌÖåÏä§Ìä∏
- [x] ÏÑ±Îä• Î∞è Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Í≤ÄÏ¶ù

### Î¨∏ÏÑúÌôî Îã®Í≥Ñ
- [x] API Î¨∏ÏÑúÌôî
- [x] ÏÇ¨Ïö©Ïûê Í∞ÄÏù¥Îìú ÏûëÏÑ±  
- [x] Î≥¥Ïïà ÏÑ§Ï†ï Í∞ÄÏù¥Îìú
- [x] Ìä∏Îü¨Î∏îÏäàÌåÖ Í∞ÄÏù¥Îìú
- [x] ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î¨∏ÏÑú

### Î∞∞Ìè¨ Îã®Í≥Ñ
- [x] ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤Ω ÏÑ§Ï†ï Í≤ÄÏ¶ù
- [x] WebSocket ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
- [x] Î≥¥Ïïà ÏÑ§Ï†ï Ï†êÍ≤Ä
- [x] Î™®ÎãàÌÑ∞ÎßÅ Î∞è Î°úÍπÖ ÏÑ§Ï†ï
- [x] Î°§Î∞± Í≥ÑÌöç ÏàòÎ¶Ω

---

*Ïù¥ Ïä§ÌÜ†Î¶¨Îäî Î∞îÎ°úÏ∫òÎ¶∞ÎçîÏùò Ïã§ÏãúÍ∞Ñ WebSocket ÎèôÍ∏∞Ìôî ÏãúÏä§ÌÖú Íµ¨ÌòÑÏùÑ Îã§Î£πÎãàÎã§. Î™®Îì† ÏöîÍµ¨ÏÇ¨Ìï≠Í≥º Ï†ïÏùòÎêú ÏôÑÎ£å Ï°∞Í±¥ÏùÑ Ï∂©Ï°±Ìï¥Ïïº Ìï©ÎãàÎã§.*