# üîÑ **8c. Realtime WebSocket Synchronization**

## üìã Î¨∏ÏÑú Ï†ïÎ≥¥
- **Î¨∏ÏÑú Î≤ÑÏ†Ñ**: 1.0
- **ÏûëÏÑ±Ïùº**: 2025-08-19
- **ÏûëÏÑ±Ïûê**: Architect Winston
- **ÌîÑÎ°úÏ†ùÌä∏Î™Ö**: Î∞îÎ°úÏ∫òÎ¶∞Îçî (Baro Calendar)
- **ÏÉÅÌÉú**: Active
- **Ïπ¥ÌÖåÍ≥†Î¶¨**: ÌîÑÎ°†Ìä∏ÏóîÎìú ÏïÑÌÇ§ÌÖçÏ≤ò - Ïã§ÏãúÍ∞Ñ WebSocket ÎèôÍ∏∞Ìôî

---

## üéØ **Í∞úÏöî**

Ïù¥ Î¨∏ÏÑúÎäî Î∞îÎ°úÏ∫òÎ¶∞Îçî ÌîÑÎ°úÏ†ùÌä∏Ïùò **Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî Î∞è WebSocket Íµ¨ÌòÑ** ÏïÑÌÇ§ÌÖçÏ≤òÎ•º Ï†ïÏùòÌï©ÎãàÎã§. WebSocketÏùÑ ÌÜµÌïú Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏, ÏûêÎèô Ïû¨Ïó∞Í≤∞, Î©îÏãúÏßÄ ÌÅêÏûâÏùÑ ÌÜµÌï¥ ÏïàÏ†ïÏ†ÅÏù∏ Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.

---

## üîå **WebSocket Ïó∞Í≤∞ Í¥ÄÎ¶¨**

### **WebSocket Manager ÌÅ¥ÎûòÏä§**
```typescript
// src/lib/realtime/websocket.ts
interface WebSocketMessage {
  type: string
  payload: any
  timestamp: number
  id: string
}

interface WebSocketConfig {
  url: string
  reconnectInterval?: number
  maxReconnectAttempts?: number
  onMessage?: (message: WebSocketMessage) => void
  onConnect?: () => void
  onDisconnect?: () => void
  onError?: (error: Event) => void
}

export class WebSocketManager {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private reconnectTimer: NodeJS.Timeout | null = null
  private messageQueue: WebSocketMessage[] = []
  private isConnected = false
  
  constructor(private config: WebSocketConfig) {}
  
  connect() {
    try {
      this.ws = new WebSocket(this.config.url)
      
      this.ws.onopen = () => {
        this.isConnected = true
        this.reconnectAttempts = 0
        this.config.onConnect?.()
        
        // ÌÅêÏóê ÏûàÎäî Î©îÏãúÏßÄÎì§ Ï†ÑÏÜ°
        this.flushMessageQueue()
      }
      
      this.ws.onmessage = (event) => {
        try {
          const message: WebSocketMessage = JSON.parse(event.data)
          this.config.onMessage?.(message)
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error)
        }
      }
      
      this.ws.onclose = () => {
        this.isConnected = false
        this.config.onDisconnect?.()
        this.scheduleReconnect()
      }
      
      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error)
        this.config.onError?.(error)
      }
    } catch (error) {
      console.error('Failed to create WebSocket connection:', error)
      this.scheduleReconnect()
    }
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close()
      this.ws = null
    }
    
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer)
      this.reconnectTimer = null
    }
  }
  
  send(message: Omit<WebSocketMessage, 'timestamp' | 'id'>) {
    const fullMessage: WebSocketMessage = {
      ...message,
      timestamp: Date.now(),
      id: crypto.randomUUID(),
    }
    
    if (this.isConnected && this.ws) {
      this.ws.send(JSON.stringify(fullMessage))
    } else {
      // Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÑ Í≤ΩÏö∞ ÌÅêÏóê Ï†ÄÏû•
      this.messageQueue.push(fullMessage)
    }
  }
  
  private scheduleReconnect() {
    if (this.reconnectAttempts >= (this.config.maxReconnectAttempts || 5)) {
      console.error('Max reconnection attempts reached')
      return
    }
    
    const interval = this.config.reconnectInterval || 1000
    const delay = interval * Math.pow(2, this.reconnectAttempts)
    
    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++
      this.connect()
    }, delay)
  }
  
  private flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift()
      if (message && this.ws) {
        this.ws.send(JSON.stringify(message))
      }
    }
  }
  
  getConnectionStatus() {
    return {
      isConnected: this.isConnected,
      reconnectAttempts: this.reconnectAttempts,
    }
  }
}
```

---

## üîÑ **Ïã§ÏãúÍ∞Ñ Ïù¥Î≤§Ìä∏ ÎèôÍ∏∞Ìôî**

### **RealtimeEventSync ÌÅ¥ÎûòÏä§**
```typescript
// src/lib/realtime/eventSync.ts
export class RealtimeEventSync {
  private wsManager: WebSocketManager
  
  constructor() {
    this.wsManager = new WebSocketManager({
      url: process.env.NEXT_PUBLIC_WS_ENDPOINT || 'ws://localhost:4000',
      onMessage: this.handleMessage.bind(this),
      onConnect: this.handleConnect.bind(this),
      onDisconnect: this.handleDisconnect.bind(this),
    })
  }
  
  connect() {
    this.wsManager.connect()
  }
  
  disconnect() {
    this.wsManager.disconnect()
  }
  
  subscribeToProject(projectId: string) {
    this.wsManager.send({
      type: 'SUBSCRIBE_PROJECT',
      payload: { projectId },
    })
  }
  
  unsubscribeFromProject(projectId: string) {
    this.wsManager.send({
      type: 'UNSUBSCRIBE_PROJECT',
      payload: { projectId },
    })
  }
  
  private handleMessage(message: WebSocketMessage) {
    switch (message.type) {
      case 'EVENT_CREATED':
        this.handleEventCreated(message.payload)
        break
      case 'EVENT_UPDATED':
        this.handleEventUpdated(message.payload)
        break
      case 'EVENT_DELETED':
        this.handleEventDeleted(message.payload)
        break
      case 'PROJECT_UPDATED':
        this.handleProjectUpdated(message.payload)
        break
      case 'USER_JOINED_PROJECT':
        this.handleUserJoinedProject(message.payload)
        break
      default:
        console.warn('Unknown message type:', message.type)
    }
  }
  
  private handleConnect() {
    console.log('Realtime connection established')
    
    // ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏Ïóê Íµ¨ÎèÖ
    const currentProject = useProjectStore.getState().selectedProject
    if (currentProject) {
      this.subscribeToProject(currentProject.id)
    }
  }
  
  private handleDisconnect() {
    console.log('Realtime connection lost')
  }
  
  private handleEventCreated(event: any) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useCalendarStore.getState().addEvent(event)
    
    // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º
    toast.success('ÏÉàÎ°úÏö¥ Ïù¥Î≤§Ìä∏Í∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§')
  }
  
  private handleEventUpdated(event: any) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useCalendarStore.getState().updateEvent(event.id, event)
    
    // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º
    toast.info('Ïù¥Î≤§Ìä∏Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§')
  }
  
  private handleEventDeleted(eventId: string) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useCalendarStore.getState().deleteEvent(eventId)
    
    // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º
    toast.warning('Ïù¥Î≤§Ìä∏Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§')
  }
  
  private handleProjectUpdated(project: any) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useProjectStore.getState().updateProject(project.id, project)
  }
  
  private handleUserJoinedProject(data: any) {
    // Zustand Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
    useProjectStore.getState().fetchMembers(data.projectId)
    
    // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º
    toast.success(`${data.user.name}ÎãòÏù¥ ÌîÑÎ°úÏ†ùÌä∏Ïóê Ï∞∏Ïó¨ÌñàÏäµÎãàÎã§`)
  }
}
```

---

## üé£ **Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî Hook**

### **useRealtimeSync Hook**
```typescript
// src/hooks/useRealtimeSync.ts
export const useRealtimeSync = () => {
  const [isConnected, setIsConnected] = useState(false)
  const realtimeSync = useRef<RealtimeEventSync | null>(null)
  
  useEffect(() => {
    realtimeSync.current = new RealtimeEventSync()
    realtimeSync.current.connect()
    
    return () => {
      realtimeSync.current?.disconnect()
    }
  }, [])
  
  const subscribeToProject = useCallback((projectId: string) => {
    realtimeSync.current?.subscribeToProject(projectId)
  }, [])
  
  const unsubscribeFromProject = useCallback((projectId: string) => {
    realtimeSync.current?.unsubscribeFromProject(projectId)
  }, [])
  
  return {
    isConnected,
    subscribeToProject,
    unsubscribeFromProject,
  }
}
```

### **ÌîÑÎ°úÏ†ùÌä∏ Íµ¨ÎèÖ Í¥ÄÎ¶¨**
```typescript
// src/hooks/useProjectSubscription.ts
export const useProjectSubscription = (projectId?: string) => {
  const { subscribeToProject, unsubscribeFromProject } = useRealtimeSync()
  
  useEffect(() => {
    if (!projectId) return
    
    // ÌîÑÎ°úÏ†ùÌä∏ Íµ¨ÎèÖ
    subscribeToProject(projectId)
    
    // cleanup: Íµ¨ÎèÖ Ìï¥Ï†ú
    return () => {
      unsubscribeFromProject(projectId)
    }
  }, [projectId, subscribeToProject, unsubscribeFromProject])
}
```

---

## üí¨ **Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ Í∏∞Îä•**

### **Ïã§ÏãúÍ∞Ñ Ïª§ÏÑú Ï∂îÏ†Å**
```typescript
// src/lib/realtime/collaboration.ts
interface CursorPosition {
  userId: string
  x: number
  y: number
  elementId?: string
}

export class CollaborationManager {
  private wsManager: WebSocketManager
  private cursors = new Map<string, CursorPosition>()
  
  constructor() {
    this.wsManager = new WebSocketManager({
      url: process.env.NEXT_PUBLIC_COLLAB_WS_ENDPOINT || 'ws://localhost:4001',
      onMessage: this.handleCollaborationMessage.bind(this),
    })
  }
  
  sendCursorPosition(position: Omit<CursorPosition, 'userId'>) {
    this.wsManager.send({
      type: 'CURSOR_MOVE',
      payload: position,
    })
  }
  
  sendSelection(elementId: string, selection: any) {
    this.wsManager.send({
      type: 'ELEMENT_SELECT',
      payload: { elementId, selection },
    })
  }
  
  sendTyping(elementId: string, isTyping: boolean) {
    this.wsManager.send({
      type: 'USER_TYPING',
      payload: { elementId, isTyping },
    })
  }
  
  private handleCollaborationMessage(message: WebSocketMessage) {
    switch (message.type) {
      case 'CURSOR_UPDATE':
        this.updateCursor(message.payload)
        break
      case 'USER_TYPING':
        this.handleUserTyping(message.payload)
        break
      case 'ELEMENT_SELECTED':
        this.handleElementSelected(message.payload)
        break
    }
  }
  
  private updateCursor(cursor: CursorPosition) {
    this.cursors.set(cursor.userId, cursor)
    // UI ÏóÖÎç∞Ïù¥Ìä∏ Ìä∏Î¶¨Í±∞
    window.dispatchEvent(new CustomEvent('cursor-update', { detail: cursor }))
  }
  
  private handleUserTyping(data: any) {
    window.dispatchEvent(new CustomEvent('user-typing', { detail: data }))
  }
  
  private handleElementSelected(data: any) {
    window.dispatchEvent(new CustomEvent('element-selected', { detail: data }))
  }
  
  getCursors() {
    return Array.from(this.cursors.values())
  }
}
```

### **Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ Ïª¥Ìè¨ÎÑåÌä∏**
```typescript
// src/components/collaboration/RealtimeCursors.tsx
export const RealtimeCursors = () => {
  const [cursors, setCursors] = useState<CursorPosition[]>([])
  const collaborationManager = useRef<CollaborationManager | null>(null)
  
  useEffect(() => {
    collaborationManager.current = new CollaborationManager()
    
    const handleCursorUpdate = (event: CustomEvent) => {
      setCursors(collaborationManager.current?.getCursors() || [])
    }
    
    window.addEventListener('cursor-update', handleCursorUpdate as EventListener)
    
    return () => {
      window.removeEventListener('cursor-update', handleCursorUpdate as EventListener)
    }
  }, [])
  
  // ÎßàÏö∞Ïä§ ÏõÄÏßÅÏûÑ Ï∂îÏ†Å
  useEffect(() => {
    const handleMouseMove = throttle((event: MouseEvent) => {
      collaborationManager.current?.sendCursorPosition({
        x: event.clientX,
        y: event.clientY,
      })
    }, 50)
    
    document.addEventListener('mousemove', handleMouseMove)
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove)
    }
  }, [])
  
  return (
    <>
      {cursors.map((cursor) => (
        <div
          key={cursor.userId}
          className="realtime-cursor"
          style={{
            position: 'fixed',
            left: cursor.x,
            top: cursor.y,
            pointerEvents: 'none',
            zIndex: 9999,
          }}
        >
          <div className="cursor-pointer" />
          <div className="cursor-label">
            User {cursor.userId.slice(0, 4)}
          </div>
        </div>
      ))}
    </>
  )
}
```

---

## üìä **Ïó∞Í≤∞ ÏÉÅÌÉú ÌëúÏãú**

### **Ïó∞Í≤∞ ÏÉÅÌÉú Ïª¥Ìè¨ÎÑåÌä∏**
```typescript
// src/components/realtime/ConnectionStatus.tsx
export const ConnectionStatus = () => {
  const { isConnected } = useRealtimeSync()
  const [showReconnecting, setShowReconnecting] = useState(false)
  
  useEffect(() => {
    if (!isConnected) {
      const timer = setTimeout(() => setShowReconnecting(true), 1000)
      return () => clearTimeout(timer)
    } else {
      setShowReconnecting(false)
    }
  }, [isConnected])
  
  if (isConnected) {
    return (
      <div className="connection-status connected">
        <div className="status-indicator" />
        <span>Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî ÌôúÏÑ±</span>
      </div>
    )
  }
  
  if (showReconnecting) {
    return (
      <div className="connection-status reconnecting">
        <div className="status-indicator pulse" />
        <span>Ïû¨Ïó∞Í≤∞ Ï§ë...</span>
      </div>
    )
  }
  
  return null
}
```

---

## üîê **Î≥¥Ïïà Í≥†Î†§ÏÇ¨Ìï≠**

### **Ïù∏Ï¶ù Î∞è Í∂åÌïú Í≤ÄÏ¶ù**
```typescript
// WebSocket Ïù∏Ï¶ù
const authWebSocket = new WebSocketManager({
  url: `${WS_ENDPOINT}?token=${getAuthToken()}`,
  onConnect: () => {
    // Ïó∞Í≤∞ Ïãú Ïù∏Ï¶ù ÌÜ†ÌÅ∞ Ï†ÑÏÜ°
    wsManager.send({
      type: 'AUTH',
      payload: { token: getAuthToken() },
    })
  },
})

// Î©îÏãúÏßÄ Í∂åÌïú Í≤ÄÏ¶ù
const validateMessagePermission = (message: WebSocketMessage): boolean => {
  // ÌîÑÎ°úÏ†ùÌä∏ Í∂åÌïú ÌôïÏù∏
  const userProjects = getUserProjects()
  return userProjects.some(p => p.id === message.payload.projectId)
}
```

---

## üìã **ÏöîÏïΩ**

Ïù¥ Î¨∏ÏÑúÎäî Î∞îÎ°úÏ∫òÎ¶∞ÎçîÏùò Ïã§ÏãúÍ∞Ñ WebSocket ÎèôÍ∏∞ÌôîÎ•º Ï†ïÏùòÌï©ÎãàÎã§:

### **üîå WebSocket Í¥ÄÎ¶¨**
- **ÏûêÎèô Ïû¨Ïó∞Í≤∞**: ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂àÏïàÏ†ï Ïãú ÏßÄÏàò Î∞±Ïò§ÌîÑ
- **Î©îÏãúÏßÄ ÌÅêÏûâ**: Ïò§ÌîÑÎùºÏù∏ Ïãú Î©îÏãúÏßÄ Ï†ÄÏû• ÌõÑ Ï†ÑÏÜ°
- **Ïó∞Í≤∞ ÏÉÅÌÉú Í¥ÄÎ¶¨**: Ïã§ÏãúÍ∞Ñ Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ

### **üîÑ Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî**
- **Ïù¥Î≤§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏**: Ïã§ÏãúÍ∞Ñ Ï∫òÎ¶∞Îçî Ïù¥Î≤§Ìä∏ ÎèôÍ∏∞Ìôî
- **ÌîÑÎ°úÏ†ùÌä∏ Íµ¨ÎèÖ**: ÏÑ†ÌÉùÏ†Å ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏ Íµ¨ÎèÖ
- **ÏÉÅÌÉú ÎèôÍ∏∞Ìôî**: Zustand Ïä§ÌÜ†Ïñ¥ÏôÄ ÏûêÎèô Ïó∞Îèô

### **üí¨ ÌòëÏóÖ Í∏∞Îä•**
- **Ïã§ÏãúÍ∞Ñ Ïª§ÏÑú**: Îã§Î•∏ ÏÇ¨Ïö©ÏûêÏùò ÎßàÏö∞Ïä§ ÏúÑÏπò ÌëúÏãú
- **ÌÉÄÏù¥Ìïë Ïù∏ÎîîÏºÄÏù¥ÌÑ∞**: Ïã§ÏãúÍ∞Ñ ÏûÖÎ†• ÏÉÅÌÉú ÌëúÏãú
- **ÏÑ†ÌÉù ÎèôÍ∏∞Ìôî**: ÏöîÏÜå ÏÑ†ÌÉù ÏÉÅÌÉú Í≥µÏú†